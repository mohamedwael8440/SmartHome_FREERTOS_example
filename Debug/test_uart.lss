
test_uart.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005dac  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000120  00800060  00005dac  00005e40  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000067b  00800180  00800180  00005f60  2**0
                  ALLOC
  3 .stab         000072cc  00000000  00000000  00005f60  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003846  00000000  00000000  0000d22c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00010a72  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00010bb2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00010d22  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  0001296b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  00013856  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00014604  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00014764  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  000149f1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  000151bf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 fa 11 	jmp	0x23f4	; 0x23f4 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec ea       	ldi	r30, 0xAC	; 172
      68:	fd e5       	ldi	r31, 0x5D	; 93
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 38       	cpi	r26, 0x80	; 128
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a0 e8       	ldi	r26, 0x80	; 128
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ab 3f       	cpi	r26, 0xFB	; 251
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 cd 2c 	call	0x599a	; 0x599a <main>
      8a:	0c 94 d4 2e 	jmp	0x5da8	; 0x5da8 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 8b 2e 	jmp	0x5d16	; 0x5d16 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a5 e7       	ldi	r26, 0x75	; 117
     128:	b1 e0       	ldi	r27, 0x01	; 1
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 a7 2e 	jmp	0x5d4e	; 0x5d4e <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 97 2e 	jmp	0x5d2e	; 0x5d2e <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 b3 2e 	jmp	0x5d66	; 0x5d66 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 97 2e 	jmp	0x5d2e	; 0x5d2e <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 b3 2e 	jmp	0x5d66	; 0x5d66 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 8b 2e 	jmp	0x5d16	; 0x5d16 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	85 e7       	ldi	r24, 0x75	; 117
     496:	91 e0       	ldi	r25, 0x01	; 1
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 a7 2e 	jmp	0x5d4e	; 0x5d4e <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 97 2e 	jmp	0x5d2e	; 0x5d2e <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 b3 2e 	jmp	0x5d66	; 0x5d66 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 97 2e 	jmp	0x5d2e	; 0x5d2e <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 b3 2e 	jmp	0x5d66	; 0x5d66 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 97 2e 	jmp	0x5d2e	; 0x5d2e <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 b3 2e 	jmp	0x5d66	; 0x5d66 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 9b 2e 	jmp	0x5d36	; 0x5d36 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 b7 2e 	jmp	0x5d6e	; 0x5d6e <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
     b46:	af 92       	push	r10
     b48:	bf 92       	push	r11
     b4a:	cf 92       	push	r12
     b4c:	df 92       	push	r13
     b4e:	ef 92       	push	r14
     b50:	ff 92       	push	r15
     b52:	0f 93       	push	r16
     b54:	df 93       	push	r29
     b56:	cf 93       	push	r28
     b58:	0f 92       	push	r0
     b5a:	cd b7       	in	r28, 0x3d	; 61
     b5c:	de b7       	in	r29, 0x3e	; 62
     b5e:	89 83       	std	Y+1, r24	; 0x01
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
     b60:	8a e0       	ldi	r24, 0x0A	; 10
     b62:	62 e0       	ldi	r22, 0x02	; 2
     b64:	40 e0       	ldi	r20, 0x00	; 0
     b66:	0e 94 83 12 	call	0x2506	; 0x2506 <xQueueGenericCreate>
     b6a:	90 93 83 01 	sts	0x0183, r25
     b6e:	80 93 82 01 	sts	0x0182, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
     b72:	87 e2       	ldi	r24, 0x27	; 39
     b74:	96 e0       	ldi	r25, 0x06	; 6
     b76:	20 e6       	ldi	r18, 0x60	; 96
     b78:	30 e0       	ldi	r19, 0x00	; 0
     b7a:	e2 e8       	ldi	r30, 0x82	; 130
     b7c:	f1 e0       	ldi	r31, 0x01	; 1
     b7e:	b9 01       	movw	r22, r18
     b80:	45 e5       	ldi	r20, 0x55	; 85
     b82:	50 e0       	ldi	r21, 0x00	; 0
     b84:	9f 01       	movw	r18, r30
     b86:	09 81       	ldd	r16, Y+1	; 0x01
     b88:	ee 24       	eor	r14, r14
     b8a:	ff 24       	eor	r15, r15
     b8c:	cc 24       	eor	r12, r12
     b8e:	dd 24       	eor	r13, r13
     b90:	aa 24       	eor	r10, r10
     b92:	bb 24       	eor	r11, r11
     b94:	0e 94 2c 19 	call	0x3258	; 0x3258 <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
     b98:	8a ee       	ldi	r24, 0xEA	; 234
     b9a:	95 e0       	ldi	r25, 0x05	; 5
     b9c:	28 e6       	ldi	r18, 0x68	; 104
     b9e:	30 e0       	ldi	r19, 0x00	; 0
     ba0:	e2 e8       	ldi	r30, 0x82	; 130
     ba2:	f1 e0       	ldi	r31, 0x01	; 1
     ba4:	b9 01       	movw	r22, r18
     ba6:	45 e5       	ldi	r20, 0x55	; 85
     ba8:	50 e0       	ldi	r21, 0x00	; 0
     baa:	9f 01       	movw	r18, r30
     bac:	09 81       	ldd	r16, Y+1	; 0x01
     bae:	ee 24       	eor	r14, r14
     bb0:	ff 24       	eor	r15, r15
     bb2:	cc 24       	eor	r12, r12
     bb4:	dd 24       	eor	r13, r13
     bb6:	aa 24       	eor	r10, r10
     bb8:	bb 24       	eor	r11, r11
     bba:	0e 94 2c 19 	call	0x3258	; 0x3258 <xTaskGenericCreate>
}
     bbe:	0f 90       	pop	r0
     bc0:	cf 91       	pop	r28
     bc2:	df 91       	pop	r29
     bc4:	0f 91       	pop	r16
     bc6:	ff 90       	pop	r15
     bc8:	ef 90       	pop	r14
     bca:	df 90       	pop	r13
     bcc:	cf 90       	pop	r12
     bce:	bf 90       	pop	r11
     bd0:	af 90       	pop	r10
     bd2:	08 95       	ret

00000bd4 <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
     bd4:	df 93       	push	r29
     bd6:	cf 93       	push	r28
     bd8:	00 d0       	rcall	.+0      	; 0xbda <vPolledQueueProducer+0x6>
     bda:	00 d0       	rcall	.+0      	; 0xbdc <vPolledQueueProducer+0x8>
     bdc:	00 d0       	rcall	.+0      	; 0xbde <vPolledQueueProducer+0xa>
     bde:	cd b7       	in	r28, 0x3d	; 61
     be0:	de b7       	in	r29, 0x3e	; 62
     be2:	9e 83       	std	Y+6, r25	; 0x06
     be4:	8d 83       	std	Y+5, r24	; 0x05
uint16_t usValue = ( uint16_t ) 0;
     be6:	1c 82       	std	Y+4, r1	; 0x04
     be8:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xError = pdFALSE, xLoop;
     bea:	1a 82       	std	Y+2, r1	; 0x02

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     bec:	19 82       	std	Y+1, r1	; 0x01
     bee:	27 c0       	rjmp	.+78     	; 0xc3e <vPolledQueueProducer+0x6a>
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
     bf0:	ed 81       	ldd	r30, Y+5	; 0x05
     bf2:	fe 81       	ldd	r31, Y+6	; 0x06
     bf4:	80 81       	ld	r24, Z
     bf6:	91 81       	ldd	r25, Z+1	; 0x01
     bf8:	9e 01       	movw	r18, r28
     bfa:	2d 5f       	subi	r18, 0xFD	; 253
     bfc:	3f 4f       	sbci	r19, 0xFF	; 255
     bfe:	b9 01       	movw	r22, r18
     c00:	40 e0       	ldi	r20, 0x00	; 0
     c02:	50 e0       	ldi	r21, 0x00	; 0
     c04:	20 e0       	ldi	r18, 0x00	; 0
     c06:	0e 94 00 13 	call	0x2600	; 0x2600 <xQueueGenericSend>
     c0a:	81 30       	cpi	r24, 0x01	; 1
     c0c:	19 f0       	breq	.+6      	; 0xc14 <vPolledQueueProducer+0x40>
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
     c0e:	81 e0       	ldi	r24, 0x01	; 1
     c10:	8a 83       	std	Y+2, r24	; 0x02
     c12:	12 c0       	rjmp	.+36     	; 0xc38 <vPolledQueueProducer+0x64>
			}
			else
			{
				if( xError == pdFALSE )
     c14:	8a 81       	ldd	r24, Y+2	; 0x02
     c16:	88 23       	and	r24, r24
     c18:	51 f4       	brne	.+20     	; 0xc2e <vPolledQueueProducer+0x5a>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
     c1a:	0f b6       	in	r0, 0x3f	; 63
     c1c:	f8 94       	cli
     c1e:	0f 92       	push	r0
						xPollingProducerCount++;
     c20:	80 91 81 01 	lds	r24, 0x0181
     c24:	8f 5f       	subi	r24, 0xFF	; 255
     c26:	80 93 81 01 	sts	0x0181, r24
					portEXIT_CRITICAL();
     c2a:	0f 90       	pop	r0
     c2c:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
     c2e:	8b 81       	ldd	r24, Y+3	; 0x03
     c30:	9c 81       	ldd	r25, Y+4	; 0x04
     c32:	01 96       	adiw	r24, 0x01	; 1
     c34:	9c 83       	std	Y+4, r25	; 0x04
     c36:	8b 83       	std	Y+3, r24	; 0x03
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     c38:	89 81       	ldd	r24, Y+1	; 0x01
     c3a:	8f 5f       	subi	r24, 0xFF	; 255
     c3c:	89 83       	std	Y+1, r24	; 0x01
     c3e:	89 81       	ldd	r24, Y+1	; 0x01
     c40:	83 30       	cpi	r24, 0x03	; 3
     c42:	b4 f2       	brlt	.-84     	; 0xbf0 <vPolledQueueProducer+0x1c>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
     c44:	88 ec       	ldi	r24, 0xC8	; 200
     c46:	90 e0       	ldi	r25, 0x00	; 0
     c48:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <vTaskDelay>
     c4c:	cf cf       	rjmp	.-98     	; 0xbec <vPolledQueueProducer+0x18>

00000c4e <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
     c4e:	df 93       	push	r29
     c50:	cf 93       	push	r28
     c52:	cd b7       	in	r28, 0x3d	; 61
     c54:	de b7       	in	r29, 0x3e	; 62
     c56:	27 97       	sbiw	r28, 0x07	; 7
     c58:	0f b6       	in	r0, 0x3f	; 63
     c5a:	f8 94       	cli
     c5c:	de bf       	out	0x3e, r29	; 62
     c5e:	0f be       	out	0x3f, r0	; 63
     c60:	cd bf       	out	0x3d, r28	; 61
     c62:	9f 83       	std	Y+7, r25	; 0x07
     c64:	8e 83       	std	Y+6, r24	; 0x06
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
     c66:	1b 82       	std	Y+3, r1	; 0x03
     c68:	1a 82       	std	Y+2, r1	; 0x02
BaseType_t xError = pdFALSE;
     c6a:	19 82       	std	Y+1, r1	; 0x01
     c6c:	2f c0       	rjmp	.+94     	; 0xccc <vPolledQueueConsumer+0x7e>
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
     c6e:	ee 81       	ldd	r30, Y+6	; 0x06
     c70:	ff 81       	ldd	r31, Y+7	; 0x07
     c72:	80 81       	ld	r24, Z
     c74:	91 81       	ldd	r25, Z+1	; 0x01
     c76:	9e 01       	movw	r18, r28
     c78:	2c 5f       	subi	r18, 0xFC	; 252
     c7a:	3f 4f       	sbci	r19, 0xFF	; 255
     c7c:	b9 01       	movw	r22, r18
     c7e:	40 e0       	ldi	r20, 0x00	; 0
     c80:	50 e0       	ldi	r21, 0x00	; 0
     c82:	20 e0       	ldi	r18, 0x00	; 0
     c84:	0e 94 0e 14 	call	0x281c	; 0x281c <xQueueGenericReceive>
     c88:	81 30       	cpi	r24, 0x01	; 1
     c8a:	01 f5       	brne	.+64     	; 0xccc <vPolledQueueConsumer+0x7e>
			{
				if( usData != usExpectedValue )
     c8c:	2c 81       	ldd	r18, Y+4	; 0x04
     c8e:	3d 81       	ldd	r19, Y+5	; 0x05
     c90:	8a 81       	ldd	r24, Y+2	; 0x02
     c92:	9b 81       	ldd	r25, Y+3	; 0x03
     c94:	28 17       	cp	r18, r24
     c96:	39 07       	cpc	r19, r25
     c98:	39 f0       	breq	.+14     	; 0xca8 <vPolledQueueConsumer+0x5a>
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
     c9a:	81 e0       	ldi	r24, 0x01	; 1
     c9c:	89 83       	std	Y+1, r24	; 0x01

					/* Catch-up to the value we received so our next expected
					value should again be correct. */
					usExpectedValue = usData;
     c9e:	8c 81       	ldd	r24, Y+4	; 0x04
     ca0:	9d 81       	ldd	r25, Y+5	; 0x05
     ca2:	9b 83       	std	Y+3, r25	; 0x03
     ca4:	8a 83       	std	Y+2, r24	; 0x02
     ca6:	0d c0       	rjmp	.+26     	; 0xcc2 <vPolledQueueConsumer+0x74>
				}
				else
				{
					if( xError == pdFALSE )
     ca8:	89 81       	ldd	r24, Y+1	; 0x01
     caa:	88 23       	and	r24, r24
     cac:	51 f4       	brne	.+20     	; 0xcc2 <vPolledQueueConsumer+0x74>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
     cae:	0f b6       	in	r0, 0x3f	; 63
     cb0:	f8 94       	cli
     cb2:	0f 92       	push	r0
							xPollingConsumerCount++;
     cb4:	80 91 80 01 	lds	r24, 0x0180
     cb8:	8f 5f       	subi	r24, 0xFF	; 255
     cba:	80 93 80 01 	sts	0x0180, r24
						portEXIT_CRITICAL();
     cbe:	0f 90       	pop	r0
     cc0:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
     cc2:	8a 81       	ldd	r24, Y+2	; 0x02
     cc4:	9b 81       	ldd	r25, Y+3	; 0x03
     cc6:	01 96       	adiw	r24, 0x01	; 1
     cc8:	9b 83       	std	Y+3, r25	; 0x03
     cca:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
     ccc:	ee 81       	ldd	r30, Y+6	; 0x06
     cce:	ff 81       	ldd	r31, Y+7	; 0x07
     cd0:	80 81       	ld	r24, Z
     cd2:	91 81       	ldd	r25, Z+1	; 0x01
     cd4:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <uxQueueMessagesWaiting>
     cd8:	88 23       	and	r24, r24
     cda:	49 f6       	brne	.-110    	; 0xc6e <vPolledQueueConsumer+0x20>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
     cdc:	84 eb       	ldi	r24, 0xB4	; 180
     cde:	90 e0       	ldi	r25, 0x00	; 0
     ce0:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <vTaskDelay>
     ce4:	f3 cf       	rjmp	.-26     	; 0xccc <vPolledQueueConsumer+0x7e>

00000ce6 <xArePollingQueuesStillRunning>:
} /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running with no errors. */
BaseType_t xArePollingQueuesStillRunning( void )
{
     ce6:	df 93       	push	r29
     ce8:	cf 93       	push	r28
     cea:	0f 92       	push	r0
     cec:	cd b7       	in	r28, 0x3d	; 61
     cee:	de b7       	in	r29, 0x3e	; 62

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
     cf0:	80 91 80 01 	lds	r24, 0x0180
     cf4:	88 23       	and	r24, r24
     cf6:	21 f0       	breq	.+8      	; 0xd00 <xArePollingQueuesStillRunning+0x1a>
     cf8:	80 91 81 01 	lds	r24, 0x0181
     cfc:	88 23       	and	r24, r24
     cfe:	11 f4       	brne	.+4      	; 0xd04 <xArePollingQueuesStillRunning+0x1e>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
     d00:	19 82       	std	Y+1, r1	; 0x01
     d02:	02 c0       	rjmp	.+4      	; 0xd08 <xArePollingQueuesStillRunning+0x22>
	}
	else
	{
		xReturn = pdTRUE;
     d04:	81 e0       	ldi	r24, 0x01	; 1
     d06:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
     d08:	10 92 80 01 	sts	0x0180, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
     d0c:	10 92 81 01 	sts	0x0181, r1

	return xReturn;
     d10:	89 81       	ldd	r24, Y+1	; 0x01
}
     d12:	0f 90       	pop	r0
     d14:	cf 91       	pop	r28
     d16:	df 91       	pop	r29
     d18:	08 95       	ret

00000d1a <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
     d1a:	df 93       	push	r29
     d1c:	cf 93       	push	r28
     d1e:	cd b7       	in	r28, 0x3d	; 61
     d20:	de b7       	in	r29, 0x3e	; 62
     d22:	27 97       	sbiw	r28, 0x07	; 7
     d24:	0f b6       	in	r0, 0x3f	; 63
     d26:	f8 94       	cli
     d28:	de bf       	out	0x3e, r29	; 62
     d2a:	0f be       	out	0x3f, r0	; 63
     d2c:	cd bf       	out	0x3d, r28	; 61
     d2e:	9d 83       	std	Y+5, r25	; 0x05
     d30:	8c 83       	std	Y+4, r24	; 0x04
     d32:	6e 83       	std	Y+6, r22	; 0x06
     d34:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     d36:	8a e1       	ldi	r24, 0x1A	; 26
     d38:	90 e0       	ldi	r25, 0x00	; 0
     d3a:	0e 94 a5 0c 	call	0x194a	; 0x194a <pvPortMalloc>
     d3e:	9a 83       	std	Y+2, r25	; 0x02
     d40:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     d42:	89 81       	ldd	r24, Y+1	; 0x01
     d44:	9a 81       	ldd	r25, Y+2	; 0x02
     d46:	00 97       	sbiw	r24, 0x00	; 0
     d48:	09 f4       	brne	.+2      	; 0xd4c <xCoRoutineCreate+0x32>
     d4a:	6f c0       	rjmp	.+222    	; 0xe2a <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     d4c:	80 91 84 01 	lds	r24, 0x0184
     d50:	90 91 85 01 	lds	r25, 0x0185
     d54:	00 97       	sbiw	r24, 0x00	; 0
     d56:	41 f4       	brne	.+16     	; 0xd68 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     d58:	89 81       	ldd	r24, Y+1	; 0x01
     d5a:	9a 81       	ldd	r25, Y+2	; 0x02
     d5c:	90 93 85 01 	sts	0x0185, r25
     d60:	80 93 84 01 	sts	0x0184, r24
			prvInitialiseCoRoutineLists();
     d64:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     d68:	8e 81       	ldd	r24, Y+6	; 0x06
     d6a:	82 30       	cpi	r24, 0x02	; 2
     d6c:	10 f0       	brcs	.+4      	; 0xd72 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     d6e:	81 e0       	ldi	r24, 0x01	; 1
     d70:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     d72:	e9 81       	ldd	r30, Y+1	; 0x01
     d74:	fa 81       	ldd	r31, Y+2	; 0x02
     d76:	11 8e       	std	Z+25, r1	; 0x19
     d78:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     d7a:	e9 81       	ldd	r30, Y+1	; 0x01
     d7c:	fa 81       	ldd	r31, Y+2	; 0x02
     d7e:	8e 81       	ldd	r24, Y+6	; 0x06
     d80:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     d82:	e9 81       	ldd	r30, Y+1	; 0x01
     d84:	fa 81       	ldd	r31, Y+2	; 0x02
     d86:	8f 81       	ldd	r24, Y+7	; 0x07
     d88:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     d8a:	e9 81       	ldd	r30, Y+1	; 0x01
     d8c:	fa 81       	ldd	r31, Y+2	; 0x02
     d8e:	8c 81       	ldd	r24, Y+4	; 0x04
     d90:	9d 81       	ldd	r25, Y+5	; 0x05
     d92:	91 83       	std	Z+1, r25	; 0x01
     d94:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     d96:	89 81       	ldd	r24, Y+1	; 0x01
     d98:	9a 81       	ldd	r25, Y+2	; 0x02
     d9a:	02 96       	adiw	r24, 0x02	; 2
     d9c:	0e 94 1d 0e 	call	0x1c3a	; 0x1c3a <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     da0:	89 81       	ldd	r24, Y+1	; 0x01
     da2:	9a 81       	ldd	r25, Y+2	; 0x02
     da4:	0c 96       	adiw	r24, 0x0c	; 12
     da6:	0e 94 1d 0e 	call	0x1c3a	; 0x1c3a <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     daa:	e9 81       	ldd	r30, Y+1	; 0x01
     dac:	fa 81       	ldd	r31, Y+2	; 0x02
     dae:	89 81       	ldd	r24, Y+1	; 0x01
     db0:	9a 81       	ldd	r25, Y+2	; 0x02
     db2:	91 87       	std	Z+9, r25	; 0x09
     db4:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     db6:	e9 81       	ldd	r30, Y+1	; 0x01
     db8:	fa 81       	ldd	r31, Y+2	; 0x02
     dba:	89 81       	ldd	r24, Y+1	; 0x01
     dbc:	9a 81       	ldd	r25, Y+2	; 0x02
     dbe:	93 8b       	std	Z+19, r25	; 0x13
     dc0:	82 8b       	std	Z+18, r24	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     dc2:	8e 81       	ldd	r24, Y+6	; 0x06
     dc4:	28 2f       	mov	r18, r24
     dc6:	30 e0       	ldi	r19, 0x00	; 0
     dc8:	82 e0       	ldi	r24, 0x02	; 2
     dca:	90 e0       	ldi	r25, 0x00	; 0
     dcc:	82 1b       	sub	r24, r18
     dce:	93 0b       	sbc	r25, r19
     dd0:	e9 81       	ldd	r30, Y+1	; 0x01
     dd2:	fa 81       	ldd	r31, Y+2	; 0x02
     dd4:	95 87       	std	Z+13, r25	; 0x0d
     dd6:	84 87       	std	Z+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     dd8:	e9 81       	ldd	r30, Y+1	; 0x01
     dda:	fa 81       	ldd	r31, Y+2	; 0x02
     ddc:	96 89       	ldd	r25, Z+22	; 0x16
     dde:	80 91 86 01 	lds	r24, 0x0186
     de2:	89 17       	cp	r24, r25
     de4:	28 f4       	brcc	.+10     	; 0xdf0 <xCoRoutineCreate+0xd6>
     de6:	e9 81       	ldd	r30, Y+1	; 0x01
     de8:	fa 81       	ldd	r31, Y+2	; 0x02
     dea:	86 89       	ldd	r24, Z+22	; 0x16
     dec:	80 93 86 01 	sts	0x0186, r24
     df0:	e9 81       	ldd	r30, Y+1	; 0x01
     df2:	fa 81       	ldd	r31, Y+2	; 0x02
     df4:	86 89       	ldd	r24, Z+22	; 0x16
     df6:	28 2f       	mov	r18, r24
     df8:	30 e0       	ldi	r19, 0x00	; 0
     dfa:	c9 01       	movw	r24, r18
     dfc:	88 0f       	add	r24, r24
     dfe:	99 1f       	adc	r25, r25
     e00:	88 0f       	add	r24, r24
     e02:	99 1f       	adc	r25, r25
     e04:	88 0f       	add	r24, r24
     e06:	99 1f       	adc	r25, r25
     e08:	82 0f       	add	r24, r18
     e0a:	93 1f       	adc	r25, r19
     e0c:	ac 01       	movw	r20, r24
     e0e:	43 57       	subi	r20, 0x73	; 115
     e10:	5e 4f       	sbci	r21, 0xFE	; 254
     e12:	89 81       	ldd	r24, Y+1	; 0x01
     e14:	9a 81       	ldd	r25, Y+2	; 0x02
     e16:	9c 01       	movw	r18, r24
     e18:	2e 5f       	subi	r18, 0xFE	; 254
     e1a:	3f 4f       	sbci	r19, 0xFF	; 255
     e1c:	ca 01       	movw	r24, r20
     e1e:	b9 01       	movw	r22, r18
     e20:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsertEnd>

		xReturn = pdPASS;
     e24:	81 e0       	ldi	r24, 0x01	; 1
     e26:	8b 83       	std	Y+3, r24	; 0x03
     e28:	02 c0       	rjmp	.+4      	; 0xe2e <xCoRoutineCreate+0x114>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     e2a:	8f ef       	ldi	r24, 0xFF	; 255
     e2c:	8b 83       	std	Y+3, r24	; 0x03
	}

	return xReturn;
     e2e:	8b 81       	ldd	r24, Y+3	; 0x03
}
     e30:	27 96       	adiw	r28, 0x07	; 7
     e32:	0f b6       	in	r0, 0x3f	; 63
     e34:	f8 94       	cli
     e36:	de bf       	out	0x3e, r29	; 62
     e38:	0f be       	out	0x3f, r0	; 63
     e3a:	cd bf       	out	0x3d, r28	; 61
     e3c:	cf 91       	pop	r28
     e3e:	df 91       	pop	r29
     e40:	08 95       	ret

00000e42 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     e42:	df 93       	push	r29
     e44:	cf 93       	push	r28
     e46:	00 d0       	rcall	.+0      	; 0xe48 <vCoRoutineAddToDelayedList+0x6>
     e48:	00 d0       	rcall	.+0      	; 0xe4a <vCoRoutineAddToDelayedList+0x8>
     e4a:	00 d0       	rcall	.+0      	; 0xe4c <vCoRoutineAddToDelayedList+0xa>
     e4c:	cd b7       	in	r28, 0x3d	; 61
     e4e:	de b7       	in	r29, 0x3e	; 62
     e50:	9c 83       	std	Y+4, r25	; 0x04
     e52:	8b 83       	std	Y+3, r24	; 0x03
     e54:	7e 83       	std	Y+6, r23	; 0x06
     e56:	6d 83       	std	Y+5, r22	; 0x05
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     e58:	20 91 87 01 	lds	r18, 0x0187
     e5c:	30 91 88 01 	lds	r19, 0x0188
     e60:	8b 81       	ldd	r24, Y+3	; 0x03
     e62:	9c 81       	ldd	r25, Y+4	; 0x04
     e64:	82 0f       	add	r24, r18
     e66:	93 1f       	adc	r25, r19
     e68:	9a 83       	std	Y+2, r25	; 0x02
     e6a:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     e6c:	80 91 84 01 	lds	r24, 0x0184
     e70:	90 91 85 01 	lds	r25, 0x0185
     e74:	02 96       	adiw	r24, 0x02	; 2
     e76:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     e7a:	e0 91 84 01 	lds	r30, 0x0184
     e7e:	f0 91 85 01 	lds	r31, 0x0185
     e82:	89 81       	ldd	r24, Y+1	; 0x01
     e84:	9a 81       	ldd	r25, Y+2	; 0x02
     e86:	93 83       	std	Z+3, r25	; 0x03
     e88:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     e8a:	20 91 87 01 	lds	r18, 0x0187
     e8e:	30 91 88 01 	lds	r19, 0x0188
     e92:	89 81       	ldd	r24, Y+1	; 0x01
     e94:	9a 81       	ldd	r25, Y+2	; 0x02
     e96:	82 17       	cp	r24, r18
     e98:	93 07       	cpc	r25, r19
     e9a:	70 f4       	brcc	.+28     	; 0xeb8 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     e9c:	80 91 b3 01 	lds	r24, 0x01B3
     ea0:	90 91 b4 01 	lds	r25, 0x01B4
     ea4:	20 91 84 01 	lds	r18, 0x0184
     ea8:	30 91 85 01 	lds	r19, 0x0185
     eac:	2e 5f       	subi	r18, 0xFE	; 254
     eae:	3f 4f       	sbci	r19, 0xFF	; 255
     eb0:	b9 01       	movw	r22, r18
     eb2:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <vListInsert>
     eb6:	0d c0       	rjmp	.+26     	; 0xed2 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     eb8:	80 91 b1 01 	lds	r24, 0x01B1
     ebc:	90 91 b2 01 	lds	r25, 0x01B2
     ec0:	20 91 84 01 	lds	r18, 0x0184
     ec4:	30 91 85 01 	lds	r19, 0x0185
     ec8:	2e 5f       	subi	r18, 0xFE	; 254
     eca:	3f 4f       	sbci	r19, 0xFF	; 255
     ecc:	b9 01       	movw	r22, r18
     ece:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <vListInsert>
	}

	if( pxEventList )
     ed2:	8d 81       	ldd	r24, Y+5	; 0x05
     ed4:	9e 81       	ldd	r25, Y+6	; 0x06
     ed6:	00 97       	sbiw	r24, 0x00	; 0
     ed8:	61 f0       	breq	.+24     	; 0xef2 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     eda:	80 91 84 01 	lds	r24, 0x0184
     ede:	90 91 85 01 	lds	r25, 0x0185
     ee2:	9c 01       	movw	r18, r24
     ee4:	24 5f       	subi	r18, 0xF4	; 244
     ee6:	3f 4f       	sbci	r19, 0xFF	; 255
     ee8:	8d 81       	ldd	r24, Y+5	; 0x05
     eea:	9e 81       	ldd	r25, Y+6	; 0x06
     eec:	b9 01       	movw	r22, r18
     eee:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <vListInsert>
	}
}
     ef2:	26 96       	adiw	r28, 0x06	; 6
     ef4:	0f b6       	in	r0, 0x3f	; 63
     ef6:	f8 94       	cli
     ef8:	de bf       	out	0x3e, r29	; 62
     efa:	0f be       	out	0x3f, r0	; 63
     efc:	cd bf       	out	0x3d, r28	; 61
     efe:	cf 91       	pop	r28
     f00:	df 91       	pop	r29
     f02:	08 95       	ret

00000f04 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     f04:	df 93       	push	r29
     f06:	cf 93       	push	r28
     f08:	00 d0       	rcall	.+0      	; 0xf0a <prvCheckPendingReadyList+0x6>
     f0a:	cd b7       	in	r28, 0x3d	; 61
     f0c:	de b7       	in	r29, 0x3e	; 62
     f0e:	3a c0       	rjmp	.+116    	; 0xf84 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     f10:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     f12:	e0 91 ba 01 	lds	r30, 0x01BA
     f16:	f0 91 bb 01 	lds	r31, 0x01BB
     f1a:	86 81       	ldd	r24, Z+6	; 0x06
     f1c:	97 81       	ldd	r25, Z+7	; 0x07
     f1e:	9a 83       	std	Y+2, r25	; 0x02
     f20:	89 83       	std	Y+1, r24	; 0x01
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     f22:	89 81       	ldd	r24, Y+1	; 0x01
     f24:	9a 81       	ldd	r25, Y+2	; 0x02
     f26:	0c 96       	adiw	r24, 0x0c	; 12
     f28:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     f2c:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     f2e:	89 81       	ldd	r24, Y+1	; 0x01
     f30:	9a 81       	ldd	r25, Y+2	; 0x02
     f32:	02 96       	adiw	r24, 0x02	; 2
     f34:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     f38:	e9 81       	ldd	r30, Y+1	; 0x01
     f3a:	fa 81       	ldd	r31, Y+2	; 0x02
     f3c:	96 89       	ldd	r25, Z+22	; 0x16
     f3e:	80 91 86 01 	lds	r24, 0x0186
     f42:	89 17       	cp	r24, r25
     f44:	28 f4       	brcc	.+10     	; 0xf50 <prvCheckPendingReadyList+0x4c>
     f46:	e9 81       	ldd	r30, Y+1	; 0x01
     f48:	fa 81       	ldd	r31, Y+2	; 0x02
     f4a:	86 89       	ldd	r24, Z+22	; 0x16
     f4c:	80 93 86 01 	sts	0x0186, r24
     f50:	e9 81       	ldd	r30, Y+1	; 0x01
     f52:	fa 81       	ldd	r31, Y+2	; 0x02
     f54:	86 89       	ldd	r24, Z+22	; 0x16
     f56:	28 2f       	mov	r18, r24
     f58:	30 e0       	ldi	r19, 0x00	; 0
     f5a:	c9 01       	movw	r24, r18
     f5c:	88 0f       	add	r24, r24
     f5e:	99 1f       	adc	r25, r25
     f60:	88 0f       	add	r24, r24
     f62:	99 1f       	adc	r25, r25
     f64:	88 0f       	add	r24, r24
     f66:	99 1f       	adc	r25, r25
     f68:	82 0f       	add	r24, r18
     f6a:	93 1f       	adc	r25, r19
     f6c:	ac 01       	movw	r20, r24
     f6e:	43 57       	subi	r20, 0x73	; 115
     f70:	5e 4f       	sbci	r21, 0xFE	; 254
     f72:	89 81       	ldd	r24, Y+1	; 0x01
     f74:	9a 81       	ldd	r25, Y+2	; 0x02
     f76:	9c 01       	movw	r18, r24
     f78:	2e 5f       	subi	r18, 0xFE	; 254
     f7a:	3f 4f       	sbci	r19, 0xFF	; 255
     f7c:	ca 01       	movw	r24, r20
     f7e:	b9 01       	movw	r22, r18
     f80:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     f84:	80 91 b5 01 	lds	r24, 0x01B5
     f88:	88 23       	and	r24, r24
     f8a:	09 f0       	breq	.+2      	; 0xf8e <prvCheckPendingReadyList+0x8a>
     f8c:	c1 cf       	rjmp	.-126    	; 0xf10 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
     f8e:	0f 90       	pop	r0
     f90:	0f 90       	pop	r0
     f92:	cf 91       	pop	r28
     f94:	df 91       	pop	r29
     f96:	08 95       	ret

00000f98 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     f98:	df 93       	push	r29
     f9a:	cf 93       	push	r28
     f9c:	00 d0       	rcall	.+0      	; 0xf9e <prvCheckDelayedList+0x6>
     f9e:	00 d0       	rcall	.+0      	; 0xfa0 <prvCheckDelayedList+0x8>
     fa0:	cd b7       	in	r28, 0x3d	; 61
     fa2:	de b7       	in	r29, 0x3e	; 62
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     fa4:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <xTaskGetTickCount>
     fa8:	20 91 89 01 	lds	r18, 0x0189
     fac:	30 91 8a 01 	lds	r19, 0x018A
     fb0:	82 1b       	sub	r24, r18
     fb2:	93 0b       	sbc	r25, r19
     fb4:	90 93 8c 01 	sts	0x018C, r25
     fb8:	80 93 8b 01 	sts	0x018B, r24
     fbc:	85 c0       	rjmp	.+266    	; 0x10c8 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     fbe:	80 91 87 01 	lds	r24, 0x0187
     fc2:	90 91 88 01 	lds	r25, 0x0188
     fc6:	01 96       	adiw	r24, 0x01	; 1
     fc8:	90 93 88 01 	sts	0x0188, r25
     fcc:	80 93 87 01 	sts	0x0187, r24
		xPassedTicks--;
     fd0:	80 91 8b 01 	lds	r24, 0x018B
     fd4:	90 91 8c 01 	lds	r25, 0x018C
     fd8:	01 97       	sbiw	r24, 0x01	; 1
     fda:	90 93 8c 01 	sts	0x018C, r25
     fde:	80 93 8b 01 	sts	0x018B, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     fe2:	80 91 87 01 	lds	r24, 0x0187
     fe6:	90 91 88 01 	lds	r25, 0x0188
     fea:	00 97       	sbiw	r24, 0x00	; 0
     fec:	09 f0       	breq	.+2      	; 0xff0 <prvCheckDelayedList+0x58>
     fee:	64 c0       	rjmp	.+200    	; 0x10b8 <prvCheckDelayedList+0x120>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     ff0:	80 91 b1 01 	lds	r24, 0x01B1
     ff4:	90 91 b2 01 	lds	r25, 0x01B2
     ff8:	9a 83       	std	Y+2, r25	; 0x02
     ffa:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     ffc:	80 91 b3 01 	lds	r24, 0x01B3
    1000:	90 91 b4 01 	lds	r25, 0x01B4
    1004:	90 93 b2 01 	sts	0x01B2, r25
    1008:	80 93 b1 01 	sts	0x01B1, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    100c:	89 81       	ldd	r24, Y+1	; 0x01
    100e:	9a 81       	ldd	r25, Y+2	; 0x02
    1010:	90 93 b4 01 	sts	0x01B4, r25
    1014:	80 93 b3 01 	sts	0x01B3, r24
    1018:	4f c0       	rjmp	.+158    	; 0x10b8 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    101a:	e0 91 b1 01 	lds	r30, 0x01B1
    101e:	f0 91 b2 01 	lds	r31, 0x01B2
    1022:	05 80       	ldd	r0, Z+5	; 0x05
    1024:	f6 81       	ldd	r31, Z+6	; 0x06
    1026:	e0 2d       	mov	r30, r0
    1028:	86 81       	ldd	r24, Z+6	; 0x06
    102a:	97 81       	ldd	r25, Z+7	; 0x07
    102c:	9c 83       	std	Y+4, r25	; 0x04
    102e:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1030:	eb 81       	ldd	r30, Y+3	; 0x03
    1032:	fc 81       	ldd	r31, Y+4	; 0x04
    1034:	22 81       	ldd	r18, Z+2	; 0x02
    1036:	33 81       	ldd	r19, Z+3	; 0x03
    1038:	80 91 87 01 	lds	r24, 0x0187
    103c:	90 91 88 01 	lds	r25, 0x0188
    1040:	82 17       	cp	r24, r18
    1042:	93 07       	cpc	r25, r19
    1044:	08 f4       	brcc	.+2      	; 0x1048 <prvCheckDelayedList+0xb0>
    1046:	40 c0       	rjmp	.+128    	; 0x10c8 <prvCheckDelayedList+0x130>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1048:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    104a:	8b 81       	ldd	r24, Y+3	; 0x03
    104c:	9c 81       	ldd	r25, Y+4	; 0x04
    104e:	02 96       	adiw	r24, 0x02	; 2
    1050:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    1054:	eb 81       	ldd	r30, Y+3	; 0x03
    1056:	fc 81       	ldd	r31, Y+4	; 0x04
    1058:	84 89       	ldd	r24, Z+20	; 0x14
    105a:	95 89       	ldd	r25, Z+21	; 0x15
    105c:	00 97       	sbiw	r24, 0x00	; 0
    105e:	29 f0       	breq	.+10     	; 0x106a <prvCheckDelayedList+0xd2>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1060:	8b 81       	ldd	r24, Y+3	; 0x03
    1062:	9c 81       	ldd	r25, Y+4	; 0x04
    1064:	0c 96       	adiw	r24, 0x0c	; 12
    1066:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    106a:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    106c:	eb 81       	ldd	r30, Y+3	; 0x03
    106e:	fc 81       	ldd	r31, Y+4	; 0x04
    1070:	96 89       	ldd	r25, Z+22	; 0x16
    1072:	80 91 86 01 	lds	r24, 0x0186
    1076:	89 17       	cp	r24, r25
    1078:	28 f4       	brcc	.+10     	; 0x1084 <prvCheckDelayedList+0xec>
    107a:	eb 81       	ldd	r30, Y+3	; 0x03
    107c:	fc 81       	ldd	r31, Y+4	; 0x04
    107e:	86 89       	ldd	r24, Z+22	; 0x16
    1080:	80 93 86 01 	sts	0x0186, r24
    1084:	eb 81       	ldd	r30, Y+3	; 0x03
    1086:	fc 81       	ldd	r31, Y+4	; 0x04
    1088:	86 89       	ldd	r24, Z+22	; 0x16
    108a:	28 2f       	mov	r18, r24
    108c:	30 e0       	ldi	r19, 0x00	; 0
    108e:	c9 01       	movw	r24, r18
    1090:	88 0f       	add	r24, r24
    1092:	99 1f       	adc	r25, r25
    1094:	88 0f       	add	r24, r24
    1096:	99 1f       	adc	r25, r25
    1098:	88 0f       	add	r24, r24
    109a:	99 1f       	adc	r25, r25
    109c:	82 0f       	add	r24, r18
    109e:	93 1f       	adc	r25, r19
    10a0:	ac 01       	movw	r20, r24
    10a2:	43 57       	subi	r20, 0x73	; 115
    10a4:	5e 4f       	sbci	r21, 0xFE	; 254
    10a6:	8b 81       	ldd	r24, Y+3	; 0x03
    10a8:	9c 81       	ldd	r25, Y+4	; 0x04
    10aa:	9c 01       	movw	r18, r24
    10ac:	2e 5f       	subi	r18, 0xFE	; 254
    10ae:	3f 4f       	sbci	r19, 0xFF	; 255
    10b0:	ca 01       	movw	r24, r20
    10b2:	b9 01       	movw	r22, r18
    10b4:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    10b8:	e0 91 b1 01 	lds	r30, 0x01B1
    10bc:	f0 91 b2 01 	lds	r31, 0x01B2
    10c0:	80 81       	ld	r24, Z
    10c2:	88 23       	and	r24, r24
    10c4:	09 f0       	breq	.+2      	; 0x10c8 <prvCheckDelayedList+0x130>
    10c6:	a9 cf       	rjmp	.-174    	; 0x101a <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    10c8:	80 91 8b 01 	lds	r24, 0x018B
    10cc:	90 91 8c 01 	lds	r25, 0x018C
    10d0:	00 97       	sbiw	r24, 0x00	; 0
    10d2:	09 f0       	breq	.+2      	; 0x10d6 <prvCheckDelayedList+0x13e>
    10d4:	74 cf       	rjmp	.-280    	; 0xfbe <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    10d6:	80 91 87 01 	lds	r24, 0x0187
    10da:	90 91 88 01 	lds	r25, 0x0188
    10de:	90 93 8a 01 	sts	0x018A, r25
    10e2:	80 93 89 01 	sts	0x0189, r24
}
    10e6:	0f 90       	pop	r0
    10e8:	0f 90       	pop	r0
    10ea:	0f 90       	pop	r0
    10ec:	0f 90       	pop	r0
    10ee:	cf 91       	pop	r28
    10f0:	df 91       	pop	r29
    10f2:	08 95       	ret

000010f4 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    10f4:	df 93       	push	r29
    10f6:	cf 93       	push	r28
    10f8:	00 d0       	rcall	.+0      	; 0x10fa <vCoRoutineSchedule+0x6>
    10fa:	cd b7       	in	r28, 0x3d	; 61
    10fc:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    10fe:	0e 94 82 07 	call	0xf04	; 0xf04 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    1102:	0e 94 cc 07 	call	0xf98	; 0xf98 <prvCheckDelayedList>
    1106:	0a c0       	rjmp	.+20     	; 0x111c <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1108:	80 91 86 01 	lds	r24, 0x0186
    110c:	88 23       	and	r24, r24
    110e:	09 f4       	brne	.+2      	; 0x1112 <vCoRoutineSchedule+0x1e>
    1110:	66 c0       	rjmp	.+204    	; 0x11de <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1112:	80 91 86 01 	lds	r24, 0x0186
    1116:	81 50       	subi	r24, 0x01	; 1
    1118:	80 93 86 01 	sts	0x0186, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    111c:	80 91 86 01 	lds	r24, 0x0186
    1120:	28 2f       	mov	r18, r24
    1122:	30 e0       	ldi	r19, 0x00	; 0
    1124:	c9 01       	movw	r24, r18
    1126:	88 0f       	add	r24, r24
    1128:	99 1f       	adc	r25, r25
    112a:	88 0f       	add	r24, r24
    112c:	99 1f       	adc	r25, r25
    112e:	88 0f       	add	r24, r24
    1130:	99 1f       	adc	r25, r25
    1132:	82 0f       	add	r24, r18
    1134:	93 1f       	adc	r25, r19
    1136:	fc 01       	movw	r30, r24
    1138:	e3 57       	subi	r30, 0x73	; 115
    113a:	fe 4f       	sbci	r31, 0xFE	; 254
    113c:	80 81       	ld	r24, Z
    113e:	88 23       	and	r24, r24
    1140:	19 f3       	breq	.-58     	; 0x1108 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1142:	80 91 86 01 	lds	r24, 0x0186
    1146:	28 2f       	mov	r18, r24
    1148:	30 e0       	ldi	r19, 0x00	; 0
    114a:	c9 01       	movw	r24, r18
    114c:	88 0f       	add	r24, r24
    114e:	99 1f       	adc	r25, r25
    1150:	88 0f       	add	r24, r24
    1152:	99 1f       	adc	r25, r25
    1154:	88 0f       	add	r24, r24
    1156:	99 1f       	adc	r25, r25
    1158:	82 0f       	add	r24, r18
    115a:	93 1f       	adc	r25, r19
    115c:	83 57       	subi	r24, 0x73	; 115
    115e:	9e 4f       	sbci	r25, 0xFE	; 254
    1160:	9a 83       	std	Y+2, r25	; 0x02
    1162:	89 83       	std	Y+1, r24	; 0x01
    1164:	e9 81       	ldd	r30, Y+1	; 0x01
    1166:	fa 81       	ldd	r31, Y+2	; 0x02
    1168:	01 80       	ldd	r0, Z+1	; 0x01
    116a:	f2 81       	ldd	r31, Z+2	; 0x02
    116c:	e0 2d       	mov	r30, r0
    116e:	82 81       	ldd	r24, Z+2	; 0x02
    1170:	93 81       	ldd	r25, Z+3	; 0x03
    1172:	e9 81       	ldd	r30, Y+1	; 0x01
    1174:	fa 81       	ldd	r31, Y+2	; 0x02
    1176:	92 83       	std	Z+2, r25	; 0x02
    1178:	81 83       	std	Z+1, r24	; 0x01
    117a:	e9 81       	ldd	r30, Y+1	; 0x01
    117c:	fa 81       	ldd	r31, Y+2	; 0x02
    117e:	21 81       	ldd	r18, Z+1	; 0x01
    1180:	32 81       	ldd	r19, Z+2	; 0x02
    1182:	89 81       	ldd	r24, Y+1	; 0x01
    1184:	9a 81       	ldd	r25, Y+2	; 0x02
    1186:	03 96       	adiw	r24, 0x03	; 3
    1188:	28 17       	cp	r18, r24
    118a:	39 07       	cpc	r19, r25
    118c:	59 f4       	brne	.+22     	; 0x11a4 <vCoRoutineSchedule+0xb0>
    118e:	e9 81       	ldd	r30, Y+1	; 0x01
    1190:	fa 81       	ldd	r31, Y+2	; 0x02
    1192:	01 80       	ldd	r0, Z+1	; 0x01
    1194:	f2 81       	ldd	r31, Z+2	; 0x02
    1196:	e0 2d       	mov	r30, r0
    1198:	82 81       	ldd	r24, Z+2	; 0x02
    119a:	93 81       	ldd	r25, Z+3	; 0x03
    119c:	e9 81       	ldd	r30, Y+1	; 0x01
    119e:	fa 81       	ldd	r31, Y+2	; 0x02
    11a0:	92 83       	std	Z+2, r25	; 0x02
    11a2:	81 83       	std	Z+1, r24	; 0x01
    11a4:	e9 81       	ldd	r30, Y+1	; 0x01
    11a6:	fa 81       	ldd	r31, Y+2	; 0x02
    11a8:	01 80       	ldd	r0, Z+1	; 0x01
    11aa:	f2 81       	ldd	r31, Z+2	; 0x02
    11ac:	e0 2d       	mov	r30, r0
    11ae:	86 81       	ldd	r24, Z+6	; 0x06
    11b0:	97 81       	ldd	r25, Z+7	; 0x07
    11b2:	90 93 85 01 	sts	0x0185, r25
    11b6:	80 93 84 01 	sts	0x0184, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    11ba:	e0 91 84 01 	lds	r30, 0x0184
    11be:	f0 91 85 01 	lds	r31, 0x0185
    11c2:	40 81       	ld	r20, Z
    11c4:	51 81       	ldd	r21, Z+1	; 0x01
    11c6:	80 91 84 01 	lds	r24, 0x0184
    11ca:	90 91 85 01 	lds	r25, 0x0185
    11ce:	e0 91 84 01 	lds	r30, 0x0184
    11d2:	f0 91 85 01 	lds	r31, 0x0185
    11d6:	27 89       	ldd	r18, Z+23	; 0x17
    11d8:	62 2f       	mov	r22, r18
    11da:	fa 01       	movw	r30, r20
    11dc:	09 95       	icall

	return;
}
    11de:	0f 90       	pop	r0
    11e0:	0f 90       	pop	r0
    11e2:	cf 91       	pop	r28
    11e4:	df 91       	pop	r29
    11e6:	08 95       	ret

000011e8 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    11e8:	df 93       	push	r29
    11ea:	cf 93       	push	r28
    11ec:	0f 92       	push	r0
    11ee:	cd b7       	in	r28, 0x3d	; 61
    11f0:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    11f2:	19 82       	std	Y+1, r1	; 0x01
    11f4:	13 c0       	rjmp	.+38     	; 0x121c <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    11f6:	89 81       	ldd	r24, Y+1	; 0x01
    11f8:	28 2f       	mov	r18, r24
    11fa:	30 e0       	ldi	r19, 0x00	; 0
    11fc:	c9 01       	movw	r24, r18
    11fe:	88 0f       	add	r24, r24
    1200:	99 1f       	adc	r25, r25
    1202:	88 0f       	add	r24, r24
    1204:	99 1f       	adc	r25, r25
    1206:	88 0f       	add	r24, r24
    1208:	99 1f       	adc	r25, r25
    120a:	82 0f       	add	r24, r18
    120c:	93 1f       	adc	r25, r19
    120e:	83 57       	subi	r24, 0x73	; 115
    1210:	9e 4f       	sbci	r25, 0xFE	; 254
    1212:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1216:	89 81       	ldd	r24, Y+1	; 0x01
    1218:	8f 5f       	subi	r24, 0xFF	; 255
    121a:	89 83       	std	Y+1, r24	; 0x01
    121c:	89 81       	ldd	r24, Y+1	; 0x01
    121e:	82 30       	cpi	r24, 0x02	; 2
    1220:	50 f3       	brcs	.-44     	; 0x11f6 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1222:	8f e9       	ldi	r24, 0x9F	; 159
    1224:	91 e0       	ldi	r25, 0x01	; 1
    1226:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    122a:	88 ea       	ldi	r24, 0xA8	; 168
    122c:	91 e0       	ldi	r25, 0x01	; 1
    122e:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1232:	85 eb       	ldi	r24, 0xB5	; 181
    1234:	91 e0       	ldi	r25, 0x01	; 1
    1236:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    123a:	8f e9       	ldi	r24, 0x9F	; 159
    123c:	91 e0       	ldi	r25, 0x01	; 1
    123e:	90 93 b2 01 	sts	0x01B2, r25
    1242:	80 93 b1 01 	sts	0x01B1, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1246:	88 ea       	ldi	r24, 0xA8	; 168
    1248:	91 e0       	ldi	r25, 0x01	; 1
    124a:	90 93 b4 01 	sts	0x01B4, r25
    124e:	80 93 b3 01 	sts	0x01B3, r24
}
    1252:	0f 90       	pop	r0
    1254:	cf 91       	pop	r28
    1256:	df 91       	pop	r29
    1258:	08 95       	ret

0000125a <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    125a:	df 93       	push	r29
    125c:	cf 93       	push	r28
    125e:	00 d0       	rcall	.+0      	; 0x1260 <xCoRoutineRemoveFromEventList+0x6>
    1260:	00 d0       	rcall	.+0      	; 0x1262 <xCoRoutineRemoveFromEventList+0x8>
    1262:	0f 92       	push	r0
    1264:	cd b7       	in	r28, 0x3d	; 61
    1266:	de b7       	in	r29, 0x3e	; 62
    1268:	9d 83       	std	Y+5, r25	; 0x05
    126a:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    126c:	ec 81       	ldd	r30, Y+4	; 0x04
    126e:	fd 81       	ldd	r31, Y+5	; 0x05
    1270:	05 80       	ldd	r0, Z+5	; 0x05
    1272:	f6 81       	ldd	r31, Z+6	; 0x06
    1274:	e0 2d       	mov	r30, r0
    1276:	86 81       	ldd	r24, Z+6	; 0x06
    1278:	97 81       	ldd	r25, Z+7	; 0x07
    127a:	9b 83       	std	Y+3, r25	; 0x03
    127c:	8a 83       	std	Y+2, r24	; 0x02
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    127e:	8a 81       	ldd	r24, Y+2	; 0x02
    1280:	9b 81       	ldd	r25, Y+3	; 0x03
    1282:	0c 96       	adiw	r24, 0x0c	; 12
    1284:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1288:	8a 81       	ldd	r24, Y+2	; 0x02
    128a:	9b 81       	ldd	r25, Y+3	; 0x03
    128c:	9c 01       	movw	r18, r24
    128e:	24 5f       	subi	r18, 0xF4	; 244
    1290:	3f 4f       	sbci	r19, 0xFF	; 255
    1292:	85 eb       	ldi	r24, 0xB5	; 181
    1294:	91 e0       	ldi	r25, 0x01	; 1
    1296:	b9 01       	movw	r22, r18
    1298:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    129c:	ea 81       	ldd	r30, Y+2	; 0x02
    129e:	fb 81       	ldd	r31, Y+3	; 0x03
    12a0:	96 89       	ldd	r25, Z+22	; 0x16
    12a2:	e0 91 84 01 	lds	r30, 0x0184
    12a6:	f0 91 85 01 	lds	r31, 0x0185
    12aa:	86 89       	ldd	r24, Z+22	; 0x16
    12ac:	98 17       	cp	r25, r24
    12ae:	18 f0       	brcs	.+6      	; 0x12b6 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    12b0:	81 e0       	ldi	r24, 0x01	; 1
    12b2:	89 83       	std	Y+1, r24	; 0x01
    12b4:	01 c0       	rjmp	.+2      	; 0x12b8 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    12b6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    12b8:	89 81       	ldd	r24, Y+1	; 0x01
}
    12ba:	0f 90       	pop	r0
    12bc:	0f 90       	pop	r0
    12be:	0f 90       	pop	r0
    12c0:	0f 90       	pop	r0
    12c2:	0f 90       	pop	r0
    12c4:	cf 91       	pop	r28
    12c6:	df 91       	pop	r29
    12c8:	08 95       	ret

000012ca <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
    12ca:	df 93       	push	r29
    12cc:	cf 93       	push	r28
    12ce:	00 d0       	rcall	.+0      	; 0x12d0 <xEventGroupCreate+0x6>
    12d0:	cd b7       	in	r28, 0x3d	; 61
    12d2:	de b7       	in	r29, 0x3e	; 62
EventGroup_t *pxEventBits;

	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
    12d4:	8b e0       	ldi	r24, 0x0B	; 11
    12d6:	90 e0       	ldi	r25, 0x00	; 0
    12d8:	0e 94 a5 0c 	call	0x194a	; 0x194a <pvPortMalloc>
    12dc:	9a 83       	std	Y+2, r25	; 0x02
    12de:	89 83       	std	Y+1, r24	; 0x01
	if( pxEventBits != NULL )
    12e0:	89 81       	ldd	r24, Y+1	; 0x01
    12e2:	9a 81       	ldd	r25, Y+2	; 0x02
    12e4:	00 97       	sbiw	r24, 0x00	; 0
    12e6:	49 f0       	breq	.+18     	; 0x12fa <xEventGroupCreate+0x30>
	{
		pxEventBits->uxEventBits = 0;
    12e8:	e9 81       	ldd	r30, Y+1	; 0x01
    12ea:	fa 81       	ldd	r31, Y+2	; 0x02
    12ec:	11 82       	std	Z+1, r1	; 0x01
    12ee:	10 82       	st	Z, r1
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    12f0:	89 81       	ldd	r24, Y+1	; 0x01
    12f2:	9a 81       	ldd	r25, Y+2	; 0x02
    12f4:	02 96       	adiw	r24, 0x02	; 2
    12f6:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <vListInitialise>
	else
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
    12fa:	89 81       	ldd	r24, Y+1	; 0x01
    12fc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    12fe:	0f 90       	pop	r0
    1300:	0f 90       	pop	r0
    1302:	cf 91       	pop	r28
    1304:	df 91       	pop	r29
    1306:	08 95       	ret

00001308 <xEventGroupSync>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    1308:	df 93       	push	r29
    130a:	cf 93       	push	r28
    130c:	cd b7       	in	r28, 0x3d	; 61
    130e:	de b7       	in	r29, 0x3e	; 62
    1310:	60 97       	sbiw	r28, 0x10	; 16
    1312:	0f b6       	in	r0, 0x3f	; 63
    1314:	f8 94       	cli
    1316:	de bf       	out	0x3e, r29	; 62
    1318:	0f be       	out	0x3f, r0	; 63
    131a:	cd bf       	out	0x3d, r28	; 61
    131c:	9a 87       	std	Y+10, r25	; 0x0a
    131e:	89 87       	std	Y+9, r24	; 0x09
    1320:	7c 87       	std	Y+12, r23	; 0x0c
    1322:	6b 87       	std	Y+11, r22	; 0x0b
    1324:	5e 87       	std	Y+14, r21	; 0x0e
    1326:	4d 87       	std	Y+13, r20	; 0x0d
    1328:	38 8b       	std	Y+16, r19	; 0x10
    132a:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    132c:	89 85       	ldd	r24, Y+9	; 0x09
    132e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1330:	9c 83       	std	Y+4, r25	; 0x04
    1332:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1334:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1336:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    133a:	eb 81       	ldd	r30, Y+3	; 0x03
    133c:	fc 81       	ldd	r31, Y+4	; 0x04
    133e:	80 81       	ld	r24, Z
    1340:	91 81       	ldd	r25, Z+1	; 0x01
    1342:	98 87       	std	Y+8, r25	; 0x08
    1344:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1346:	89 85       	ldd	r24, Y+9	; 0x09
    1348:	9a 85       	ldd	r25, Y+10	; 0x0a
    134a:	2b 85       	ldd	r18, Y+11	; 0x0b
    134c:	3c 85       	ldd	r19, Y+12	; 0x0c
    134e:	b9 01       	movw	r22, r18
    1350:	0e 94 56 0b 	call	0x16ac	; 0x16ac <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1354:	2f 81       	ldd	r18, Y+7	; 0x07
    1356:	38 85       	ldd	r19, Y+8	; 0x08
    1358:	8b 85       	ldd	r24, Y+11	; 0x0b
    135a:	9c 85       	ldd	r25, Y+12	; 0x0c
    135c:	28 2b       	or	r18, r24
    135e:	39 2b       	or	r19, r25
    1360:	8d 85       	ldd	r24, Y+13	; 0x0d
    1362:	9e 85       	ldd	r25, Y+14	; 0x0e
    1364:	28 23       	and	r18, r24
    1366:	39 23       	and	r19, r25
    1368:	8d 85       	ldd	r24, Y+13	; 0x0d
    136a:	9e 85       	ldd	r25, Y+14	; 0x0e
    136c:	28 17       	cp	r18, r24
    136e:	39 07       	cpc	r19, r25
    1370:	c9 f4       	brne	.+50     	; 0x13a4 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1372:	2f 81       	ldd	r18, Y+7	; 0x07
    1374:	38 85       	ldd	r19, Y+8	; 0x08
    1376:	8b 85       	ldd	r24, Y+11	; 0x0b
    1378:	9c 85       	ldd	r25, Y+12	; 0x0c
    137a:	82 2b       	or	r24, r18
    137c:	93 2b       	or	r25, r19
    137e:	9e 83       	std	Y+6, r25	; 0x06
    1380:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1382:	eb 81       	ldd	r30, Y+3	; 0x03
    1384:	fc 81       	ldd	r31, Y+4	; 0x04
    1386:	20 81       	ld	r18, Z
    1388:	31 81       	ldd	r19, Z+1	; 0x01
    138a:	8d 85       	ldd	r24, Y+13	; 0x0d
    138c:	9e 85       	ldd	r25, Y+14	; 0x0e
    138e:	80 95       	com	r24
    1390:	90 95       	com	r25
    1392:	82 23       	and	r24, r18
    1394:	93 23       	and	r25, r19
    1396:	eb 81       	ldd	r30, Y+3	; 0x03
    1398:	fc 81       	ldd	r31, Y+4	; 0x04
    139a:	91 83       	std	Z+1, r25	; 0x01
    139c:	80 83       	st	Z, r24

			xTicksToWait = 0;
    139e:	18 8a       	std	Y+16, r1	; 0x10
    13a0:	1f 86       	std	Y+15, r1	; 0x0f
    13a2:	1c c0       	rjmp	.+56     	; 0x13dc <xEventGroupSync+0xd4>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    13a4:	8f 85       	ldd	r24, Y+15	; 0x0f
    13a6:	98 89       	ldd	r25, Y+16	; 0x10
    13a8:	00 97       	sbiw	r24, 0x00	; 0
    13aa:	91 f0       	breq	.+36     	; 0x13d0 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    13ac:	8b 81       	ldd	r24, Y+3	; 0x03
    13ae:	9c 81       	ldd	r25, Y+4	; 0x04
    13b0:	bc 01       	movw	r22, r24
    13b2:	6e 5f       	subi	r22, 0xFE	; 254
    13b4:	7f 4f       	sbci	r23, 0xFF	; 255
    13b6:	8d 85       	ldd	r24, Y+13	; 0x0d
    13b8:	9e 85       	ldd	r25, Y+14	; 0x0e
    13ba:	9c 01       	movw	r18, r24
    13bc:	35 60       	ori	r19, 0x05	; 5
    13be:	4f 85       	ldd	r20, Y+15	; 0x0f
    13c0:	58 89       	ldd	r21, Y+16	; 0x10
    13c2:	cb 01       	movw	r24, r22
    13c4:	b9 01       	movw	r22, r18
    13c6:	0e 94 ae 1d 	call	0x3b5c	; 0x3b5c <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    13ca:	1e 82       	std	Y+6, r1	; 0x06
    13cc:	1d 82       	std	Y+5, r1	; 0x05
    13ce:	06 c0       	rjmp	.+12     	; 0x13dc <xEventGroupSync+0xd4>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    13d0:	eb 81       	ldd	r30, Y+3	; 0x03
    13d2:	fc 81       	ldd	r31, Y+4	; 0x04
    13d4:	80 81       	ld	r24, Z
    13d6:	91 81       	ldd	r25, Z+1	; 0x01
    13d8:	9e 83       	std	Y+6, r25	; 0x06
    13da:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    13dc:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <xTaskResumeAll>
    13e0:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    13e2:	8f 85       	ldd	r24, Y+15	; 0x0f
    13e4:	98 89       	ldd	r25, Y+16	; 0x10
    13e6:	00 97       	sbiw	r24, 0x00	; 0
    13e8:	09 f4       	brne	.+2      	; 0x13ec <xEventGroupSync+0xe4>
    13ea:	3a c0       	rjmp	.+116    	; 0x1460 <xEventGroupSync+0x158>
	{
		if( xAlreadyYielded == pdFALSE )
    13ec:	8a 81       	ldd	r24, Y+2	; 0x02
    13ee:	88 23       	and	r24, r24
    13f0:	11 f4       	brne	.+4      	; 0x13f6 <xEventGroupSync+0xee>
		{
			portYIELD_WITHIN_API();
    13f2:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    13f6:	0e 94 14 21 	call	0x4228	; 0x4228 <uxTaskResetEventItemValue>
    13fa:	9e 83       	std	Y+6, r25	; 0x06
    13fc:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    13fe:	8d 81       	ldd	r24, Y+5	; 0x05
    1400:	9e 81       	ldd	r25, Y+6	; 0x06
    1402:	80 70       	andi	r24, 0x00	; 0
    1404:	92 70       	andi	r25, 0x02	; 2
    1406:	00 97       	sbiw	r24, 0x00	; 0
    1408:	31 f5       	brne	.+76     	; 0x1456 <xEventGroupSync+0x14e>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    140a:	0f b6       	in	r0, 0x3f	; 63
    140c:	f8 94       	cli
    140e:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    1410:	eb 81       	ldd	r30, Y+3	; 0x03
    1412:	fc 81       	ldd	r31, Y+4	; 0x04
    1414:	80 81       	ld	r24, Z
    1416:	91 81       	ldd	r25, Z+1	; 0x01
    1418:	9e 83       	std	Y+6, r25	; 0x06
    141a:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    141c:	2d 81       	ldd	r18, Y+5	; 0x05
    141e:	3e 81       	ldd	r19, Y+6	; 0x06
    1420:	8d 85       	ldd	r24, Y+13	; 0x0d
    1422:	9e 85       	ldd	r25, Y+14	; 0x0e
    1424:	28 23       	and	r18, r24
    1426:	39 23       	and	r19, r25
    1428:	8d 85       	ldd	r24, Y+13	; 0x0d
    142a:	9e 85       	ldd	r25, Y+14	; 0x0e
    142c:	28 17       	cp	r18, r24
    142e:	39 07       	cpc	r19, r25
    1430:	71 f4       	brne	.+28     	; 0x144e <xEventGroupSync+0x146>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1432:	eb 81       	ldd	r30, Y+3	; 0x03
    1434:	fc 81       	ldd	r31, Y+4	; 0x04
    1436:	20 81       	ld	r18, Z
    1438:	31 81       	ldd	r19, Z+1	; 0x01
    143a:	8d 85       	ldd	r24, Y+13	; 0x0d
    143c:	9e 85       	ldd	r25, Y+14	; 0x0e
    143e:	80 95       	com	r24
    1440:	90 95       	com	r25
    1442:	82 23       	and	r24, r18
    1444:	93 23       	and	r25, r19
    1446:	eb 81       	ldd	r30, Y+3	; 0x03
    1448:	fc 81       	ldd	r31, Y+4	; 0x04
    144a:	91 83       	std	Z+1, r25	; 0x01
    144c:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    144e:	0f 90       	pop	r0
    1450:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    1452:	81 e0       	ldi	r24, 0x01	; 1
    1454:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1456:	8d 81       	ldd	r24, Y+5	; 0x05
    1458:	9e 81       	ldd	r25, Y+6	; 0x06
    145a:	90 70       	andi	r25, 0x00	; 0
    145c:	9e 83       	std	Y+6, r25	; 0x06
    145e:	8d 83       	std	Y+5, r24	; 0x05
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    1460:	8d 81       	ldd	r24, Y+5	; 0x05
    1462:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1464:	60 96       	adiw	r28, 0x10	; 16
    1466:	0f b6       	in	r0, 0x3f	; 63
    1468:	f8 94       	cli
    146a:	de bf       	out	0x3e, r29	; 62
    146c:	0f be       	out	0x3f, r0	; 63
    146e:	cd bf       	out	0x3d, r28	; 61
    1470:	cf 91       	pop	r28
    1472:	df 91       	pop	r29
    1474:	08 95       	ret

00001476 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    1476:	0f 93       	push	r16
    1478:	1f 93       	push	r17
    147a:	df 93       	push	r29
    147c:	cf 93       	push	r28
    147e:	cd b7       	in	r28, 0x3d	; 61
    1480:	de b7       	in	r29, 0x3e	; 62
    1482:	63 97       	sbiw	r28, 0x13	; 19
    1484:	0f b6       	in	r0, 0x3f	; 63
    1486:	f8 94       	cli
    1488:	de bf       	out	0x3e, r29	; 62
    148a:	0f be       	out	0x3f, r0	; 63
    148c:	cd bf       	out	0x3d, r28	; 61
    148e:	9d 87       	std	Y+13, r25	; 0x0d
    1490:	8c 87       	std	Y+12, r24	; 0x0c
    1492:	7f 87       	std	Y+15, r23	; 0x0f
    1494:	6e 87       	std	Y+14, r22	; 0x0e
    1496:	48 8b       	std	Y+16, r20	; 0x10
    1498:	29 8b       	std	Y+17, r18	; 0x11
    149a:	1b 8b       	std	Y+19, r17	; 0x13
    149c:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    149e:	8c 85       	ldd	r24, Y+12	; 0x0c
    14a0:	9d 85       	ldd	r25, Y+13	; 0x0d
    14a2:	9b 87       	std	Y+11, r25	; 0x0b
    14a4:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    14a6:	1f 82       	std	Y+7, r1	; 0x07
    14a8:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    14aa:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    14ac:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    14b0:	ea 85       	ldd	r30, Y+10	; 0x0a
    14b2:	fb 85       	ldd	r31, Y+11	; 0x0b
    14b4:	80 81       	ld	r24, Z
    14b6:	91 81       	ldd	r25, Z+1	; 0x01
    14b8:	9a 83       	std	Y+2, r25	; 0x02
    14ba:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    14bc:	89 81       	ldd	r24, Y+1	; 0x01
    14be:	9a 81       	ldd	r25, Y+2	; 0x02
    14c0:	2e 85       	ldd	r18, Y+14	; 0x0e
    14c2:	3f 85       	ldd	r19, Y+15	; 0x0f
    14c4:	b9 01       	movw	r22, r18
    14c6:	49 89       	ldd	r20, Y+17	; 0x11
    14c8:	0e 94 73 0c 	call	0x18e6	; 0x18e6 <prvTestWaitCondition>
    14cc:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    14ce:	8d 81       	ldd	r24, Y+5	; 0x05
    14d0:	88 23       	and	r24, r24
    14d2:	c1 f0       	breq	.+48     	; 0x1504 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    14d4:	89 81       	ldd	r24, Y+1	; 0x01
    14d6:	9a 81       	ldd	r25, Y+2	; 0x02
    14d8:	99 87       	std	Y+9, r25	; 0x09
    14da:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    14dc:	1b 8a       	std	Y+19, r1	; 0x13
    14de:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    14e0:	88 89       	ldd	r24, Y+16	; 0x10
    14e2:	88 23       	and	r24, r24
    14e4:	d9 f1       	breq	.+118    	; 0x155c <xEventGroupWaitBits+0xe6>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    14e6:	ea 85       	ldd	r30, Y+10	; 0x0a
    14e8:	fb 85       	ldd	r31, Y+11	; 0x0b
    14ea:	20 81       	ld	r18, Z
    14ec:	31 81       	ldd	r19, Z+1	; 0x01
    14ee:	8e 85       	ldd	r24, Y+14	; 0x0e
    14f0:	9f 85       	ldd	r25, Y+15	; 0x0f
    14f2:	80 95       	com	r24
    14f4:	90 95       	com	r25
    14f6:	82 23       	and	r24, r18
    14f8:	93 23       	and	r25, r19
    14fa:	ea 85       	ldd	r30, Y+10	; 0x0a
    14fc:	fb 85       	ldd	r31, Y+11	; 0x0b
    14fe:	91 83       	std	Z+1, r25	; 0x01
    1500:	80 83       	st	Z, r24
    1502:	2c c0       	rjmp	.+88     	; 0x155c <xEventGroupWaitBits+0xe6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    1504:	8a 89       	ldd	r24, Y+18	; 0x12
    1506:	9b 89       	ldd	r25, Y+19	; 0x13
    1508:	00 97       	sbiw	r24, 0x00	; 0
    150a:	29 f4       	brne	.+10     	; 0x1516 <xEventGroupWaitBits+0xa0>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    150c:	89 81       	ldd	r24, Y+1	; 0x01
    150e:	9a 81       	ldd	r25, Y+2	; 0x02
    1510:	99 87       	std	Y+9, r25	; 0x09
    1512:	88 87       	std	Y+8, r24	; 0x08
    1514:	23 c0       	rjmp	.+70     	; 0x155c <xEventGroupWaitBits+0xe6>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    1516:	88 89       	ldd	r24, Y+16	; 0x10
    1518:	88 23       	and	r24, r24
    151a:	29 f0       	breq	.+10     	; 0x1526 <xEventGroupWaitBits+0xb0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    151c:	8e 81       	ldd	r24, Y+6	; 0x06
    151e:	9f 81       	ldd	r25, Y+7	; 0x07
    1520:	91 60       	ori	r25, 0x01	; 1
    1522:	9f 83       	std	Y+7, r25	; 0x07
    1524:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    1526:	89 89       	ldd	r24, Y+17	; 0x11
    1528:	88 23       	and	r24, r24
    152a:	29 f0       	breq	.+10     	; 0x1536 <xEventGroupWaitBits+0xc0>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    152c:	8e 81       	ldd	r24, Y+6	; 0x06
    152e:	9f 81       	ldd	r25, Y+7	; 0x07
    1530:	94 60       	ori	r25, 0x04	; 4
    1532:	9f 83       	std	Y+7, r25	; 0x07
    1534:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    1536:	8a 85       	ldd	r24, Y+10	; 0x0a
    1538:	9b 85       	ldd	r25, Y+11	; 0x0b
    153a:	bc 01       	movw	r22, r24
    153c:	6e 5f       	subi	r22, 0xFE	; 254
    153e:	7f 4f       	sbci	r23, 0xFF	; 255
    1540:	2e 85       	ldd	r18, Y+14	; 0x0e
    1542:	3f 85       	ldd	r19, Y+15	; 0x0f
    1544:	8e 81       	ldd	r24, Y+6	; 0x06
    1546:	9f 81       	ldd	r25, Y+7	; 0x07
    1548:	28 2b       	or	r18, r24
    154a:	39 2b       	or	r19, r25
    154c:	4a 89       	ldd	r20, Y+18	; 0x12
    154e:	5b 89       	ldd	r21, Y+19	; 0x13
    1550:	cb 01       	movw	r24, r22
    1552:	b9 01       	movw	r22, r18
    1554:	0e 94 ae 1d 	call	0x3b5c	; 0x3b5c <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    1558:	19 86       	std	Y+9, r1	; 0x09
    155a:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    155c:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <xTaskResumeAll>
    1560:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    1562:	8a 89       	ldd	r24, Y+18	; 0x12
    1564:	9b 89       	ldd	r25, Y+19	; 0x13
    1566:	00 97       	sbiw	r24, 0x00	; 0
    1568:	09 f4       	brne	.+2      	; 0x156c <xEventGroupWaitBits+0xf6>
    156a:	3b c0       	rjmp	.+118    	; 0x15e2 <xEventGroupWaitBits+0x16c>
	{
		if( xAlreadyYielded == pdFALSE )
    156c:	8c 81       	ldd	r24, Y+4	; 0x04
    156e:	88 23       	and	r24, r24
    1570:	11 f4       	brne	.+4      	; 0x1576 <xEventGroupWaitBits+0x100>
		{
			portYIELD_WITHIN_API();
    1572:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1576:	0e 94 14 21 	call	0x4228	; 0x4228 <uxTaskResetEventItemValue>
    157a:	99 87       	std	Y+9, r25	; 0x09
    157c:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    157e:	88 85       	ldd	r24, Y+8	; 0x08
    1580:	99 85       	ldd	r25, Y+9	; 0x09
    1582:	80 70       	andi	r24, 0x00	; 0
    1584:	92 70       	andi	r25, 0x02	; 2
    1586:	00 97       	sbiw	r24, 0x00	; 0
    1588:	39 f5       	brne	.+78     	; 0x15d8 <xEventGroupWaitBits+0x162>
		{
			taskENTER_CRITICAL();
    158a:	0f b6       	in	r0, 0x3f	; 63
    158c:	f8 94       	cli
    158e:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1590:	ea 85       	ldd	r30, Y+10	; 0x0a
    1592:	fb 85       	ldd	r31, Y+11	; 0x0b
    1594:	80 81       	ld	r24, Z
    1596:	91 81       	ldd	r25, Z+1	; 0x01
    1598:	99 87       	std	Y+9, r25	; 0x09
    159a:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    159c:	88 85       	ldd	r24, Y+8	; 0x08
    159e:	99 85       	ldd	r25, Y+9	; 0x09
    15a0:	2e 85       	ldd	r18, Y+14	; 0x0e
    15a2:	3f 85       	ldd	r19, Y+15	; 0x0f
    15a4:	b9 01       	movw	r22, r18
    15a6:	49 89       	ldd	r20, Y+17	; 0x11
    15a8:	0e 94 73 0c 	call	0x18e6	; 0x18e6 <prvTestWaitCondition>
    15ac:	88 23       	and	r24, r24
    15ae:	89 f0       	breq	.+34     	; 0x15d2 <xEventGroupWaitBits+0x15c>
				{
					if( xClearOnExit != pdFALSE )
    15b0:	88 89       	ldd	r24, Y+16	; 0x10
    15b2:	88 23       	and	r24, r24
    15b4:	71 f0       	breq	.+28     	; 0x15d2 <xEventGroupWaitBits+0x15c>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    15b6:	ea 85       	ldd	r30, Y+10	; 0x0a
    15b8:	fb 85       	ldd	r31, Y+11	; 0x0b
    15ba:	20 81       	ld	r18, Z
    15bc:	31 81       	ldd	r19, Z+1	; 0x01
    15be:	8e 85       	ldd	r24, Y+14	; 0x0e
    15c0:	9f 85       	ldd	r25, Y+15	; 0x0f
    15c2:	80 95       	com	r24
    15c4:	90 95       	com	r25
    15c6:	82 23       	and	r24, r18
    15c8:	93 23       	and	r25, r19
    15ca:	ea 85       	ldd	r30, Y+10	; 0x0a
    15cc:	fb 85       	ldd	r31, Y+11	; 0x0b
    15ce:	91 83       	std	Z+1, r25	; 0x01
    15d0:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    15d2:	0f 90       	pop	r0
    15d4:	0f be       	out	0x3f, r0	; 63

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
    15d6:	1b 82       	std	Y+3, r1	; 0x03
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    15d8:	88 85       	ldd	r24, Y+8	; 0x08
    15da:	99 85       	ldd	r25, Y+9	; 0x09
    15dc:	90 70       	andi	r25, 0x00	; 0
    15de:	99 87       	std	Y+9, r25	; 0x09
    15e0:	88 87       	std	Y+8, r24	; 0x08
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    15e2:	88 85       	ldd	r24, Y+8	; 0x08
    15e4:	99 85       	ldd	r25, Y+9	; 0x09
}
    15e6:	63 96       	adiw	r28, 0x13	; 19
    15e8:	0f b6       	in	r0, 0x3f	; 63
    15ea:	f8 94       	cli
    15ec:	de bf       	out	0x3e, r29	; 62
    15ee:	0f be       	out	0x3f, r0	; 63
    15f0:	cd bf       	out	0x3d, r28	; 61
    15f2:	cf 91       	pop	r28
    15f4:	df 91       	pop	r29
    15f6:	1f 91       	pop	r17
    15f8:	0f 91       	pop	r16
    15fa:	08 95       	ret

000015fc <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    15fc:	df 93       	push	r29
    15fe:	cf 93       	push	r28
    1600:	cd b7       	in	r28, 0x3d	; 61
    1602:	de b7       	in	r29, 0x3e	; 62
    1604:	28 97       	sbiw	r28, 0x08	; 8
    1606:	0f b6       	in	r0, 0x3f	; 63
    1608:	f8 94       	cli
    160a:	de bf       	out	0x3e, r29	; 62
    160c:	0f be       	out	0x3f, r0	; 63
    160e:	cd bf       	out	0x3d, r28	; 61
    1610:	9e 83       	std	Y+6, r25	; 0x06
    1612:	8d 83       	std	Y+5, r24	; 0x05
    1614:	78 87       	std	Y+8, r23	; 0x08
    1616:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1618:	8d 81       	ldd	r24, Y+5	; 0x05
    161a:	9e 81       	ldd	r25, Y+6	; 0x06
    161c:	9c 83       	std	Y+4, r25	; 0x04
    161e:	8b 83       	std	Y+3, r24	; 0x03

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    1620:	0f b6       	in	r0, 0x3f	; 63
    1622:	f8 94       	cli
    1624:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    1626:	eb 81       	ldd	r30, Y+3	; 0x03
    1628:	fc 81       	ldd	r31, Y+4	; 0x04
    162a:	80 81       	ld	r24, Z
    162c:	91 81       	ldd	r25, Z+1	; 0x01
    162e:	9a 83       	std	Y+2, r25	; 0x02
    1630:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1632:	eb 81       	ldd	r30, Y+3	; 0x03
    1634:	fc 81       	ldd	r31, Y+4	; 0x04
    1636:	20 81       	ld	r18, Z
    1638:	31 81       	ldd	r19, Z+1	; 0x01
    163a:	8f 81       	ldd	r24, Y+7	; 0x07
    163c:	98 85       	ldd	r25, Y+8	; 0x08
    163e:	80 95       	com	r24
    1640:	90 95       	com	r25
    1642:	82 23       	and	r24, r18
    1644:	93 23       	and	r25, r19
    1646:	eb 81       	ldd	r30, Y+3	; 0x03
    1648:	fc 81       	ldd	r31, Y+4	; 0x04
    164a:	91 83       	std	Z+1, r25	; 0x01
    164c:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    164e:	0f 90       	pop	r0
    1650:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1652:	89 81       	ldd	r24, Y+1	; 0x01
    1654:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1656:	28 96       	adiw	r28, 0x08	; 8
    1658:	0f b6       	in	r0, 0x3f	; 63
    165a:	f8 94       	cli
    165c:	de bf       	out	0x3e, r29	; 62
    165e:	0f be       	out	0x3f, r0	; 63
    1660:	cd bf       	out	0x3d, r28	; 61
    1662:	cf 91       	pop	r28
    1664:	df 91       	pop	r29
    1666:	08 95       	ret

00001668 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1668:	df 93       	push	r29
    166a:	cf 93       	push	r28
    166c:	cd b7       	in	r28, 0x3d	; 61
    166e:	de b7       	in	r29, 0x3e	; 62
    1670:	27 97       	sbiw	r28, 0x07	; 7
    1672:	0f b6       	in	r0, 0x3f	; 63
    1674:	f8 94       	cli
    1676:	de bf       	out	0x3e, r29	; 62
    1678:	0f be       	out	0x3f, r0	; 63
    167a:	cd bf       	out	0x3d, r28	; 61
    167c:	9f 83       	std	Y+7, r25	; 0x07
    167e:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1680:	8e 81       	ldd	r24, Y+6	; 0x06
    1682:	9f 81       	ldd	r25, Y+7	; 0x07
    1684:	9c 83       	std	Y+4, r25	; 0x04
    1686:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1688:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    168a:	eb 81       	ldd	r30, Y+3	; 0x03
    168c:	fc 81       	ldd	r31, Y+4	; 0x04
    168e:	80 81       	ld	r24, Z
    1690:	91 81       	ldd	r25, Z+1	; 0x01
    1692:	9a 83       	std	Y+2, r25	; 0x02
    1694:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    1696:	89 81       	ldd	r24, Y+1	; 0x01
    1698:	9a 81       	ldd	r25, Y+2	; 0x02
}
    169a:	27 96       	adiw	r28, 0x07	; 7
    169c:	0f b6       	in	r0, 0x3f	; 63
    169e:	f8 94       	cli
    16a0:	de bf       	out	0x3e, r29	; 62
    16a2:	0f be       	out	0x3f, r0	; 63
    16a4:	cd bf       	out	0x3d, r28	; 61
    16a6:	cf 91       	pop	r28
    16a8:	df 91       	pop	r29
    16aa:	08 95       	ret

000016ac <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    16ac:	df 93       	push	r29
    16ae:	cf 93       	push	r28
    16b0:	cd b7       	in	r28, 0x3d	; 61
    16b2:	de b7       	in	r29, 0x3e	; 62
    16b4:	65 97       	sbiw	r28, 0x15	; 21
    16b6:	0f b6       	in	r0, 0x3f	; 63
    16b8:	f8 94       	cli
    16ba:	de bf       	out	0x3e, r29	; 62
    16bc:	0f be       	out	0x3f, r0	; 63
    16be:	cd bf       	out	0x3d, r28	; 61
    16c0:	9b 8b       	std	Y+19, r25	; 0x13
    16c2:	8a 8b       	std	Y+18, r24	; 0x12
    16c4:	7d 8b       	std	Y+21, r23	; 0x15
    16c6:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    16c8:	19 86       	std	Y+9, r1	; 0x09
    16ca:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    16cc:	8a 89       	ldd	r24, Y+18	; 0x12
    16ce:	9b 89       	ldd	r25, Y+19	; 0x13
    16d0:	9b 83       	std	Y+3, r25	; 0x03
    16d2:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    16d4:	19 82       	std	Y+1, r1	; 0x01

	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    16d6:	8a 81       	ldd	r24, Y+2	; 0x02
    16d8:	9b 81       	ldd	r25, Y+3	; 0x03
    16da:	02 96       	adiw	r24, 0x02	; 2
    16dc:	9b 87       	std	Y+11, r25	; 0x0b
    16de:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    16e0:	8a 85       	ldd	r24, Y+10	; 0x0a
    16e2:	9b 85       	ldd	r25, Y+11	; 0x0b
    16e4:	03 96       	adiw	r24, 0x03	; 3
    16e6:	9d 87       	std	Y+13, r25	; 0x0d
    16e8:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    16ea:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    16ee:	ea 85       	ldd	r30, Y+10	; 0x0a
    16f0:	fb 85       	ldd	r31, Y+11	; 0x0b
    16f2:	85 81       	ldd	r24, Z+5	; 0x05
    16f4:	96 81       	ldd	r25, Z+6	; 0x06
    16f6:	99 8b       	std	Y+17, r25	; 0x11
    16f8:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    16fa:	ea 81       	ldd	r30, Y+2	; 0x02
    16fc:	fb 81       	ldd	r31, Y+3	; 0x03
    16fe:	20 81       	ld	r18, Z
    1700:	31 81       	ldd	r19, Z+1	; 0x01
    1702:	8c 89       	ldd	r24, Y+20	; 0x14
    1704:	9d 89       	ldd	r25, Y+21	; 0x15
    1706:	82 2b       	or	r24, r18
    1708:	93 2b       	or	r25, r19
    170a:	ea 81       	ldd	r30, Y+2	; 0x02
    170c:	fb 81       	ldd	r31, Y+3	; 0x03
    170e:	91 83       	std	Z+1, r25	; 0x01
    1710:	80 83       	st	Z, r24
    1712:	59 c0       	rjmp	.+178    	; 0x17c6 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    1714:	e8 89       	ldd	r30, Y+16	; 0x10
    1716:	f9 89       	ldd	r31, Y+17	; 0x11
    1718:	82 81       	ldd	r24, Z+2	; 0x02
    171a:	93 81       	ldd	r25, Z+3	; 0x03
    171c:	9f 87       	std	Y+15, r25	; 0x0f
    171e:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1720:	e8 89       	ldd	r30, Y+16	; 0x10
    1722:	f9 89       	ldd	r31, Y+17	; 0x11
    1724:	80 81       	ld	r24, Z
    1726:	91 81       	ldd	r25, Z+1	; 0x01
    1728:	9f 83       	std	Y+7, r25	; 0x07
    172a:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    172c:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    172e:	8e 81       	ldd	r24, Y+6	; 0x06
    1730:	9f 81       	ldd	r25, Y+7	; 0x07
    1732:	80 70       	andi	r24, 0x00	; 0
    1734:	9d 83       	std	Y+5, r25	; 0x05
    1736:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1738:	8e 81       	ldd	r24, Y+6	; 0x06
    173a:	9f 81       	ldd	r25, Y+7	; 0x07
    173c:	90 70       	andi	r25, 0x00	; 0
    173e:	9f 83       	std	Y+7, r25	; 0x07
    1740:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1742:	8c 81       	ldd	r24, Y+4	; 0x04
    1744:	9d 81       	ldd	r25, Y+5	; 0x05
    1746:	80 70       	andi	r24, 0x00	; 0
    1748:	94 70       	andi	r25, 0x04	; 4
    174a:	00 97       	sbiw	r24, 0x00	; 0
    174c:	69 f4       	brne	.+26     	; 0x1768 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    174e:	ea 81       	ldd	r30, Y+2	; 0x02
    1750:	fb 81       	ldd	r31, Y+3	; 0x03
    1752:	20 81       	ld	r18, Z
    1754:	31 81       	ldd	r19, Z+1	; 0x01
    1756:	8e 81       	ldd	r24, Y+6	; 0x06
    1758:	9f 81       	ldd	r25, Y+7	; 0x07
    175a:	82 23       	and	r24, r18
    175c:	93 23       	and	r25, r19
    175e:	00 97       	sbiw	r24, 0x00	; 0
    1760:	91 f0       	breq	.+36     	; 0x1786 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    1762:	81 e0       	ldi	r24, 0x01	; 1
    1764:	89 83       	std	Y+1, r24	; 0x01
    1766:	0f c0       	rjmp	.+30     	; 0x1786 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1768:	ea 81       	ldd	r30, Y+2	; 0x02
    176a:	fb 81       	ldd	r31, Y+3	; 0x03
    176c:	20 81       	ld	r18, Z
    176e:	31 81       	ldd	r19, Z+1	; 0x01
    1770:	8e 81       	ldd	r24, Y+6	; 0x06
    1772:	9f 81       	ldd	r25, Y+7	; 0x07
    1774:	28 23       	and	r18, r24
    1776:	39 23       	and	r19, r25
    1778:	8e 81       	ldd	r24, Y+6	; 0x06
    177a:	9f 81       	ldd	r25, Y+7	; 0x07
    177c:	28 17       	cp	r18, r24
    177e:	39 07       	cpc	r19, r25
    1780:	11 f4       	brne	.+4      	; 0x1786 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    1782:	81 e0       	ldi	r24, 0x01	; 1
    1784:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    1786:	89 81       	ldd	r24, Y+1	; 0x01
    1788:	88 23       	and	r24, r24
    178a:	c9 f0       	breq	.+50     	; 0x17be <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    178c:	8c 81       	ldd	r24, Y+4	; 0x04
    178e:	9d 81       	ldd	r25, Y+5	; 0x05
    1790:	80 70       	andi	r24, 0x00	; 0
    1792:	91 70       	andi	r25, 0x01	; 1
    1794:	00 97       	sbiw	r24, 0x00	; 0
    1796:	41 f0       	breq	.+16     	; 0x17a8 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    1798:	88 85       	ldd	r24, Y+8	; 0x08
    179a:	99 85       	ldd	r25, Y+9	; 0x09
    179c:	2e 81       	ldd	r18, Y+6	; 0x06
    179e:	3f 81       	ldd	r19, Y+7	; 0x07
    17a0:	82 2b       	or	r24, r18
    17a2:	93 2b       	or	r25, r19
    17a4:	99 87       	std	Y+9, r25	; 0x09
    17a6:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    17a8:	ea 81       	ldd	r30, Y+2	; 0x02
    17aa:	fb 81       	ldd	r31, Y+3	; 0x03
    17ac:	80 81       	ld	r24, Z
    17ae:	91 81       	ldd	r25, Z+1	; 0x01
    17b0:	9c 01       	movw	r18, r24
    17b2:	32 60       	ori	r19, 0x02	; 2
    17b4:	88 89       	ldd	r24, Y+16	; 0x10
    17b6:	99 89       	ldd	r25, Y+17	; 0x11
    17b8:	b9 01       	movw	r22, r18
    17ba:	0e 94 5c 1e 	call	0x3cb8	; 0x3cb8 <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    17be:	8e 85       	ldd	r24, Y+14	; 0x0e
    17c0:	9f 85       	ldd	r25, Y+15	; 0x0f
    17c2:	99 8b       	std	Y+17, r25	; 0x11
    17c4:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    17c6:	28 89       	ldd	r18, Y+16	; 0x10
    17c8:	39 89       	ldd	r19, Y+17	; 0x11
    17ca:	8c 85       	ldd	r24, Y+12	; 0x0c
    17cc:	9d 85       	ldd	r25, Y+13	; 0x0d
    17ce:	28 17       	cp	r18, r24
    17d0:	39 07       	cpc	r19, r25
    17d2:	09 f0       	breq	.+2      	; 0x17d6 <xEventGroupSetBits+0x12a>
    17d4:	9f cf       	rjmp	.-194    	; 0x1714 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    17d6:	ea 81       	ldd	r30, Y+2	; 0x02
    17d8:	fb 81       	ldd	r31, Y+3	; 0x03
    17da:	20 81       	ld	r18, Z
    17dc:	31 81       	ldd	r19, Z+1	; 0x01
    17de:	88 85       	ldd	r24, Y+8	; 0x08
    17e0:	99 85       	ldd	r25, Y+9	; 0x09
    17e2:	80 95       	com	r24
    17e4:	90 95       	com	r25
    17e6:	82 23       	and	r24, r18
    17e8:	93 23       	and	r25, r19
    17ea:	ea 81       	ldd	r30, Y+2	; 0x02
    17ec:	fb 81       	ldd	r31, Y+3	; 0x03
    17ee:	91 83       	std	Z+1, r25	; 0x01
    17f0:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    17f2:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    17f6:	ea 81       	ldd	r30, Y+2	; 0x02
    17f8:	fb 81       	ldd	r31, Y+3	; 0x03
    17fa:	80 81       	ld	r24, Z
    17fc:	91 81       	ldd	r25, Z+1	; 0x01
}
    17fe:	65 96       	adiw	r28, 0x15	; 21
    1800:	0f b6       	in	r0, 0x3f	; 63
    1802:	f8 94       	cli
    1804:	de bf       	out	0x3e, r29	; 62
    1806:	0f be       	out	0x3f, r0	; 63
    1808:	cd bf       	out	0x3d, r28	; 61
    180a:	cf 91       	pop	r28
    180c:	df 91       	pop	r29
    180e:	08 95       	ret

00001810 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1810:	df 93       	push	r29
    1812:	cf 93       	push	r28
    1814:	00 d0       	rcall	.+0      	; 0x1816 <vEventGroupDelete+0x6>
    1816:	00 d0       	rcall	.+0      	; 0x1818 <vEventGroupDelete+0x8>
    1818:	00 d0       	rcall	.+0      	; 0x181a <vEventGroupDelete+0xa>
    181a:	cd b7       	in	r28, 0x3d	; 61
    181c:	de b7       	in	r29, 0x3e	; 62
    181e:	9e 83       	std	Y+6, r25	; 0x06
    1820:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1822:	8d 81       	ldd	r24, Y+5	; 0x05
    1824:	9e 81       	ldd	r25, Y+6	; 0x06
    1826:	9c 83       	std	Y+4, r25	; 0x04
    1828:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    182a:	8b 81       	ldd	r24, Y+3	; 0x03
    182c:	9c 81       	ldd	r25, Y+4	; 0x04
    182e:	02 96       	adiw	r24, 0x02	; 2
    1830:	9a 83       	std	Y+2, r25	; 0x02
    1832:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    1834:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vTaskSuspendAll>
    1838:	08 c0       	rjmp	.+16     	; 0x184a <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    183a:	e9 81       	ldd	r30, Y+1	; 0x01
    183c:	fa 81       	ldd	r31, Y+2	; 0x02
    183e:	85 81       	ldd	r24, Z+5	; 0x05
    1840:	96 81       	ldd	r25, Z+6	; 0x06
    1842:	60 e0       	ldi	r22, 0x00	; 0
    1844:	72 e0       	ldi	r23, 0x02	; 2
    1846:	0e 94 5c 1e 	call	0x3cb8	; 0x3cb8 <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    184a:	e9 81       	ldd	r30, Y+1	; 0x01
    184c:	fa 81       	ldd	r31, Y+2	; 0x02
    184e:	80 81       	ld	r24, Z
    1850:	88 23       	and	r24, r24
    1852:	99 f7       	brne	.-26     	; 0x183a <vEventGroupDelete+0x2a>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
    1854:	8b 81       	ldd	r24, Y+3	; 0x03
    1856:	9c 81       	ldd	r25, Y+4	; 0x04
    1858:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <vPortFree>
	}
	( void ) xTaskResumeAll();
    185c:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <xTaskResumeAll>
}
    1860:	26 96       	adiw	r28, 0x06	; 6
    1862:	0f b6       	in	r0, 0x3f	; 63
    1864:	f8 94       	cli
    1866:	de bf       	out	0x3e, r29	; 62
    1868:	0f be       	out	0x3f, r0	; 63
    186a:	cd bf       	out	0x3d, r28	; 61
    186c:	cf 91       	pop	r28
    186e:	df 91       	pop	r29
    1870:	08 95       	ret

00001872 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    1872:	df 93       	push	r29
    1874:	cf 93       	push	r28
    1876:	00 d0       	rcall	.+0      	; 0x1878 <vEventGroupSetBitsCallback+0x6>
    1878:	00 d0       	rcall	.+0      	; 0x187a <vEventGroupSetBitsCallback+0x8>
    187a:	00 d0       	rcall	.+0      	; 0x187c <vEventGroupSetBitsCallback+0xa>
    187c:	cd b7       	in	r28, 0x3d	; 61
    187e:	de b7       	in	r29, 0x3e	; 62
    1880:	9a 83       	std	Y+2, r25	; 0x02
    1882:	89 83       	std	Y+1, r24	; 0x01
    1884:	4b 83       	std	Y+3, r20	; 0x03
    1886:	5c 83       	std	Y+4, r21	; 0x04
    1888:	6d 83       	std	Y+5, r22	; 0x05
    188a:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
    188c:	2b 81       	ldd	r18, Y+3	; 0x03
    188e:	3c 81       	ldd	r19, Y+4	; 0x04
    1890:	89 81       	ldd	r24, Y+1	; 0x01
    1892:	9a 81       	ldd	r25, Y+2	; 0x02
    1894:	b9 01       	movw	r22, r18
    1896:	0e 94 56 0b 	call	0x16ac	; 0x16ac <xEventGroupSetBits>
}
    189a:	26 96       	adiw	r28, 0x06	; 6
    189c:	0f b6       	in	r0, 0x3f	; 63
    189e:	f8 94       	cli
    18a0:	de bf       	out	0x3e, r29	; 62
    18a2:	0f be       	out	0x3f, r0	; 63
    18a4:	cd bf       	out	0x3d, r28	; 61
    18a6:	cf 91       	pop	r28
    18a8:	df 91       	pop	r29
    18aa:	08 95       	ret

000018ac <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    18ac:	df 93       	push	r29
    18ae:	cf 93       	push	r28
    18b0:	00 d0       	rcall	.+0      	; 0x18b2 <vEventGroupClearBitsCallback+0x6>
    18b2:	00 d0       	rcall	.+0      	; 0x18b4 <vEventGroupClearBitsCallback+0x8>
    18b4:	00 d0       	rcall	.+0      	; 0x18b6 <vEventGroupClearBitsCallback+0xa>
    18b6:	cd b7       	in	r28, 0x3d	; 61
    18b8:	de b7       	in	r29, 0x3e	; 62
    18ba:	9a 83       	std	Y+2, r25	; 0x02
    18bc:	89 83       	std	Y+1, r24	; 0x01
    18be:	4b 83       	std	Y+3, r20	; 0x03
    18c0:	5c 83       	std	Y+4, r21	; 0x04
    18c2:	6d 83       	std	Y+5, r22	; 0x05
    18c4:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
    18c6:	2b 81       	ldd	r18, Y+3	; 0x03
    18c8:	3c 81       	ldd	r19, Y+4	; 0x04
    18ca:	89 81       	ldd	r24, Y+1	; 0x01
    18cc:	9a 81       	ldd	r25, Y+2	; 0x02
    18ce:	b9 01       	movw	r22, r18
    18d0:	0e 94 fe 0a 	call	0x15fc	; 0x15fc <xEventGroupClearBits>
}
    18d4:	26 96       	adiw	r28, 0x06	; 6
    18d6:	0f b6       	in	r0, 0x3f	; 63
    18d8:	f8 94       	cli
    18da:	de bf       	out	0x3e, r29	; 62
    18dc:	0f be       	out	0x3f, r0	; 63
    18de:	cd bf       	out	0x3d, r28	; 61
    18e0:	cf 91       	pop	r28
    18e2:	df 91       	pop	r29
    18e4:	08 95       	ret

000018e6 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    18e6:	df 93       	push	r29
    18e8:	cf 93       	push	r28
    18ea:	00 d0       	rcall	.+0      	; 0x18ec <prvTestWaitCondition+0x6>
    18ec:	00 d0       	rcall	.+0      	; 0x18ee <prvTestWaitCondition+0x8>
    18ee:	00 d0       	rcall	.+0      	; 0x18f0 <prvTestWaitCondition+0xa>
    18f0:	cd b7       	in	r28, 0x3d	; 61
    18f2:	de b7       	in	r29, 0x3e	; 62
    18f4:	9b 83       	std	Y+3, r25	; 0x03
    18f6:	8a 83       	std	Y+2, r24	; 0x02
    18f8:	7d 83       	std	Y+5, r23	; 0x05
    18fa:	6c 83       	std	Y+4, r22	; 0x04
    18fc:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    18fe:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    1900:	8e 81       	ldd	r24, Y+6	; 0x06
    1902:	88 23       	and	r24, r24
    1904:	59 f4       	brne	.+22     	; 0x191c <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1906:	8a 81       	ldd	r24, Y+2	; 0x02
    1908:	9b 81       	ldd	r25, Y+3	; 0x03
    190a:	2c 81       	ldd	r18, Y+4	; 0x04
    190c:	3d 81       	ldd	r19, Y+5	; 0x05
    190e:	82 23       	and	r24, r18
    1910:	93 23       	and	r25, r19
    1912:	00 97       	sbiw	r24, 0x00	; 0
    1914:	81 f0       	breq	.+32     	; 0x1936 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1916:	81 e0       	ldi	r24, 0x01	; 1
    1918:	89 83       	std	Y+1, r24	; 0x01
    191a:	0d c0       	rjmp	.+26     	; 0x1936 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    191c:	2a 81       	ldd	r18, Y+2	; 0x02
    191e:	3b 81       	ldd	r19, Y+3	; 0x03
    1920:	8c 81       	ldd	r24, Y+4	; 0x04
    1922:	9d 81       	ldd	r25, Y+5	; 0x05
    1924:	28 23       	and	r18, r24
    1926:	39 23       	and	r19, r25
    1928:	8c 81       	ldd	r24, Y+4	; 0x04
    192a:	9d 81       	ldd	r25, Y+5	; 0x05
    192c:	28 17       	cp	r18, r24
    192e:	39 07       	cpc	r19, r25
    1930:	11 f4       	brne	.+4      	; 0x1936 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1932:	81 e0       	ldi	r24, 0x01	; 1
    1934:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    1936:	89 81       	ldd	r24, Y+1	; 0x01
}
    1938:	26 96       	adiw	r28, 0x06	; 6
    193a:	0f b6       	in	r0, 0x3f	; 63
    193c:	f8 94       	cli
    193e:	de bf       	out	0x3e, r29	; 62
    1940:	0f be       	out	0x3f, r0	; 63
    1942:	cd bf       	out	0x3d, r28	; 61
    1944:	cf 91       	pop	r28
    1946:	df 91       	pop	r29
    1948:	08 95       	ret

0000194a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    194a:	df 93       	push	r29
    194c:	cf 93       	push	r28
    194e:	00 d0       	rcall	.+0      	; 0x1950 <pvPortMalloc+0x6>
    1950:	00 d0       	rcall	.+0      	; 0x1952 <pvPortMalloc+0x8>
    1952:	cd b7       	in	r28, 0x3d	; 61
    1954:	de b7       	in	r29, 0x3e	; 62
    1956:	9c 83       	std	Y+4, r25	; 0x04
    1958:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    195a:	1a 82       	std	Y+2, r1	; 0x02
    195c:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    195e:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1962:	80 91 c0 01 	lds	r24, 0x01C0
    1966:	90 91 c1 01 	lds	r25, 0x01C1
    196a:	00 97       	sbiw	r24, 0x00	; 0
    196c:	31 f4       	brne	.+12     	; 0x197a <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    196e:	83 ec       	ldi	r24, 0xC3	; 195
    1970:	91 e0       	ldi	r25, 0x01	; 1
    1972:	90 93 c1 01 	sts	0x01C1, r25
    1976:	80 93 c0 01 	sts	0x01C0, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    197a:	80 91 be 01 	lds	r24, 0x01BE
    197e:	90 91 bf 01 	lds	r25, 0x01BF
    1982:	2b 81       	ldd	r18, Y+3	; 0x03
    1984:	3c 81       	ldd	r19, Y+4	; 0x04
    1986:	82 0f       	add	r24, r18
    1988:	93 1f       	adc	r25, r19
    198a:	25 e0       	ldi	r18, 0x05	; 5
    198c:	8b 3d       	cpi	r24, 0xDB	; 219
    198e:	92 07       	cpc	r25, r18
    1990:	38 f5       	brcc	.+78     	; 0x19e0 <pvPortMalloc+0x96>
    1992:	20 91 be 01 	lds	r18, 0x01BE
    1996:	30 91 bf 01 	lds	r19, 0x01BF
    199a:	8b 81       	ldd	r24, Y+3	; 0x03
    199c:	9c 81       	ldd	r25, Y+4	; 0x04
    199e:	28 0f       	add	r18, r24
    19a0:	39 1f       	adc	r19, r25
    19a2:	80 91 be 01 	lds	r24, 0x01BE
    19a6:	90 91 bf 01 	lds	r25, 0x01BF
    19aa:	82 17       	cp	r24, r18
    19ac:	93 07       	cpc	r25, r19
    19ae:	c0 f4       	brcc	.+48     	; 0x19e0 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    19b0:	20 91 c0 01 	lds	r18, 0x01C0
    19b4:	30 91 c1 01 	lds	r19, 0x01C1
    19b8:	80 91 be 01 	lds	r24, 0x01BE
    19bc:	90 91 bf 01 	lds	r25, 0x01BF
    19c0:	82 0f       	add	r24, r18
    19c2:	93 1f       	adc	r25, r19
    19c4:	9a 83       	std	Y+2, r25	; 0x02
    19c6:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    19c8:	20 91 be 01 	lds	r18, 0x01BE
    19cc:	30 91 bf 01 	lds	r19, 0x01BF
    19d0:	8b 81       	ldd	r24, Y+3	; 0x03
    19d2:	9c 81       	ldd	r25, Y+4	; 0x04
    19d4:	82 0f       	add	r24, r18
    19d6:	93 1f       	adc	r25, r19
    19d8:	90 93 bf 01 	sts	0x01BF, r25
    19dc:	80 93 be 01 	sts	0x01BE, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    19e0:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    19e4:	89 81       	ldd	r24, Y+1	; 0x01
    19e6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    19e8:	0f 90       	pop	r0
    19ea:	0f 90       	pop	r0
    19ec:	0f 90       	pop	r0
    19ee:	0f 90       	pop	r0
    19f0:	cf 91       	pop	r28
    19f2:	df 91       	pop	r29
    19f4:	08 95       	ret

000019f6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    19f6:	df 93       	push	r29
    19f8:	cf 93       	push	r28
    19fa:	00 d0       	rcall	.+0      	; 0x19fc <vPortFree+0x6>
    19fc:	cd b7       	in	r28, 0x3d	; 61
    19fe:	de b7       	in	r29, 0x3e	; 62
    1a00:	9a 83       	std	Y+2, r25	; 0x02
    1a02:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    1a04:	0f 90       	pop	r0
    1a06:	0f 90       	pop	r0
    1a08:	cf 91       	pop	r28
    1a0a:	df 91       	pop	r29
    1a0c:	08 95       	ret

00001a0e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1a0e:	df 93       	push	r29
    1a10:	cf 93       	push	r28
    1a12:	cd b7       	in	r28, 0x3d	; 61
    1a14:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1a16:	10 92 bf 01 	sts	0x01BF, r1
    1a1a:	10 92 be 01 	sts	0x01BE, r1
}
    1a1e:	cf 91       	pop	r28
    1a20:	df 91       	pop	r29
    1a22:	08 95       	ret

00001a24 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1a24:	df 93       	push	r29
    1a26:	cf 93       	push	r28
    1a28:	cd b7       	in	r28, 0x3d	; 61
    1a2a:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1a2c:	20 91 be 01 	lds	r18, 0x01BE
    1a30:	30 91 bf 01 	lds	r19, 0x01BF
    1a34:	8b ed       	ldi	r24, 0xDB	; 219
    1a36:	95 e0       	ldi	r25, 0x05	; 5
    1a38:	82 1b       	sub	r24, r18
    1a3a:	93 0b       	sbc	r25, r19
}
    1a3c:	cf 91       	pop	r28
    1a3e:	df 91       	pop	r29
    1a40:	08 95       	ret

00001a42 <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    1a42:	af 92       	push	r10
    1a44:	bf 92       	push	r11
    1a46:	cf 92       	push	r12
    1a48:	df 92       	push	r13
    1a4a:	ef 92       	push	r14
    1a4c:	ff 92       	push	r15
    1a4e:	0f 93       	push	r16
    1a50:	df 93       	push	r29
    1a52:	cf 93       	push	r28
    1a54:	00 d0       	rcall	.+0      	; 0x1a56 <vStartIntegerMathTasks+0x14>
    1a56:	0f 92       	push	r0
    1a58:	cd b7       	in	r28, 0x3d	; 61
    1a5a:	de b7       	in	r29, 0x3e	; 62
    1a5c:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1a5e:	1a 82       	std	Y+2, r1	; 0x02
    1a60:	19 82       	std	Y+1, r1	; 0x01
    1a62:	1b c0       	rjmp	.+54     	; 0x1a9a <vStartIntegerMathTasks+0x58>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    1a64:	89 81       	ldd	r24, Y+1	; 0x01
    1a66:	9a 81       	ldd	r25, Y+2	; 0x02
    1a68:	fc 01       	movw	r30, r24
    1a6a:	e2 56       	subi	r30, 0x62	; 98
    1a6c:	f8 4f       	sbci	r31, 0xF8	; 248
    1a6e:	8f e5       	ldi	r24, 0x5F	; 95
    1a70:	9d e0       	ldi	r25, 0x0D	; 13
    1a72:	20 e7       	ldi	r18, 0x70	; 112
    1a74:	30 e0       	ldi	r19, 0x00	; 0
    1a76:	b9 01       	movw	r22, r18
    1a78:	45 e5       	ldi	r20, 0x55	; 85
    1a7a:	50 e0       	ldi	r21, 0x00	; 0
    1a7c:	9f 01       	movw	r18, r30
    1a7e:	0b 81       	ldd	r16, Y+3	; 0x03
    1a80:	ee 24       	eor	r14, r14
    1a82:	ff 24       	eor	r15, r15
    1a84:	cc 24       	eor	r12, r12
    1a86:	dd 24       	eor	r13, r13
    1a88:	aa 24       	eor	r10, r10
    1a8a:	bb 24       	eor	r11, r11
    1a8c:	0e 94 2c 19 	call	0x3258	; 0x3258 <xTaskGenericCreate>

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1a90:	89 81       	ldd	r24, Y+1	; 0x01
    1a92:	9a 81       	ldd	r25, Y+2	; 0x02
    1a94:	01 96       	adiw	r24, 0x01	; 1
    1a96:	9a 83       	std	Y+2, r25	; 0x02
    1a98:	89 83       	std	Y+1, r24	; 0x01
    1a9a:	89 81       	ldd	r24, Y+1	; 0x01
    1a9c:	9a 81       	ldd	r25, Y+2	; 0x02
    1a9e:	18 16       	cp	r1, r24
    1aa0:	19 06       	cpc	r1, r25
    1aa2:	04 f7       	brge	.-64     	; 0x1a64 <vStartIntegerMathTasks+0x22>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
	}
}
    1aa4:	0f 90       	pop	r0
    1aa6:	0f 90       	pop	r0
    1aa8:	0f 90       	pop	r0
    1aaa:	cf 91       	pop	r28
    1aac:	df 91       	pop	r29
    1aae:	0f 91       	pop	r16
    1ab0:	ff 90       	pop	r15
    1ab2:	ef 90       	pop	r14
    1ab4:	df 90       	pop	r13
    1ab6:	cf 90       	pop	r12
    1ab8:	bf 90       	pop	r11
    1aba:	af 90       	pop	r10
    1abc:	08 95       	ret

00001abe <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    1abe:	df 93       	push	r29
    1ac0:	cf 93       	push	r28
    1ac2:	cd b7       	in	r28, 0x3d	; 61
    1ac4:	de b7       	in	r29, 0x3e	; 62
    1ac6:	2a 97       	sbiw	r28, 0x0a	; 10
    1ac8:	0f b6       	in	r0, 0x3f	; 63
    1aca:	f8 94       	cli
    1acc:	de bf       	out	0x3e, r29	; 62
    1ace:	0f be       	out	0x3f, r0	; 63
    1ad0:	cd bf       	out	0x3d, r28	; 61
    1ad2:	9a 87       	std	Y+10, r25	; 0x0a
    1ad4:	89 87       	std	Y+9, r24	; 0x09
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    1ad6:	1c 82       	std	Y+4, r1	; 0x04
    1ad8:	1b 82       	std	Y+3, r1	; 0x03
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    1ada:	89 85       	ldd	r24, Y+9	; 0x09
    1adc:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ade:	9a 83       	std	Y+2, r25	; 0x02
    1ae0:	89 83       	std	Y+1, r24	; 0x01
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    1ae2:	8b e7       	ldi	r24, 0x7B	; 123
    1ae4:	90 e0       	ldi	r25, 0x00	; 0
    1ae6:	a0 e0       	ldi	r26, 0x00	; 0
    1ae8:	b0 e0       	ldi	r27, 0x00	; 0
    1aea:	8d 83       	std	Y+5, r24	; 0x05
    1aec:	9e 83       	std	Y+6, r25	; 0x06
    1aee:	af 83       	std	Y+7, r26	; 0x07
    1af0:	b8 87       	std	Y+8, r27	; 0x08
		lValue += intgCONST2;
    1af2:	8d 81       	ldd	r24, Y+5	; 0x05
    1af4:	9e 81       	ldd	r25, Y+6	; 0x06
    1af6:	af 81       	ldd	r26, Y+7	; 0x07
    1af8:	b8 85       	ldd	r27, Y+8	; 0x08
    1afa:	89 5b       	subi	r24, 0xB9	; 185
    1afc:	9b 46       	sbci	r25, 0x6B	; 107
    1afe:	ac 4f       	sbci	r26, 0xFC	; 252
    1b00:	bf 4f       	sbci	r27, 0xFF	; 255
    1b02:	8d 83       	std	Y+5, r24	; 0x05
    1b04:	9e 83       	std	Y+6, r25	; 0x06
    1b06:	af 83       	std	Y+7, r26	; 0x07
    1b08:	b8 87       	std	Y+8, r27	; 0x08
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    1b0a:	8d 81       	ldd	r24, Y+5	; 0x05
    1b0c:	9e 81       	ldd	r25, Y+6	; 0x06
    1b0e:	af 81       	ldd	r26, Y+7	; 0x07
    1b10:	b8 85       	ldd	r27, Y+8	; 0x08
    1b12:	2d ef       	ldi	r18, 0xFD	; 253
    1b14:	3f ef       	ldi	r19, 0xFF	; 255
    1b16:	4f ef       	ldi	r20, 0xFF	; 255
    1b18:	5f ef       	ldi	r21, 0xFF	; 255
    1b1a:	bc 01       	movw	r22, r24
    1b1c:	cd 01       	movw	r24, r26
    1b1e:	0e 94 2f 2e 	call	0x5c5e	; 0x5c5e <__mulsi3>
    1b22:	dc 01       	movw	r26, r24
    1b24:	cb 01       	movw	r24, r22
    1b26:	8d 83       	std	Y+5, r24	; 0x05
    1b28:	9e 83       	std	Y+6, r25	; 0x06
    1b2a:	af 83       	std	Y+7, r26	; 0x07
    1b2c:	b8 87       	std	Y+8, r27	; 0x08
		lValue /= intgCONST4;
    1b2e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b30:	9e 81       	ldd	r25, Y+6	; 0x06
    1b32:	af 81       	ldd	r26, Y+7	; 0x07
    1b34:	b8 85       	ldd	r27, Y+8	; 0x08
    1b36:	27 e0       	ldi	r18, 0x07	; 7
    1b38:	30 e0       	ldi	r19, 0x00	; 0
    1b3a:	40 e0       	ldi	r20, 0x00	; 0
    1b3c:	50 e0       	ldi	r21, 0x00	; 0
    1b3e:	bc 01       	movw	r22, r24
    1b40:	cd 01       	movw	r24, r26
    1b42:	0e 94 70 2e 	call	0x5ce0	; 0x5ce0 <__divmodsi4>
    1b46:	da 01       	movw	r26, r20
    1b48:	c9 01       	movw	r24, r18
    1b4a:	8d 83       	std	Y+5, r24	; 0x05
    1b4c:	9e 83       	std	Y+6, r25	; 0x06
    1b4e:	af 83       	std	Y+7, r26	; 0x07
    1b50:	b8 87       	std	Y+8, r27	; 0x08

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    1b52:	8d 81       	ldd	r24, Y+5	; 0x05
    1b54:	9e 81       	ldd	r25, Y+6	; 0x06
    1b56:	af 81       	ldd	r26, Y+7	; 0x07
    1b58:	b8 85       	ldd	r27, Y+8	; 0x08
    1b5a:	8b 31       	cpi	r24, 0x1B	; 27
    1b5c:	27 e7       	ldi	r18, 0x77	; 119
    1b5e:	92 07       	cpc	r25, r18
    1b60:	2e ef       	ldi	r18, 0xFE	; 254
    1b62:	a2 07       	cpc	r26, r18
    1b64:	2f ef       	ldi	r18, 0xFF	; 255
    1b66:	b2 07       	cpc	r27, r18
    1b68:	21 f0       	breq	.+8      	; 0x1b72 <vCompeteingIntMathTask+0xb4>
		{
			sError = pdTRUE;
    1b6a:	81 e0       	ldi	r24, 0x01	; 1
    1b6c:	90 e0       	ldi	r25, 0x00	; 0
    1b6e:	9c 83       	std	Y+4, r25	; 0x04
    1b70:	8b 83       	std	Y+3, r24	; 0x03
		}

		if( sError == pdFALSE )
    1b72:	8b 81       	ldd	r24, Y+3	; 0x03
    1b74:	9c 81       	ldd	r25, Y+4	; 0x04
    1b76:	00 97       	sbiw	r24, 0x00	; 0
    1b78:	09 f0       	breq	.+2      	; 0x1b7c <vCompeteingIntMathTask+0xbe>
    1b7a:	b3 cf       	rjmp	.-154    	; 0x1ae2 <vCompeteingIntMathTask+0x24>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    1b7c:	0f b6       	in	r0, 0x3f	; 63
    1b7e:	f8 94       	cli
    1b80:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    1b82:	e9 81       	ldd	r30, Y+1	; 0x01
    1b84:	fa 81       	ldd	r31, Y+2	; 0x02
    1b86:	81 e0       	ldi	r24, 0x01	; 1
    1b88:	80 83       	st	Z, r24
			portEXIT_CRITICAL();
    1b8a:	0f 90       	pop	r0
    1b8c:	0f be       	out	0x3f, r0	; 63
    1b8e:	a9 cf       	rjmp	.-174    	; 0x1ae2 <vCompeteingIntMathTask+0x24>

00001b90 <xAreIntegerMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
    1b90:	df 93       	push	r29
    1b92:	cf 93       	push	r28
    1b94:	00 d0       	rcall	.+0      	; 0x1b96 <xAreIntegerMathsTaskStillRunning+0x6>
    1b96:	0f 92       	push	r0
    1b98:	cd b7       	in	r28, 0x3d	; 61
    1b9a:	de b7       	in	r29, 0x3e	; 62
BaseType_t xReturn = pdTRUE;
    1b9c:	81 e0       	ldi	r24, 0x01	; 1
    1b9e:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1ba0:	1a 82       	std	Y+2, r1	; 0x02
    1ba2:	19 82       	std	Y+1, r1	; 0x01
    1ba4:	14 c0       	rjmp	.+40     	; 0x1bce <xAreIntegerMathsTaskStillRunning+0x3e>
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    1ba6:	89 81       	ldd	r24, Y+1	; 0x01
    1ba8:	9a 81       	ldd	r25, Y+2	; 0x02
    1baa:	fc 01       	movw	r30, r24
    1bac:	e2 56       	subi	r30, 0x62	; 98
    1bae:	f8 4f       	sbci	r31, 0xF8	; 248
    1bb0:	80 81       	ld	r24, Z
    1bb2:	88 23       	and	r24, r24
    1bb4:	09 f4       	brne	.+2      	; 0x1bb8 <xAreIntegerMathsTaskStillRunning+0x28>
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
    1bb6:	1b 82       	std	Y+3, r1	; 0x03
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    1bb8:	89 81       	ldd	r24, Y+1	; 0x01
    1bba:	9a 81       	ldd	r25, Y+2	; 0x02
    1bbc:	fc 01       	movw	r30, r24
    1bbe:	e2 56       	subi	r30, 0x62	; 98
    1bc0:	f8 4f       	sbci	r31, 0xF8	; 248
    1bc2:	10 82       	st	Z, r1
BaseType_t xReturn = pdTRUE;
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1bc4:	89 81       	ldd	r24, Y+1	; 0x01
    1bc6:	9a 81       	ldd	r25, Y+2	; 0x02
    1bc8:	01 96       	adiw	r24, 0x01	; 1
    1bca:	9a 83       	std	Y+2, r25	; 0x02
    1bcc:	89 83       	std	Y+1, r24	; 0x01
    1bce:	89 81       	ldd	r24, Y+1	; 0x01
    1bd0:	9a 81       	ldd	r25, Y+2	; 0x02
    1bd2:	18 16       	cp	r1, r24
    1bd4:	19 06       	cpc	r1, r25
    1bd6:	3c f7       	brge	.-50     	; 0x1ba6 <xAreIntegerMathsTaskStillRunning+0x16>
		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
    1bd8:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1bda:	0f 90       	pop	r0
    1bdc:	0f 90       	pop	r0
    1bde:	0f 90       	pop	r0
    1be0:	cf 91       	pop	r28
    1be2:	df 91       	pop	r29
    1be4:	08 95       	ret

00001be6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1be6:	df 93       	push	r29
    1be8:	cf 93       	push	r28
    1bea:	00 d0       	rcall	.+0      	; 0x1bec <vListInitialise+0x6>
    1bec:	cd b7       	in	r28, 0x3d	; 61
    1bee:	de b7       	in	r29, 0x3e	; 62
    1bf0:	9a 83       	std	Y+2, r25	; 0x02
    1bf2:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bf4:	89 81       	ldd	r24, Y+1	; 0x01
    1bf6:	9a 81       	ldd	r25, Y+2	; 0x02
    1bf8:	03 96       	adiw	r24, 0x03	; 3
    1bfa:	e9 81       	ldd	r30, Y+1	; 0x01
    1bfc:	fa 81       	ldd	r31, Y+2	; 0x02
    1bfe:	92 83       	std	Z+2, r25	; 0x02
    1c00:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1c02:	e9 81       	ldd	r30, Y+1	; 0x01
    1c04:	fa 81       	ldd	r31, Y+2	; 0x02
    1c06:	8f ef       	ldi	r24, 0xFF	; 255
    1c08:	9f ef       	ldi	r25, 0xFF	; 255
    1c0a:	94 83       	std	Z+4, r25	; 0x04
    1c0c:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c0e:	89 81       	ldd	r24, Y+1	; 0x01
    1c10:	9a 81       	ldd	r25, Y+2	; 0x02
    1c12:	03 96       	adiw	r24, 0x03	; 3
    1c14:	e9 81       	ldd	r30, Y+1	; 0x01
    1c16:	fa 81       	ldd	r31, Y+2	; 0x02
    1c18:	96 83       	std	Z+6, r25	; 0x06
    1c1a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c1c:	89 81       	ldd	r24, Y+1	; 0x01
    1c1e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c20:	03 96       	adiw	r24, 0x03	; 3
    1c22:	e9 81       	ldd	r30, Y+1	; 0x01
    1c24:	fa 81       	ldd	r31, Y+2	; 0x02
    1c26:	90 87       	std	Z+8, r25	; 0x08
    1c28:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1c2a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c2c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c2e:	10 82       	st	Z, r1
}
    1c30:	0f 90       	pop	r0
    1c32:	0f 90       	pop	r0
    1c34:	cf 91       	pop	r28
    1c36:	df 91       	pop	r29
    1c38:	08 95       	ret

00001c3a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1c3a:	df 93       	push	r29
    1c3c:	cf 93       	push	r28
    1c3e:	00 d0       	rcall	.+0      	; 0x1c40 <vListInitialiseItem+0x6>
    1c40:	cd b7       	in	r28, 0x3d	; 61
    1c42:	de b7       	in	r29, 0x3e	; 62
    1c44:	9a 83       	std	Y+2, r25	; 0x02
    1c46:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1c48:	e9 81       	ldd	r30, Y+1	; 0x01
    1c4a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c4c:	11 86       	std	Z+9, r1	; 0x09
    1c4e:	10 86       	std	Z+8, r1	; 0x08
}
    1c50:	0f 90       	pop	r0
    1c52:	0f 90       	pop	r0
    1c54:	cf 91       	pop	r28
    1c56:	df 91       	pop	r29
    1c58:	08 95       	ret

00001c5a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c5a:	df 93       	push	r29
    1c5c:	cf 93       	push	r28
    1c5e:	00 d0       	rcall	.+0      	; 0x1c60 <vListInsertEnd+0x6>
    1c60:	00 d0       	rcall	.+0      	; 0x1c62 <vListInsertEnd+0x8>
    1c62:	00 d0       	rcall	.+0      	; 0x1c64 <vListInsertEnd+0xa>
    1c64:	cd b7       	in	r28, 0x3d	; 61
    1c66:	de b7       	in	r29, 0x3e	; 62
    1c68:	9c 83       	std	Y+4, r25	; 0x04
    1c6a:	8b 83       	std	Y+3, r24	; 0x03
    1c6c:	7e 83       	std	Y+6, r23	; 0x06
    1c6e:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    1c70:	eb 81       	ldd	r30, Y+3	; 0x03
    1c72:	fc 81       	ldd	r31, Y+4	; 0x04
    1c74:	81 81       	ldd	r24, Z+1	; 0x01
    1c76:	92 81       	ldd	r25, Z+2	; 0x02
    1c78:	9a 83       	std	Y+2, r25	; 0x02
    1c7a:	89 83       	std	Y+1, r24	; 0x01

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1c7c:	ed 81       	ldd	r30, Y+5	; 0x05
    1c7e:	fe 81       	ldd	r31, Y+6	; 0x06
    1c80:	89 81       	ldd	r24, Y+1	; 0x01
    1c82:	9a 81       	ldd	r25, Y+2	; 0x02
    1c84:	93 83       	std	Z+3, r25	; 0x03
    1c86:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1c88:	e9 81       	ldd	r30, Y+1	; 0x01
    1c8a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c8c:	84 81       	ldd	r24, Z+4	; 0x04
    1c8e:	95 81       	ldd	r25, Z+5	; 0x05
    1c90:	ed 81       	ldd	r30, Y+5	; 0x05
    1c92:	fe 81       	ldd	r31, Y+6	; 0x06
    1c94:	95 83       	std	Z+5, r25	; 0x05
    1c96:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1c98:	e9 81       	ldd	r30, Y+1	; 0x01
    1c9a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c9c:	04 80       	ldd	r0, Z+4	; 0x04
    1c9e:	f5 81       	ldd	r31, Z+5	; 0x05
    1ca0:	e0 2d       	mov	r30, r0
    1ca2:	8d 81       	ldd	r24, Y+5	; 0x05
    1ca4:	9e 81       	ldd	r25, Y+6	; 0x06
    1ca6:	93 83       	std	Z+3, r25	; 0x03
    1ca8:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1caa:	e9 81       	ldd	r30, Y+1	; 0x01
    1cac:	fa 81       	ldd	r31, Y+2	; 0x02
    1cae:	8d 81       	ldd	r24, Y+5	; 0x05
    1cb0:	9e 81       	ldd	r25, Y+6	; 0x06
    1cb2:	95 83       	std	Z+5, r25	; 0x05
    1cb4:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1cb6:	ed 81       	ldd	r30, Y+5	; 0x05
    1cb8:	fe 81       	ldd	r31, Y+6	; 0x06
    1cba:	8b 81       	ldd	r24, Y+3	; 0x03
    1cbc:	9c 81       	ldd	r25, Y+4	; 0x04
    1cbe:	91 87       	std	Z+9, r25	; 0x09
    1cc0:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1cc2:	eb 81       	ldd	r30, Y+3	; 0x03
    1cc4:	fc 81       	ldd	r31, Y+4	; 0x04
    1cc6:	80 81       	ld	r24, Z
    1cc8:	8f 5f       	subi	r24, 0xFF	; 255
    1cca:	eb 81       	ldd	r30, Y+3	; 0x03
    1ccc:	fc 81       	ldd	r31, Y+4	; 0x04
    1cce:	80 83       	st	Z, r24
}
    1cd0:	26 96       	adiw	r28, 0x06	; 6
    1cd2:	0f b6       	in	r0, 0x3f	; 63
    1cd4:	f8 94       	cli
    1cd6:	de bf       	out	0x3e, r29	; 62
    1cd8:	0f be       	out	0x3f, r0	; 63
    1cda:	cd bf       	out	0x3d, r28	; 61
    1cdc:	cf 91       	pop	r28
    1cde:	df 91       	pop	r29
    1ce0:	08 95       	ret

00001ce2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1ce2:	df 93       	push	r29
    1ce4:	cf 93       	push	r28
    1ce6:	cd b7       	in	r28, 0x3d	; 61
    1ce8:	de b7       	in	r29, 0x3e	; 62
    1cea:	28 97       	sbiw	r28, 0x08	; 8
    1cec:	0f b6       	in	r0, 0x3f	; 63
    1cee:	f8 94       	cli
    1cf0:	de bf       	out	0x3e, r29	; 62
    1cf2:	0f be       	out	0x3f, r0	; 63
    1cf4:	cd bf       	out	0x3d, r28	; 61
    1cf6:	9e 83       	std	Y+6, r25	; 0x06
    1cf8:	8d 83       	std	Y+5, r24	; 0x05
    1cfa:	78 87       	std	Y+8, r23	; 0x08
    1cfc:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1cfe:	ef 81       	ldd	r30, Y+7	; 0x07
    1d00:	f8 85       	ldd	r31, Y+8	; 0x08
    1d02:	80 81       	ld	r24, Z
    1d04:	91 81       	ldd	r25, Z+1	; 0x01
    1d06:	9a 83       	std	Y+2, r25	; 0x02
    1d08:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1d0a:	89 81       	ldd	r24, Y+1	; 0x01
    1d0c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d0e:	2f ef       	ldi	r18, 0xFF	; 255
    1d10:	8f 3f       	cpi	r24, 0xFF	; 255
    1d12:	92 07       	cpc	r25, r18
    1d14:	39 f4       	brne	.+14     	; 0x1d24 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1d16:	ed 81       	ldd	r30, Y+5	; 0x05
    1d18:	fe 81       	ldd	r31, Y+6	; 0x06
    1d1a:	87 81       	ldd	r24, Z+7	; 0x07
    1d1c:	90 85       	ldd	r25, Z+8	; 0x08
    1d1e:	9c 83       	std	Y+4, r25	; 0x04
    1d20:	8b 83       	std	Y+3, r24	; 0x03
    1d22:	18 c0       	rjmp	.+48     	; 0x1d54 <vListInsert+0x72>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1d24:	8d 81       	ldd	r24, Y+5	; 0x05
    1d26:	9e 81       	ldd	r25, Y+6	; 0x06
    1d28:	03 96       	adiw	r24, 0x03	; 3
    1d2a:	9c 83       	std	Y+4, r25	; 0x04
    1d2c:	8b 83       	std	Y+3, r24	; 0x03
    1d2e:	06 c0       	rjmp	.+12     	; 0x1d3c <vListInsert+0x5a>
    1d30:	eb 81       	ldd	r30, Y+3	; 0x03
    1d32:	fc 81       	ldd	r31, Y+4	; 0x04
    1d34:	82 81       	ldd	r24, Z+2	; 0x02
    1d36:	93 81       	ldd	r25, Z+3	; 0x03
    1d38:	9c 83       	std	Y+4, r25	; 0x04
    1d3a:	8b 83       	std	Y+3, r24	; 0x03
    1d3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d40:	02 80       	ldd	r0, Z+2	; 0x02
    1d42:	f3 81       	ldd	r31, Z+3	; 0x03
    1d44:	e0 2d       	mov	r30, r0
    1d46:	20 81       	ld	r18, Z
    1d48:	31 81       	ldd	r19, Z+1	; 0x01
    1d4a:	89 81       	ldd	r24, Y+1	; 0x01
    1d4c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d4e:	82 17       	cp	r24, r18
    1d50:	93 07       	cpc	r25, r19
    1d52:	70 f7       	brcc	.-36     	; 0x1d30 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1d54:	eb 81       	ldd	r30, Y+3	; 0x03
    1d56:	fc 81       	ldd	r31, Y+4	; 0x04
    1d58:	82 81       	ldd	r24, Z+2	; 0x02
    1d5a:	93 81       	ldd	r25, Z+3	; 0x03
    1d5c:	ef 81       	ldd	r30, Y+7	; 0x07
    1d5e:	f8 85       	ldd	r31, Y+8	; 0x08
    1d60:	93 83       	std	Z+3, r25	; 0x03
    1d62:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1d64:	ef 81       	ldd	r30, Y+7	; 0x07
    1d66:	f8 85       	ldd	r31, Y+8	; 0x08
    1d68:	02 80       	ldd	r0, Z+2	; 0x02
    1d6a:	f3 81       	ldd	r31, Z+3	; 0x03
    1d6c:	e0 2d       	mov	r30, r0
    1d6e:	8f 81       	ldd	r24, Y+7	; 0x07
    1d70:	98 85       	ldd	r25, Y+8	; 0x08
    1d72:	95 83       	std	Z+5, r25	; 0x05
    1d74:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1d76:	ef 81       	ldd	r30, Y+7	; 0x07
    1d78:	f8 85       	ldd	r31, Y+8	; 0x08
    1d7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d7e:	95 83       	std	Z+5, r25	; 0x05
    1d80:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1d82:	eb 81       	ldd	r30, Y+3	; 0x03
    1d84:	fc 81       	ldd	r31, Y+4	; 0x04
    1d86:	8f 81       	ldd	r24, Y+7	; 0x07
    1d88:	98 85       	ldd	r25, Y+8	; 0x08
    1d8a:	93 83       	std	Z+3, r25	; 0x03
    1d8c:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1d8e:	ef 81       	ldd	r30, Y+7	; 0x07
    1d90:	f8 85       	ldd	r31, Y+8	; 0x08
    1d92:	8d 81       	ldd	r24, Y+5	; 0x05
    1d94:	9e 81       	ldd	r25, Y+6	; 0x06
    1d96:	91 87       	std	Z+9, r25	; 0x09
    1d98:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1d9a:	ed 81       	ldd	r30, Y+5	; 0x05
    1d9c:	fe 81       	ldd	r31, Y+6	; 0x06
    1d9e:	80 81       	ld	r24, Z
    1da0:	8f 5f       	subi	r24, 0xFF	; 255
    1da2:	ed 81       	ldd	r30, Y+5	; 0x05
    1da4:	fe 81       	ldd	r31, Y+6	; 0x06
    1da6:	80 83       	st	Z, r24
}
    1da8:	28 96       	adiw	r28, 0x08	; 8
    1daa:	0f b6       	in	r0, 0x3f	; 63
    1dac:	f8 94       	cli
    1dae:	de bf       	out	0x3e, r29	; 62
    1db0:	0f be       	out	0x3f, r0	; 63
    1db2:	cd bf       	out	0x3d, r28	; 61
    1db4:	cf 91       	pop	r28
    1db6:	df 91       	pop	r29
    1db8:	08 95       	ret

00001dba <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1dba:	df 93       	push	r29
    1dbc:	cf 93       	push	r28
    1dbe:	00 d0       	rcall	.+0      	; 0x1dc0 <uxListRemove+0x6>
    1dc0:	00 d0       	rcall	.+0      	; 0x1dc2 <uxListRemove+0x8>
    1dc2:	cd b7       	in	r28, 0x3d	; 61
    1dc4:	de b7       	in	r29, 0x3e	; 62
    1dc6:	9c 83       	std	Y+4, r25	; 0x04
    1dc8:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1dca:	eb 81       	ldd	r30, Y+3	; 0x03
    1dcc:	fc 81       	ldd	r31, Y+4	; 0x04
    1dce:	80 85       	ldd	r24, Z+8	; 0x08
    1dd0:	91 85       	ldd	r25, Z+9	; 0x09
    1dd2:	9a 83       	std	Y+2, r25	; 0x02
    1dd4:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1dd6:	eb 81       	ldd	r30, Y+3	; 0x03
    1dd8:	fc 81       	ldd	r31, Y+4	; 0x04
    1dda:	a2 81       	ldd	r26, Z+2	; 0x02
    1ddc:	b3 81       	ldd	r27, Z+3	; 0x03
    1dde:	eb 81       	ldd	r30, Y+3	; 0x03
    1de0:	fc 81       	ldd	r31, Y+4	; 0x04
    1de2:	84 81       	ldd	r24, Z+4	; 0x04
    1de4:	95 81       	ldd	r25, Z+5	; 0x05
    1de6:	15 96       	adiw	r26, 0x05	; 5
    1de8:	9c 93       	st	X, r25
    1dea:	8e 93       	st	-X, r24
    1dec:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1dee:	eb 81       	ldd	r30, Y+3	; 0x03
    1df0:	fc 81       	ldd	r31, Y+4	; 0x04
    1df2:	a4 81       	ldd	r26, Z+4	; 0x04
    1df4:	b5 81       	ldd	r27, Z+5	; 0x05
    1df6:	eb 81       	ldd	r30, Y+3	; 0x03
    1df8:	fc 81       	ldd	r31, Y+4	; 0x04
    1dfa:	82 81       	ldd	r24, Z+2	; 0x02
    1dfc:	93 81       	ldd	r25, Z+3	; 0x03
    1dfe:	13 96       	adiw	r26, 0x03	; 3
    1e00:	9c 93       	st	X, r25
    1e02:	8e 93       	st	-X, r24
    1e04:	12 97       	sbiw	r26, 0x02	; 2

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1e06:	e9 81       	ldd	r30, Y+1	; 0x01
    1e08:	fa 81       	ldd	r31, Y+2	; 0x02
    1e0a:	21 81       	ldd	r18, Z+1	; 0x01
    1e0c:	32 81       	ldd	r19, Z+2	; 0x02
    1e0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e10:	9c 81       	ldd	r25, Y+4	; 0x04
    1e12:	28 17       	cp	r18, r24
    1e14:	39 07       	cpc	r19, r25
    1e16:	41 f4       	brne	.+16     	; 0x1e28 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1e18:	eb 81       	ldd	r30, Y+3	; 0x03
    1e1a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e1c:	84 81       	ldd	r24, Z+4	; 0x04
    1e1e:	95 81       	ldd	r25, Z+5	; 0x05
    1e20:	e9 81       	ldd	r30, Y+1	; 0x01
    1e22:	fa 81       	ldd	r31, Y+2	; 0x02
    1e24:	92 83       	std	Z+2, r25	; 0x02
    1e26:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1e28:	eb 81       	ldd	r30, Y+3	; 0x03
    1e2a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e2c:	11 86       	std	Z+9, r1	; 0x09
    1e2e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1e30:	e9 81       	ldd	r30, Y+1	; 0x01
    1e32:	fa 81       	ldd	r31, Y+2	; 0x02
    1e34:	80 81       	ld	r24, Z
    1e36:	81 50       	subi	r24, 0x01	; 1
    1e38:	e9 81       	ldd	r30, Y+1	; 0x01
    1e3a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e3c:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    1e3e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e40:	fa 81       	ldd	r31, Y+2	; 0x02
    1e42:	80 81       	ld	r24, Z
}
    1e44:	0f 90       	pop	r0
    1e46:	0f 90       	pop	r0
    1e48:	0f 90       	pop	r0
    1e4a:	0f 90       	pop	r0
    1e4c:	cf 91       	pop	r28
    1e4e:	df 91       	pop	r29
    1e50:	08 95       	ret

00001e52 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1e52:	df 93       	push	r29
    1e54:	cf 93       	push	r28
    1e56:	cd b7       	in	r28, 0x3d	; 61
    1e58:	de b7       	in	r29, 0x3e	; 62
    1e5a:	28 97       	sbiw	r28, 0x08	; 8
    1e5c:	0f b6       	in	r0, 0x3f	; 63
    1e5e:	f8 94       	cli
    1e60:	de bf       	out	0x3e, r29	; 62
    1e62:	0f be       	out	0x3f, r0	; 63
    1e64:	cd bf       	out	0x3d, r28	; 61
    1e66:	9c 83       	std	Y+4, r25	; 0x04
    1e68:	8b 83       	std	Y+3, r24	; 0x03
    1e6a:	7e 83       	std	Y+6, r23	; 0x06
    1e6c:	6d 83       	std	Y+5, r22	; 0x05
    1e6e:	58 87       	std	Y+8, r21	; 0x08
    1e70:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1e72:	eb 81       	ldd	r30, Y+3	; 0x03
    1e74:	fc 81       	ldd	r31, Y+4	; 0x04
    1e76:	81 e1       	ldi	r24, 0x11	; 17
    1e78:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e7e:	01 97       	sbiw	r24, 0x01	; 1
    1e80:	9c 83       	std	Y+4, r25	; 0x04
    1e82:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1e84:	eb 81       	ldd	r30, Y+3	; 0x03
    1e86:	fc 81       	ldd	r31, Y+4	; 0x04
    1e88:	82 e2       	ldi	r24, 0x22	; 34
    1e8a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e8c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e8e:	9c 81       	ldd	r25, Y+4	; 0x04
    1e90:	01 97       	sbiw	r24, 0x01	; 1
    1e92:	9c 83       	std	Y+4, r25	; 0x04
    1e94:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1e96:	eb 81       	ldd	r30, Y+3	; 0x03
    1e98:	fc 81       	ldd	r31, Y+4	; 0x04
    1e9a:	83 e3       	ldi	r24, 0x33	; 51
    1e9c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e9e:	8b 81       	ldd	r24, Y+3	; 0x03
    1ea0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ea2:	01 97       	sbiw	r24, 0x01	; 1
    1ea4:	9c 83       	std	Y+4, r25	; 0x04
    1ea6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1ea8:	8d 81       	ldd	r24, Y+5	; 0x05
    1eaa:	9e 81       	ldd	r25, Y+6	; 0x06
    1eac:	9a 83       	std	Y+2, r25	; 0x02
    1eae:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1eb0:	89 81       	ldd	r24, Y+1	; 0x01
    1eb2:	eb 81       	ldd	r30, Y+3	; 0x03
    1eb4:	fc 81       	ldd	r31, Y+4	; 0x04
    1eb6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1eb8:	8b 81       	ldd	r24, Y+3	; 0x03
    1eba:	9c 81       	ldd	r25, Y+4	; 0x04
    1ebc:	01 97       	sbiw	r24, 0x01	; 1
    1ebe:	9c 83       	std	Y+4, r25	; 0x04
    1ec0:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1ec2:	89 81       	ldd	r24, Y+1	; 0x01
    1ec4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ec6:	89 2f       	mov	r24, r25
    1ec8:	99 27       	eor	r25, r25
    1eca:	9a 83       	std	Y+2, r25	; 0x02
    1ecc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1ece:	89 81       	ldd	r24, Y+1	; 0x01
    1ed0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ed2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ed4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ed6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ed8:	9c 81       	ldd	r25, Y+4	; 0x04
    1eda:	01 97       	sbiw	r24, 0x01	; 1
    1edc:	9c 83       	std	Y+4, r25	; 0x04
    1ede:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1ee0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ee2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ee4:	10 82       	st	Z, r1
	pxTopOfStack--;
    1ee6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ee8:	9c 81       	ldd	r25, Y+4	; 0x04
    1eea:	01 97       	sbiw	r24, 0x01	; 1
    1eec:	9c 83       	std	Y+4, r25	; 0x04
    1eee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1ef0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ef2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ef4:	80 e8       	ldi	r24, 0x80	; 128
    1ef6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ef8:	8b 81       	ldd	r24, Y+3	; 0x03
    1efa:	9c 81       	ldd	r25, Y+4	; 0x04
    1efc:	01 97       	sbiw	r24, 0x01	; 1
    1efe:	9c 83       	std	Y+4, r25	; 0x04
    1f00:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1f02:	eb 81       	ldd	r30, Y+3	; 0x03
    1f04:	fc 81       	ldd	r31, Y+4	; 0x04
    1f06:	10 82       	st	Z, r1
	pxTopOfStack--;
    1f08:	8b 81       	ldd	r24, Y+3	; 0x03
    1f0a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f0c:	01 97       	sbiw	r24, 0x01	; 1
    1f0e:	9c 83       	std	Y+4, r25	; 0x04
    1f10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1f12:	eb 81       	ldd	r30, Y+3	; 0x03
    1f14:	fc 81       	ldd	r31, Y+4	; 0x04
    1f16:	82 e0       	ldi	r24, 0x02	; 2
    1f18:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f1a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f1c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f1e:	01 97       	sbiw	r24, 0x01	; 1
    1f20:	9c 83       	std	Y+4, r25	; 0x04
    1f22:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1f24:	eb 81       	ldd	r30, Y+3	; 0x03
    1f26:	fc 81       	ldd	r31, Y+4	; 0x04
    1f28:	83 e0       	ldi	r24, 0x03	; 3
    1f2a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f2c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f2e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f30:	01 97       	sbiw	r24, 0x01	; 1
    1f32:	9c 83       	std	Y+4, r25	; 0x04
    1f34:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1f36:	eb 81       	ldd	r30, Y+3	; 0x03
    1f38:	fc 81       	ldd	r31, Y+4	; 0x04
    1f3a:	84 e0       	ldi	r24, 0x04	; 4
    1f3c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f3e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f40:	9c 81       	ldd	r25, Y+4	; 0x04
    1f42:	01 97       	sbiw	r24, 0x01	; 1
    1f44:	9c 83       	std	Y+4, r25	; 0x04
    1f46:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1f48:	eb 81       	ldd	r30, Y+3	; 0x03
    1f4a:	fc 81       	ldd	r31, Y+4	; 0x04
    1f4c:	85 e0       	ldi	r24, 0x05	; 5
    1f4e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f50:	8b 81       	ldd	r24, Y+3	; 0x03
    1f52:	9c 81       	ldd	r25, Y+4	; 0x04
    1f54:	01 97       	sbiw	r24, 0x01	; 1
    1f56:	9c 83       	std	Y+4, r25	; 0x04
    1f58:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1f5a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f5c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f5e:	86 e0       	ldi	r24, 0x06	; 6
    1f60:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f62:	8b 81       	ldd	r24, Y+3	; 0x03
    1f64:	9c 81       	ldd	r25, Y+4	; 0x04
    1f66:	01 97       	sbiw	r24, 0x01	; 1
    1f68:	9c 83       	std	Y+4, r25	; 0x04
    1f6a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1f6c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f6e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f70:	87 e0       	ldi	r24, 0x07	; 7
    1f72:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f74:	8b 81       	ldd	r24, Y+3	; 0x03
    1f76:	9c 81       	ldd	r25, Y+4	; 0x04
    1f78:	01 97       	sbiw	r24, 0x01	; 1
    1f7a:	9c 83       	std	Y+4, r25	; 0x04
    1f7c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1f7e:	eb 81       	ldd	r30, Y+3	; 0x03
    1f80:	fc 81       	ldd	r31, Y+4	; 0x04
    1f82:	88 e0       	ldi	r24, 0x08	; 8
    1f84:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f86:	8b 81       	ldd	r24, Y+3	; 0x03
    1f88:	9c 81       	ldd	r25, Y+4	; 0x04
    1f8a:	01 97       	sbiw	r24, 0x01	; 1
    1f8c:	9c 83       	std	Y+4, r25	; 0x04
    1f8e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1f90:	eb 81       	ldd	r30, Y+3	; 0x03
    1f92:	fc 81       	ldd	r31, Y+4	; 0x04
    1f94:	89 e0       	ldi	r24, 0x09	; 9
    1f96:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f98:	8b 81       	ldd	r24, Y+3	; 0x03
    1f9a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f9c:	01 97       	sbiw	r24, 0x01	; 1
    1f9e:	9c 83       	std	Y+4, r25	; 0x04
    1fa0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1fa2:	eb 81       	ldd	r30, Y+3	; 0x03
    1fa4:	fc 81       	ldd	r31, Y+4	; 0x04
    1fa6:	80 e1       	ldi	r24, 0x10	; 16
    1fa8:	80 83       	st	Z, r24
	pxTopOfStack--;
    1faa:	8b 81       	ldd	r24, Y+3	; 0x03
    1fac:	9c 81       	ldd	r25, Y+4	; 0x04
    1fae:	01 97       	sbiw	r24, 0x01	; 1
    1fb0:	9c 83       	std	Y+4, r25	; 0x04
    1fb2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1fb4:	eb 81       	ldd	r30, Y+3	; 0x03
    1fb6:	fc 81       	ldd	r31, Y+4	; 0x04
    1fb8:	81 e1       	ldi	r24, 0x11	; 17
    1fba:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fbc:	8b 81       	ldd	r24, Y+3	; 0x03
    1fbe:	9c 81       	ldd	r25, Y+4	; 0x04
    1fc0:	01 97       	sbiw	r24, 0x01	; 1
    1fc2:	9c 83       	std	Y+4, r25	; 0x04
    1fc4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1fc6:	eb 81       	ldd	r30, Y+3	; 0x03
    1fc8:	fc 81       	ldd	r31, Y+4	; 0x04
    1fca:	82 e1       	ldi	r24, 0x12	; 18
    1fcc:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fce:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd0:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd2:	01 97       	sbiw	r24, 0x01	; 1
    1fd4:	9c 83       	std	Y+4, r25	; 0x04
    1fd6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1fd8:	eb 81       	ldd	r30, Y+3	; 0x03
    1fda:	fc 81       	ldd	r31, Y+4	; 0x04
    1fdc:	83 e1       	ldi	r24, 0x13	; 19
    1fde:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fe0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fe2:	9c 81       	ldd	r25, Y+4	; 0x04
    1fe4:	01 97       	sbiw	r24, 0x01	; 1
    1fe6:	9c 83       	std	Y+4, r25	; 0x04
    1fe8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1fea:	eb 81       	ldd	r30, Y+3	; 0x03
    1fec:	fc 81       	ldd	r31, Y+4	; 0x04
    1fee:	84 e1       	ldi	r24, 0x14	; 20
    1ff0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ff6:	01 97       	sbiw	r24, 0x01	; 1
    1ff8:	9c 83       	std	Y+4, r25	; 0x04
    1ffa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1ffc:	eb 81       	ldd	r30, Y+3	; 0x03
    1ffe:	fc 81       	ldd	r31, Y+4	; 0x04
    2000:	85 e1       	ldi	r24, 0x15	; 21
    2002:	80 83       	st	Z, r24
	pxTopOfStack--;
    2004:	8b 81       	ldd	r24, Y+3	; 0x03
    2006:	9c 81       	ldd	r25, Y+4	; 0x04
    2008:	01 97       	sbiw	r24, 0x01	; 1
    200a:	9c 83       	std	Y+4, r25	; 0x04
    200c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    200e:	eb 81       	ldd	r30, Y+3	; 0x03
    2010:	fc 81       	ldd	r31, Y+4	; 0x04
    2012:	86 e1       	ldi	r24, 0x16	; 22
    2014:	80 83       	st	Z, r24
	pxTopOfStack--;
    2016:	8b 81       	ldd	r24, Y+3	; 0x03
    2018:	9c 81       	ldd	r25, Y+4	; 0x04
    201a:	01 97       	sbiw	r24, 0x01	; 1
    201c:	9c 83       	std	Y+4, r25	; 0x04
    201e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2020:	eb 81       	ldd	r30, Y+3	; 0x03
    2022:	fc 81       	ldd	r31, Y+4	; 0x04
    2024:	87 e1       	ldi	r24, 0x17	; 23
    2026:	80 83       	st	Z, r24
	pxTopOfStack--;
    2028:	8b 81       	ldd	r24, Y+3	; 0x03
    202a:	9c 81       	ldd	r25, Y+4	; 0x04
    202c:	01 97       	sbiw	r24, 0x01	; 1
    202e:	9c 83       	std	Y+4, r25	; 0x04
    2030:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2032:	eb 81       	ldd	r30, Y+3	; 0x03
    2034:	fc 81       	ldd	r31, Y+4	; 0x04
    2036:	88 e1       	ldi	r24, 0x18	; 24
    2038:	80 83       	st	Z, r24
	pxTopOfStack--;
    203a:	8b 81       	ldd	r24, Y+3	; 0x03
    203c:	9c 81       	ldd	r25, Y+4	; 0x04
    203e:	01 97       	sbiw	r24, 0x01	; 1
    2040:	9c 83       	std	Y+4, r25	; 0x04
    2042:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2044:	eb 81       	ldd	r30, Y+3	; 0x03
    2046:	fc 81       	ldd	r31, Y+4	; 0x04
    2048:	89 e1       	ldi	r24, 0x19	; 25
    204a:	80 83       	st	Z, r24
	pxTopOfStack--;
    204c:	8b 81       	ldd	r24, Y+3	; 0x03
    204e:	9c 81       	ldd	r25, Y+4	; 0x04
    2050:	01 97       	sbiw	r24, 0x01	; 1
    2052:	9c 83       	std	Y+4, r25	; 0x04
    2054:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2056:	eb 81       	ldd	r30, Y+3	; 0x03
    2058:	fc 81       	ldd	r31, Y+4	; 0x04
    205a:	80 e2       	ldi	r24, 0x20	; 32
    205c:	80 83       	st	Z, r24
	pxTopOfStack--;
    205e:	8b 81       	ldd	r24, Y+3	; 0x03
    2060:	9c 81       	ldd	r25, Y+4	; 0x04
    2062:	01 97       	sbiw	r24, 0x01	; 1
    2064:	9c 83       	std	Y+4, r25	; 0x04
    2066:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2068:	eb 81       	ldd	r30, Y+3	; 0x03
    206a:	fc 81       	ldd	r31, Y+4	; 0x04
    206c:	81 e2       	ldi	r24, 0x21	; 33
    206e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2070:	8b 81       	ldd	r24, Y+3	; 0x03
    2072:	9c 81       	ldd	r25, Y+4	; 0x04
    2074:	01 97       	sbiw	r24, 0x01	; 1
    2076:	9c 83       	std	Y+4, r25	; 0x04
    2078:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    207a:	eb 81       	ldd	r30, Y+3	; 0x03
    207c:	fc 81       	ldd	r31, Y+4	; 0x04
    207e:	82 e2       	ldi	r24, 0x22	; 34
    2080:	80 83       	st	Z, r24
	pxTopOfStack--;
    2082:	8b 81       	ldd	r24, Y+3	; 0x03
    2084:	9c 81       	ldd	r25, Y+4	; 0x04
    2086:	01 97       	sbiw	r24, 0x01	; 1
    2088:	9c 83       	std	Y+4, r25	; 0x04
    208a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    208c:	eb 81       	ldd	r30, Y+3	; 0x03
    208e:	fc 81       	ldd	r31, Y+4	; 0x04
    2090:	83 e2       	ldi	r24, 0x23	; 35
    2092:	80 83       	st	Z, r24
	pxTopOfStack--;
    2094:	8b 81       	ldd	r24, Y+3	; 0x03
    2096:	9c 81       	ldd	r25, Y+4	; 0x04
    2098:	01 97       	sbiw	r24, 0x01	; 1
    209a:	9c 83       	std	Y+4, r25	; 0x04
    209c:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    209e:	8f 81       	ldd	r24, Y+7	; 0x07
    20a0:	98 85       	ldd	r25, Y+8	; 0x08
    20a2:	9a 83       	std	Y+2, r25	; 0x02
    20a4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20a6:	89 81       	ldd	r24, Y+1	; 0x01
    20a8:	eb 81       	ldd	r30, Y+3	; 0x03
    20aa:	fc 81       	ldd	r31, Y+4	; 0x04
    20ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    20ae:	8b 81       	ldd	r24, Y+3	; 0x03
    20b0:	9c 81       	ldd	r25, Y+4	; 0x04
    20b2:	01 97       	sbiw	r24, 0x01	; 1
    20b4:	9c 83       	std	Y+4, r25	; 0x04
    20b6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    20b8:	89 81       	ldd	r24, Y+1	; 0x01
    20ba:	9a 81       	ldd	r25, Y+2	; 0x02
    20bc:	89 2f       	mov	r24, r25
    20be:	99 27       	eor	r25, r25
    20c0:	9a 83       	std	Y+2, r25	; 0x02
    20c2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20c4:	89 81       	ldd	r24, Y+1	; 0x01
    20c6:	eb 81       	ldd	r30, Y+3	; 0x03
    20c8:	fc 81       	ldd	r31, Y+4	; 0x04
    20ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    20cc:	8b 81       	ldd	r24, Y+3	; 0x03
    20ce:	9c 81       	ldd	r25, Y+4	; 0x04
    20d0:	01 97       	sbiw	r24, 0x01	; 1
    20d2:	9c 83       	std	Y+4, r25	; 0x04
    20d4:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    20d6:	eb 81       	ldd	r30, Y+3	; 0x03
    20d8:	fc 81       	ldd	r31, Y+4	; 0x04
    20da:	86 e2       	ldi	r24, 0x26	; 38
    20dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    20de:	8b 81       	ldd	r24, Y+3	; 0x03
    20e0:	9c 81       	ldd	r25, Y+4	; 0x04
    20e2:	01 97       	sbiw	r24, 0x01	; 1
    20e4:	9c 83       	std	Y+4, r25	; 0x04
    20e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    20e8:	eb 81       	ldd	r30, Y+3	; 0x03
    20ea:	fc 81       	ldd	r31, Y+4	; 0x04
    20ec:	87 e2       	ldi	r24, 0x27	; 39
    20ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    20f0:	8b 81       	ldd	r24, Y+3	; 0x03
    20f2:	9c 81       	ldd	r25, Y+4	; 0x04
    20f4:	01 97       	sbiw	r24, 0x01	; 1
    20f6:	9c 83       	std	Y+4, r25	; 0x04
    20f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    20fa:	eb 81       	ldd	r30, Y+3	; 0x03
    20fc:	fc 81       	ldd	r31, Y+4	; 0x04
    20fe:	88 e2       	ldi	r24, 0x28	; 40
    2100:	80 83       	st	Z, r24
	pxTopOfStack--;
    2102:	8b 81       	ldd	r24, Y+3	; 0x03
    2104:	9c 81       	ldd	r25, Y+4	; 0x04
    2106:	01 97       	sbiw	r24, 0x01	; 1
    2108:	9c 83       	std	Y+4, r25	; 0x04
    210a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    210c:	eb 81       	ldd	r30, Y+3	; 0x03
    210e:	fc 81       	ldd	r31, Y+4	; 0x04
    2110:	89 e2       	ldi	r24, 0x29	; 41
    2112:	80 83       	st	Z, r24
	pxTopOfStack--;
    2114:	8b 81       	ldd	r24, Y+3	; 0x03
    2116:	9c 81       	ldd	r25, Y+4	; 0x04
    2118:	01 97       	sbiw	r24, 0x01	; 1
    211a:	9c 83       	std	Y+4, r25	; 0x04
    211c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    211e:	eb 81       	ldd	r30, Y+3	; 0x03
    2120:	fc 81       	ldd	r31, Y+4	; 0x04
    2122:	80 e3       	ldi	r24, 0x30	; 48
    2124:	80 83       	st	Z, r24
	pxTopOfStack--;
    2126:	8b 81       	ldd	r24, Y+3	; 0x03
    2128:	9c 81       	ldd	r25, Y+4	; 0x04
    212a:	01 97       	sbiw	r24, 0x01	; 1
    212c:	9c 83       	std	Y+4, r25	; 0x04
    212e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2130:	eb 81       	ldd	r30, Y+3	; 0x03
    2132:	fc 81       	ldd	r31, Y+4	; 0x04
    2134:	81 e3       	ldi	r24, 0x31	; 49
    2136:	80 83       	st	Z, r24
	pxTopOfStack--;
    2138:	8b 81       	ldd	r24, Y+3	; 0x03
    213a:	9c 81       	ldd	r25, Y+4	; 0x04
    213c:	01 97       	sbiw	r24, 0x01	; 1
    213e:	9c 83       	std	Y+4, r25	; 0x04
    2140:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2142:	8b 81       	ldd	r24, Y+3	; 0x03
    2144:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2146:	28 96       	adiw	r28, 0x08	; 8
    2148:	0f b6       	in	r0, 0x3f	; 63
    214a:	f8 94       	cli
    214c:	de bf       	out	0x3e, r29	; 62
    214e:	0f be       	out	0x3f, r0	; 63
    2150:	cd bf       	out	0x3d, r28	; 61
    2152:	cf 91       	pop	r28
    2154:	df 91       	pop	r29
    2156:	08 95       	ret

00002158 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    2158:	df 93       	push	r29
    215a:	cf 93       	push	r28
    215c:	cd b7       	in	r28, 0x3d	; 61
    215e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2160:	0e 94 9e 11 	call	0x233c	; 0x233c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2164:	a0 91 9f 07 	lds	r26, 0x079F
    2168:	b0 91 a0 07 	lds	r27, 0x07A0
    216c:	cd 91       	ld	r28, X+
    216e:	cd bf       	out	0x3d, r28	; 61
    2170:	dd 91       	ld	r29, X+
    2172:	de bf       	out	0x3e, r29	; 62
    2174:	ff 91       	pop	r31
    2176:	ef 91       	pop	r30
    2178:	df 91       	pop	r29
    217a:	cf 91       	pop	r28
    217c:	bf 91       	pop	r27
    217e:	af 91       	pop	r26
    2180:	9f 91       	pop	r25
    2182:	8f 91       	pop	r24
    2184:	7f 91       	pop	r23
    2186:	6f 91       	pop	r22
    2188:	5f 91       	pop	r21
    218a:	4f 91       	pop	r20
    218c:	3f 91       	pop	r19
    218e:	2f 91       	pop	r18
    2190:	1f 91       	pop	r17
    2192:	0f 91       	pop	r16
    2194:	ff 90       	pop	r15
    2196:	ef 90       	pop	r14
    2198:	df 90       	pop	r13
    219a:	cf 90       	pop	r12
    219c:	bf 90       	pop	r11
    219e:	af 90       	pop	r10
    21a0:	9f 90       	pop	r9
    21a2:	8f 90       	pop	r8
    21a4:	7f 90       	pop	r7
    21a6:	6f 90       	pop	r6
    21a8:	5f 90       	pop	r5
    21aa:	4f 90       	pop	r4
    21ac:	3f 90       	pop	r3
    21ae:	2f 90       	pop	r2
    21b0:	1f 90       	pop	r1
    21b2:	0f 90       	pop	r0
    21b4:	0f be       	out	0x3f, r0	; 63
    21b6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    21b8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    21ba:	81 e0       	ldi	r24, 0x01	; 1
}
    21bc:	cf 91       	pop	r28
    21be:	df 91       	pop	r29
    21c0:	08 95       	ret

000021c2 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    21c2:	df 93       	push	r29
    21c4:	cf 93       	push	r28
    21c6:	cd b7       	in	r28, 0x3d	; 61
    21c8:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    21ca:	cf 91       	pop	r28
    21cc:	df 91       	pop	r29
    21ce:	08 95       	ret

000021d0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    21d0:	0f 92       	push	r0
    21d2:	0f b6       	in	r0, 0x3f	; 63
    21d4:	f8 94       	cli
    21d6:	0f 92       	push	r0
    21d8:	1f 92       	push	r1
    21da:	11 24       	eor	r1, r1
    21dc:	2f 92       	push	r2
    21de:	3f 92       	push	r3
    21e0:	4f 92       	push	r4
    21e2:	5f 92       	push	r5
    21e4:	6f 92       	push	r6
    21e6:	7f 92       	push	r7
    21e8:	8f 92       	push	r8
    21ea:	9f 92       	push	r9
    21ec:	af 92       	push	r10
    21ee:	bf 92       	push	r11
    21f0:	cf 92       	push	r12
    21f2:	df 92       	push	r13
    21f4:	ef 92       	push	r14
    21f6:	ff 92       	push	r15
    21f8:	0f 93       	push	r16
    21fa:	1f 93       	push	r17
    21fc:	2f 93       	push	r18
    21fe:	3f 93       	push	r19
    2200:	4f 93       	push	r20
    2202:	5f 93       	push	r21
    2204:	6f 93       	push	r22
    2206:	7f 93       	push	r23
    2208:	8f 93       	push	r24
    220a:	9f 93       	push	r25
    220c:	af 93       	push	r26
    220e:	bf 93       	push	r27
    2210:	cf 93       	push	r28
    2212:	df 93       	push	r29
    2214:	ef 93       	push	r30
    2216:	ff 93       	push	r31
    2218:	a0 91 9f 07 	lds	r26, 0x079F
    221c:	b0 91 a0 07 	lds	r27, 0x07A0
    2220:	0d b6       	in	r0, 0x3d	; 61
    2222:	0d 92       	st	X+, r0
    2224:	0e b6       	in	r0, 0x3e	; 62
    2226:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2228:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    222c:	a0 91 9f 07 	lds	r26, 0x079F
    2230:	b0 91 a0 07 	lds	r27, 0x07A0
    2234:	cd 91       	ld	r28, X+
    2236:	cd bf       	out	0x3d, r28	; 61
    2238:	dd 91       	ld	r29, X+
    223a:	de bf       	out	0x3e, r29	; 62
    223c:	ff 91       	pop	r31
    223e:	ef 91       	pop	r30
    2240:	df 91       	pop	r29
    2242:	cf 91       	pop	r28
    2244:	bf 91       	pop	r27
    2246:	af 91       	pop	r26
    2248:	9f 91       	pop	r25
    224a:	8f 91       	pop	r24
    224c:	7f 91       	pop	r23
    224e:	6f 91       	pop	r22
    2250:	5f 91       	pop	r21
    2252:	4f 91       	pop	r20
    2254:	3f 91       	pop	r19
    2256:	2f 91       	pop	r18
    2258:	1f 91       	pop	r17
    225a:	0f 91       	pop	r16
    225c:	ff 90       	pop	r15
    225e:	ef 90       	pop	r14
    2260:	df 90       	pop	r13
    2262:	cf 90       	pop	r12
    2264:	bf 90       	pop	r11
    2266:	af 90       	pop	r10
    2268:	9f 90       	pop	r9
    226a:	8f 90       	pop	r8
    226c:	7f 90       	pop	r7
    226e:	6f 90       	pop	r6
    2270:	5f 90       	pop	r5
    2272:	4f 90       	pop	r4
    2274:	3f 90       	pop	r3
    2276:	2f 90       	pop	r2
    2278:	1f 90       	pop	r1
    227a:	0f 90       	pop	r0
    227c:	0f be       	out	0x3f, r0	; 63
    227e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2280:	08 95       	ret

00002282 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2282:	0f 92       	push	r0
    2284:	0f b6       	in	r0, 0x3f	; 63
    2286:	f8 94       	cli
    2288:	0f 92       	push	r0
    228a:	1f 92       	push	r1
    228c:	11 24       	eor	r1, r1
    228e:	2f 92       	push	r2
    2290:	3f 92       	push	r3
    2292:	4f 92       	push	r4
    2294:	5f 92       	push	r5
    2296:	6f 92       	push	r6
    2298:	7f 92       	push	r7
    229a:	8f 92       	push	r8
    229c:	9f 92       	push	r9
    229e:	af 92       	push	r10
    22a0:	bf 92       	push	r11
    22a2:	cf 92       	push	r12
    22a4:	df 92       	push	r13
    22a6:	ef 92       	push	r14
    22a8:	ff 92       	push	r15
    22aa:	0f 93       	push	r16
    22ac:	1f 93       	push	r17
    22ae:	2f 93       	push	r18
    22b0:	3f 93       	push	r19
    22b2:	4f 93       	push	r20
    22b4:	5f 93       	push	r21
    22b6:	6f 93       	push	r22
    22b8:	7f 93       	push	r23
    22ba:	8f 93       	push	r24
    22bc:	9f 93       	push	r25
    22be:	af 93       	push	r26
    22c0:	bf 93       	push	r27
    22c2:	cf 93       	push	r28
    22c4:	df 93       	push	r29
    22c6:	ef 93       	push	r30
    22c8:	ff 93       	push	r31
    22ca:	a0 91 9f 07 	lds	r26, 0x079F
    22ce:	b0 91 a0 07 	lds	r27, 0x07A0
    22d2:	0d b6       	in	r0, 0x3d	; 61
    22d4:	0d 92       	st	X+, r0
    22d6:	0e b6       	in	r0, 0x3e	; 62
    22d8:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    22da:	0e 94 29 1c 	call	0x3852	; 0x3852 <xTaskIncrementTick>
    22de:	88 23       	and	r24, r24
    22e0:	11 f0       	breq	.+4      	; 0x22e6 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    22e2:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    22e6:	a0 91 9f 07 	lds	r26, 0x079F
    22ea:	b0 91 a0 07 	lds	r27, 0x07A0
    22ee:	cd 91       	ld	r28, X+
    22f0:	cd bf       	out	0x3d, r28	; 61
    22f2:	dd 91       	ld	r29, X+
    22f4:	de bf       	out	0x3e, r29	; 62
    22f6:	ff 91       	pop	r31
    22f8:	ef 91       	pop	r30
    22fa:	df 91       	pop	r29
    22fc:	cf 91       	pop	r28
    22fe:	bf 91       	pop	r27
    2300:	af 91       	pop	r26
    2302:	9f 91       	pop	r25
    2304:	8f 91       	pop	r24
    2306:	7f 91       	pop	r23
    2308:	6f 91       	pop	r22
    230a:	5f 91       	pop	r21
    230c:	4f 91       	pop	r20
    230e:	3f 91       	pop	r19
    2310:	2f 91       	pop	r18
    2312:	1f 91       	pop	r17
    2314:	0f 91       	pop	r16
    2316:	ff 90       	pop	r15
    2318:	ef 90       	pop	r14
    231a:	df 90       	pop	r13
    231c:	cf 90       	pop	r12
    231e:	bf 90       	pop	r11
    2320:	af 90       	pop	r10
    2322:	9f 90       	pop	r9
    2324:	8f 90       	pop	r8
    2326:	7f 90       	pop	r7
    2328:	6f 90       	pop	r6
    232a:	5f 90       	pop	r5
    232c:	4f 90       	pop	r4
    232e:	3f 90       	pop	r3
    2330:	2f 90       	pop	r2
    2332:	1f 90       	pop	r1
    2334:	0f 90       	pop	r0
    2336:	0f be       	out	0x3f, r0	; 63
    2338:	0f 90       	pop	r0

	asm volatile ( "ret" );
    233a:	08 95       	ret

0000233c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    233c:	df 93       	push	r29
    233e:	cf 93       	push	r28
    2340:	00 d0       	rcall	.+0      	; 0x2342 <prvSetupTimerInterrupt+0x6>
    2342:	00 d0       	rcall	.+0      	; 0x2344 <prvSetupTimerInterrupt+0x8>
    2344:	00 d0       	rcall	.+0      	; 0x2346 <prvSetupTimerInterrupt+0xa>
    2346:	cd b7       	in	r28, 0x3d	; 61
    2348:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    234a:	80 e4       	ldi	r24, 0x40	; 64
    234c:	9f e1       	ldi	r25, 0x1F	; 31
    234e:	a0 e0       	ldi	r26, 0x00	; 0
    2350:	b0 e0       	ldi	r27, 0x00	; 0
    2352:	8b 83       	std	Y+3, r24	; 0x03
    2354:	9c 83       	std	Y+4, r25	; 0x04
    2356:	ad 83       	std	Y+5, r26	; 0x05
    2358:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    235a:	8b 81       	ldd	r24, Y+3	; 0x03
    235c:	9c 81       	ldd	r25, Y+4	; 0x04
    235e:	ad 81       	ldd	r26, Y+5	; 0x05
    2360:	be 81       	ldd	r27, Y+6	; 0x06
    2362:	68 94       	set
    2364:	15 f8       	bld	r1, 5
    2366:	b6 95       	lsr	r27
    2368:	a7 95       	ror	r26
    236a:	97 95       	ror	r25
    236c:	87 95       	ror	r24
    236e:	16 94       	lsr	r1
    2370:	d1 f7       	brne	.-12     	; 0x2366 <prvSetupTimerInterrupt+0x2a>
    2372:	8b 83       	std	Y+3, r24	; 0x03
    2374:	9c 83       	std	Y+4, r25	; 0x04
    2376:	ad 83       	std	Y+5, r26	; 0x05
    2378:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    237a:	8b 81       	ldd	r24, Y+3	; 0x03
    237c:	9c 81       	ldd	r25, Y+4	; 0x04
    237e:	ad 81       	ldd	r26, Y+5	; 0x05
    2380:	be 81       	ldd	r27, Y+6	; 0x06
    2382:	01 97       	sbiw	r24, 0x01	; 1
    2384:	a1 09       	sbc	r26, r1
    2386:	b1 09       	sbc	r27, r1
    2388:	8b 83       	std	Y+3, r24	; 0x03
    238a:	9c 83       	std	Y+4, r25	; 0x04
    238c:	ad 83       	std	Y+5, r26	; 0x05
    238e:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2390:	8b 81       	ldd	r24, Y+3	; 0x03
    2392:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    2394:	8b 81       	ldd	r24, Y+3	; 0x03
    2396:	9c 81       	ldd	r25, Y+4	; 0x04
    2398:	ad 81       	ldd	r26, Y+5	; 0x05
    239a:	be 81       	ldd	r27, Y+6	; 0x06
    239c:	89 2f       	mov	r24, r25
    239e:	9a 2f       	mov	r25, r26
    23a0:	ab 2f       	mov	r26, r27
    23a2:	bb 27       	eor	r27, r27
    23a4:	8b 83       	std	Y+3, r24	; 0x03
    23a6:	9c 83       	std	Y+4, r25	; 0x04
    23a8:	ad 83       	std	Y+5, r26	; 0x05
    23aa:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    23ac:	8b 81       	ldd	r24, Y+3	; 0x03
    23ae:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    23b0:	eb e4       	ldi	r30, 0x4B	; 75
    23b2:	f0 e0       	ldi	r31, 0x00	; 0
    23b4:	8a 81       	ldd	r24, Y+2	; 0x02
    23b6:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    23b8:	ea e4       	ldi	r30, 0x4A	; 74
    23ba:	f0 e0       	ldi	r31, 0x00	; 0
    23bc:	89 81       	ldd	r24, Y+1	; 0x01
    23be:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    23c0:	8b e0       	ldi	r24, 0x0B	; 11
    23c2:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    23c4:	ee e4       	ldi	r30, 0x4E	; 78
    23c6:	f0 e0       	ldi	r31, 0x00	; 0
    23c8:	89 81       	ldd	r24, Y+1	; 0x01
    23ca:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    23cc:	e9 e5       	ldi	r30, 0x59	; 89
    23ce:	f0 e0       	ldi	r31, 0x00	; 0
    23d0:	80 81       	ld	r24, Z
    23d2:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    23d4:	89 81       	ldd	r24, Y+1	; 0x01
    23d6:	80 61       	ori	r24, 0x10	; 16
    23d8:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    23da:	e9 e5       	ldi	r30, 0x59	; 89
    23dc:	f0 e0       	ldi	r31, 0x00	; 0
    23de:	89 81       	ldd	r24, Y+1	; 0x01
    23e0:	80 83       	st	Z, r24
}
    23e2:	26 96       	adiw	r28, 0x06	; 6
    23e4:	0f b6       	in	r0, 0x3f	; 63
    23e6:	f8 94       	cli
    23e8:	de bf       	out	0x3e, r29	; 62
    23ea:	0f be       	out	0x3f, r0	; 63
    23ec:	cd bf       	out	0x3d, r28	; 61
    23ee:	cf 91       	pop	r28
    23f0:	df 91       	pop	r29
    23f2:	08 95       	ret

000023f4 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    23f4:	0e 94 41 11 	call	0x2282	; 0x2282 <vPortYieldFromTick>
		asm volatile ( "reti" );
    23f8:	18 95       	reti

000023fa <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    23fa:	df 93       	push	r29
    23fc:	cf 93       	push	r28
    23fe:	00 d0       	rcall	.+0      	; 0x2400 <xQueueGenericReset+0x6>
    2400:	00 d0       	rcall	.+0      	; 0x2402 <xQueueGenericReset+0x8>
    2402:	0f 92       	push	r0
    2404:	cd b7       	in	r28, 0x3d	; 61
    2406:	de b7       	in	r29, 0x3e	; 62
    2408:	9c 83       	std	Y+4, r25	; 0x04
    240a:	8b 83       	std	Y+3, r24	; 0x03
    240c:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    240e:	8b 81       	ldd	r24, Y+3	; 0x03
    2410:	9c 81       	ldd	r25, Y+4	; 0x04
    2412:	9a 83       	std	Y+2, r25	; 0x02
    2414:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2416:	0f b6       	in	r0, 0x3f	; 63
    2418:	f8 94       	cli
    241a:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    241c:	e9 81       	ldd	r30, Y+1	; 0x01
    241e:	fa 81       	ldd	r31, Y+2	; 0x02
    2420:	40 81       	ld	r20, Z
    2422:	51 81       	ldd	r21, Z+1	; 0x01
    2424:	e9 81       	ldd	r30, Y+1	; 0x01
    2426:	fa 81       	ldd	r31, Y+2	; 0x02
    2428:	83 8d       	ldd	r24, Z+27	; 0x1b
    242a:	28 2f       	mov	r18, r24
    242c:	30 e0       	ldi	r19, 0x00	; 0
    242e:	e9 81       	ldd	r30, Y+1	; 0x01
    2430:	fa 81       	ldd	r31, Y+2	; 0x02
    2432:	84 8d       	ldd	r24, Z+28	; 0x1c
    2434:	88 2f       	mov	r24, r24
    2436:	90 e0       	ldi	r25, 0x00	; 0
    2438:	bc 01       	movw	r22, r24
    243a:	26 9f       	mul	r18, r22
    243c:	c0 01       	movw	r24, r0
    243e:	27 9f       	mul	r18, r23
    2440:	90 0d       	add	r25, r0
    2442:	36 9f       	mul	r19, r22
    2444:	90 0d       	add	r25, r0
    2446:	11 24       	eor	r1, r1
    2448:	84 0f       	add	r24, r20
    244a:	95 1f       	adc	r25, r21
    244c:	e9 81       	ldd	r30, Y+1	; 0x01
    244e:	fa 81       	ldd	r31, Y+2	; 0x02
    2450:	93 83       	std	Z+3, r25	; 0x03
    2452:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2454:	e9 81       	ldd	r30, Y+1	; 0x01
    2456:	fa 81       	ldd	r31, Y+2	; 0x02
    2458:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    245a:	e9 81       	ldd	r30, Y+1	; 0x01
    245c:	fa 81       	ldd	r31, Y+2	; 0x02
    245e:	80 81       	ld	r24, Z
    2460:	91 81       	ldd	r25, Z+1	; 0x01
    2462:	e9 81       	ldd	r30, Y+1	; 0x01
    2464:	fa 81       	ldd	r31, Y+2	; 0x02
    2466:	95 83       	std	Z+5, r25	; 0x05
    2468:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    246a:	e9 81       	ldd	r30, Y+1	; 0x01
    246c:	fa 81       	ldd	r31, Y+2	; 0x02
    246e:	40 81       	ld	r20, Z
    2470:	51 81       	ldd	r21, Z+1	; 0x01
    2472:	e9 81       	ldd	r30, Y+1	; 0x01
    2474:	fa 81       	ldd	r31, Y+2	; 0x02
    2476:	83 8d       	ldd	r24, Z+27	; 0x1b
    2478:	88 2f       	mov	r24, r24
    247a:	90 e0       	ldi	r25, 0x00	; 0
    247c:	9c 01       	movw	r18, r24
    247e:	21 50       	subi	r18, 0x01	; 1
    2480:	30 40       	sbci	r19, 0x00	; 0
    2482:	e9 81       	ldd	r30, Y+1	; 0x01
    2484:	fa 81       	ldd	r31, Y+2	; 0x02
    2486:	84 8d       	ldd	r24, Z+28	; 0x1c
    2488:	88 2f       	mov	r24, r24
    248a:	90 e0       	ldi	r25, 0x00	; 0
    248c:	bc 01       	movw	r22, r24
    248e:	26 9f       	mul	r18, r22
    2490:	c0 01       	movw	r24, r0
    2492:	27 9f       	mul	r18, r23
    2494:	90 0d       	add	r25, r0
    2496:	36 9f       	mul	r19, r22
    2498:	90 0d       	add	r25, r0
    249a:	11 24       	eor	r1, r1
    249c:	84 0f       	add	r24, r20
    249e:	95 1f       	adc	r25, r21
    24a0:	e9 81       	ldd	r30, Y+1	; 0x01
    24a2:	fa 81       	ldd	r31, Y+2	; 0x02
    24a4:	97 83       	std	Z+7, r25	; 0x07
    24a6:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    24a8:	e9 81       	ldd	r30, Y+1	; 0x01
    24aa:	fa 81       	ldd	r31, Y+2	; 0x02
    24ac:	8f ef       	ldi	r24, 0xFF	; 255
    24ae:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    24b0:	e9 81       	ldd	r30, Y+1	; 0x01
    24b2:	fa 81       	ldd	r31, Y+2	; 0x02
    24b4:	8f ef       	ldi	r24, 0xFF	; 255
    24b6:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    24b8:	8d 81       	ldd	r24, Y+5	; 0x05
    24ba:	88 23       	and	r24, r24
    24bc:	79 f4       	brne	.+30     	; 0x24dc <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24be:	e9 81       	ldd	r30, Y+1	; 0x01
    24c0:	fa 81       	ldd	r31, Y+2	; 0x02
    24c2:	80 85       	ldd	r24, Z+8	; 0x08
    24c4:	88 23       	and	r24, r24
    24c6:	a1 f0       	breq	.+40     	; 0x24f0 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    24c8:	89 81       	ldd	r24, Y+1	; 0x01
    24ca:	9a 81       	ldd	r25, Y+2	; 0x02
    24cc:	08 96       	adiw	r24, 0x08	; 8
    24ce:	0e 94 f1 1d 	call	0x3be2	; 0x3be2 <xTaskRemoveFromEventList>
    24d2:	81 30       	cpi	r24, 0x01	; 1
    24d4:	69 f4       	brne	.+26     	; 0x24f0 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    24d6:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vPortYield>
    24da:	0a c0       	rjmp	.+20     	; 0x24f0 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    24dc:	89 81       	ldd	r24, Y+1	; 0x01
    24de:	9a 81       	ldd	r25, Y+2	; 0x02
    24e0:	08 96       	adiw	r24, 0x08	; 8
    24e2:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    24e6:	89 81       	ldd	r24, Y+1	; 0x01
    24e8:	9a 81       	ldd	r25, Y+2	; 0x02
    24ea:	41 96       	adiw	r24, 0x11	; 17
    24ec:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    24f0:	0f 90       	pop	r0
    24f2:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    24f4:	81 e0       	ldi	r24, 0x01	; 1
}
    24f6:	0f 90       	pop	r0
    24f8:	0f 90       	pop	r0
    24fa:	0f 90       	pop	r0
    24fc:	0f 90       	pop	r0
    24fe:	0f 90       	pop	r0
    2500:	cf 91       	pop	r28
    2502:	df 91       	pop	r29
    2504:	08 95       	ret

00002506 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    2506:	df 93       	push	r29
    2508:	cf 93       	push	r28
    250a:	cd b7       	in	r28, 0x3d	; 61
    250c:	de b7       	in	r29, 0x3e	; 62
    250e:	29 97       	sbiw	r28, 0x09	; 9
    2510:	0f b6       	in	r0, 0x3f	; 63
    2512:	f8 94       	cli
    2514:	de bf       	out	0x3e, r29	; 62
    2516:	0f be       	out	0x3f, r0	; 63
    2518:	cd bf       	out	0x3d, r28	; 61
    251a:	8f 83       	std	Y+7, r24	; 0x07
    251c:	68 87       	std	Y+8, r22	; 0x08
    251e:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    2520:	1a 82       	std	Y+2, r1	; 0x02
    2522:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    2524:	8f 81       	ldd	r24, Y+7	; 0x07
    2526:	88 23       	and	r24, r24
    2528:	09 f4       	brne	.+2      	; 0x252c <xQueueGenericCreate+0x26>
    252a:	3f c0       	rjmp	.+126    	; 0x25aa <xQueueGenericCreate+0xa4>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    252c:	8f e1       	ldi	r24, 0x1F	; 31
    252e:	90 e0       	ldi	r25, 0x00	; 0
    2530:	0e 94 a5 0c 	call	0x194a	; 0x194a <pvPortMalloc>
    2534:	9e 83       	std	Y+6, r25	; 0x06
    2536:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    2538:	8d 81       	ldd	r24, Y+5	; 0x05
    253a:	9e 81       	ldd	r25, Y+6	; 0x06
    253c:	00 97       	sbiw	r24, 0x00	; 0
    253e:	a9 f1       	breq	.+106    	; 0x25aa <xQueueGenericCreate+0xa4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2540:	8f 81       	ldd	r24, Y+7	; 0x07
    2542:	28 2f       	mov	r18, r24
    2544:	30 e0       	ldi	r19, 0x00	; 0
    2546:	88 85       	ldd	r24, Y+8	; 0x08
    2548:	88 2f       	mov	r24, r24
    254a:	90 e0       	ldi	r25, 0x00	; 0
    254c:	ac 01       	movw	r20, r24
    254e:	24 9f       	mul	r18, r20
    2550:	c0 01       	movw	r24, r0
    2552:	25 9f       	mul	r18, r21
    2554:	90 0d       	add	r25, r0
    2556:	34 9f       	mul	r19, r20
    2558:	90 0d       	add	r25, r0
    255a:	11 24       	eor	r1, r1
    255c:	01 96       	adiw	r24, 0x01	; 1
    255e:	9c 83       	std	Y+4, r25	; 0x04
    2560:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    2562:	8b 81       	ldd	r24, Y+3	; 0x03
    2564:	9c 81       	ldd	r25, Y+4	; 0x04
    2566:	0e 94 a5 0c 	call	0x194a	; 0x194a <pvPortMalloc>
    256a:	ed 81       	ldd	r30, Y+5	; 0x05
    256c:	fe 81       	ldd	r31, Y+6	; 0x06
    256e:	91 83       	std	Z+1, r25	; 0x01
    2570:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    2572:	ed 81       	ldd	r30, Y+5	; 0x05
    2574:	fe 81       	ldd	r31, Y+6	; 0x06
    2576:	80 81       	ld	r24, Z
    2578:	91 81       	ldd	r25, Z+1	; 0x01
    257a:	00 97       	sbiw	r24, 0x00	; 0
    257c:	91 f0       	breq	.+36     	; 0x25a2 <xQueueGenericCreate+0x9c>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    257e:	ed 81       	ldd	r30, Y+5	; 0x05
    2580:	fe 81       	ldd	r31, Y+6	; 0x06
    2582:	8f 81       	ldd	r24, Y+7	; 0x07
    2584:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2586:	ed 81       	ldd	r30, Y+5	; 0x05
    2588:	fe 81       	ldd	r31, Y+6	; 0x06
    258a:	88 85       	ldd	r24, Y+8	; 0x08
    258c:	84 8f       	std	Z+28, r24	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    258e:	8d 81       	ldd	r24, Y+5	; 0x05
    2590:	9e 81       	ldd	r25, Y+6	; 0x06
    2592:	61 e0       	ldi	r22, 0x01	; 1
    2594:	0e 94 fd 11 	call	0x23fa	; 0x23fa <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    2598:	8d 81       	ldd	r24, Y+5	; 0x05
    259a:	9e 81       	ldd	r25, Y+6	; 0x06
    259c:	9a 83       	std	Y+2, r25	; 0x02
    259e:	89 83       	std	Y+1, r24	; 0x01
    25a0:	04 c0       	rjmp	.+8      	; 0x25aa <xQueueGenericCreate+0xa4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    25a2:	8d 81       	ldd	r24, Y+5	; 0x05
    25a4:	9e 81       	ldd	r25, Y+6	; 0x06
    25a6:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <vPortFree>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    25aa:	89 81       	ldd	r24, Y+1	; 0x01
    25ac:	9a 81       	ldd	r25, Y+2	; 0x02
}
    25ae:	29 96       	adiw	r28, 0x09	; 9
    25b0:	0f b6       	in	r0, 0x3f	; 63
    25b2:	f8 94       	cli
    25b4:	de bf       	out	0x3e, r29	; 62
    25b6:	0f be       	out	0x3f, r0	; 63
    25b8:	cd bf       	out	0x3d, r28	; 61
    25ba:	cf 91       	pop	r28
    25bc:	df 91       	pop	r29
    25be:	08 95       	ret

000025c0 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    25c0:	df 93       	push	r29
    25c2:	cf 93       	push	r28
    25c4:	00 d0       	rcall	.+0      	; 0x25c6 <xQueueCreateCountingSemaphore+0x6>
    25c6:	00 d0       	rcall	.+0      	; 0x25c8 <xQueueCreateCountingSemaphore+0x8>
    25c8:	cd b7       	in	r28, 0x3d	; 61
    25ca:	de b7       	in	r29, 0x3e	; 62
    25cc:	8b 83       	std	Y+3, r24	; 0x03
    25ce:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    25d0:	8b 81       	ldd	r24, Y+3	; 0x03
    25d2:	60 e0       	ldi	r22, 0x00	; 0
    25d4:	42 e0       	ldi	r20, 0x02	; 2
    25d6:	0e 94 83 12 	call	0x2506	; 0x2506 <xQueueGenericCreate>
    25da:	9a 83       	std	Y+2, r25	; 0x02
    25dc:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    25de:	89 81       	ldd	r24, Y+1	; 0x01
    25e0:	9a 81       	ldd	r25, Y+2	; 0x02
    25e2:	00 97       	sbiw	r24, 0x00	; 0
    25e4:	21 f0       	breq	.+8      	; 0x25ee <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    25e6:	e9 81       	ldd	r30, Y+1	; 0x01
    25e8:	fa 81       	ldd	r31, Y+2	; 0x02
    25ea:	8c 81       	ldd	r24, Y+4	; 0x04
    25ec:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
		return xHandle;
    25ee:	89 81       	ldd	r24, Y+1	; 0x01
    25f0:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    25f2:	0f 90       	pop	r0
    25f4:	0f 90       	pop	r0
    25f6:	0f 90       	pop	r0
    25f8:	0f 90       	pop	r0
    25fa:	cf 91       	pop	r28
    25fc:	df 91       	pop	r29
    25fe:	08 95       	ret

00002600 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    2600:	df 93       	push	r29
    2602:	cf 93       	push	r28
    2604:	cd b7       	in	r28, 0x3d	; 61
    2606:	de b7       	in	r29, 0x3e	; 62
    2608:	2f 97       	sbiw	r28, 0x0f	; 15
    260a:	0f b6       	in	r0, 0x3f	; 63
    260c:	f8 94       	cli
    260e:	de bf       	out	0x3e, r29	; 62
    2610:	0f be       	out	0x3f, r0	; 63
    2612:	cd bf       	out	0x3d, r28	; 61
    2614:	99 87       	std	Y+9, r25	; 0x09
    2616:	88 87       	std	Y+8, r24	; 0x08
    2618:	7b 87       	std	Y+11, r23	; 0x0b
    261a:	6a 87       	std	Y+10, r22	; 0x0a
    261c:	5d 87       	std	Y+13, r21	; 0x0d
    261e:	4c 87       	std	Y+12, r20	; 0x0c
    2620:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2622:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2624:	88 85       	ldd	r24, Y+8	; 0x08
    2626:	99 85       	ldd	r25, Y+9	; 0x09
    2628:	9a 83       	std	Y+2, r25	; 0x02
    262a:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    262c:	0f b6       	in	r0, 0x3f	; 63
    262e:	f8 94       	cli
    2630:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2632:	e9 81       	ldd	r30, Y+1	; 0x01
    2634:	fa 81       	ldd	r31, Y+2	; 0x02
    2636:	92 8d       	ldd	r25, Z+26	; 0x1a
    2638:	e9 81       	ldd	r30, Y+1	; 0x01
    263a:	fa 81       	ldd	r31, Y+2	; 0x02
    263c:	83 8d       	ldd	r24, Z+27	; 0x1b
    263e:	98 17       	cp	r25, r24
    2640:	18 f0       	brcs	.+6      	; 0x2648 <xQueueGenericSend+0x48>
    2642:	8e 85       	ldd	r24, Y+14	; 0x0e
    2644:	82 30       	cpi	r24, 0x02	; 2
    2646:	11 f5       	brne	.+68     	; 0x268c <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2648:	89 81       	ldd	r24, Y+1	; 0x01
    264a:	9a 81       	ldd	r25, Y+2	; 0x02
    264c:	2a 85       	ldd	r18, Y+10	; 0x0a
    264e:	3b 85       	ldd	r19, Y+11	; 0x0b
    2650:	b9 01       	movw	r22, r18
    2652:	4e 85       	ldd	r20, Y+14	; 0x0e
    2654:	0e 94 d5 15 	call	0x2baa	; 0x2baa <prvCopyDataToQueue>
    2658:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    265a:	e9 81       	ldd	r30, Y+1	; 0x01
    265c:	fa 81       	ldd	r31, Y+2	; 0x02
    265e:	81 89       	ldd	r24, Z+17	; 0x11
    2660:	88 23       	and	r24, r24
    2662:	51 f0       	breq	.+20     	; 0x2678 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2664:	89 81       	ldd	r24, Y+1	; 0x01
    2666:	9a 81       	ldd	r25, Y+2	; 0x02
    2668:	41 96       	adiw	r24, 0x11	; 17
    266a:	0e 94 f1 1d 	call	0x3be2	; 0x3be2 <xTaskRemoveFromEventList>
    266e:	81 30       	cpi	r24, 0x01	; 1
    2670:	41 f4       	brne	.+16     	; 0x2682 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2672:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vPortYield>
    2676:	05 c0       	rjmp	.+10     	; 0x2682 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    2678:	8b 81       	ldd	r24, Y+3	; 0x03
    267a:	88 23       	and	r24, r24
    267c:	11 f0       	breq	.+4      	; 0x2682 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    267e:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2682:	0f 90       	pop	r0
    2684:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2686:	81 e0       	ldi	r24, 0x01	; 1
    2688:	8f 87       	std	Y+15, r24	; 0x0f
    268a:	5c c0       	rjmp	.+184    	; 0x2744 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    268c:	8c 85       	ldd	r24, Y+12	; 0x0c
    268e:	9d 85       	ldd	r25, Y+13	; 0x0d
    2690:	00 97       	sbiw	r24, 0x00	; 0
    2692:	21 f4       	brne	.+8      	; 0x269c <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2694:	0f 90       	pop	r0
    2696:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2698:	1f 86       	std	Y+15, r1	; 0x0f
    269a:	54 c0       	rjmp	.+168    	; 0x2744 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    269c:	8c 81       	ldd	r24, Y+4	; 0x04
    269e:	88 23       	and	r24, r24
    26a0:	31 f4       	brne	.+12     	; 0x26ae <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    26a2:	ce 01       	movw	r24, r28
    26a4:	05 96       	adiw	r24, 0x05	; 5
    26a6:	0e 94 c1 1e 	call	0x3d82	; 0x3d82 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    26aa:	81 e0       	ldi	r24, 0x01	; 1
    26ac:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    26ae:	0f 90       	pop	r0
    26b0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    26b2:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    26b6:	0f b6       	in	r0, 0x3f	; 63
    26b8:	f8 94       	cli
    26ba:	0f 92       	push	r0
    26bc:	e9 81       	ldd	r30, Y+1	; 0x01
    26be:	fa 81       	ldd	r31, Y+2	; 0x02
    26c0:	85 8d       	ldd	r24, Z+29	; 0x1d
    26c2:	8f 3f       	cpi	r24, 0xFF	; 255
    26c4:	19 f4       	brne	.+6      	; 0x26cc <xQueueGenericSend+0xcc>
    26c6:	e9 81       	ldd	r30, Y+1	; 0x01
    26c8:	fa 81       	ldd	r31, Y+2	; 0x02
    26ca:	15 8e       	std	Z+29, r1	; 0x1d
    26cc:	e9 81       	ldd	r30, Y+1	; 0x01
    26ce:	fa 81       	ldd	r31, Y+2	; 0x02
    26d0:	86 8d       	ldd	r24, Z+30	; 0x1e
    26d2:	8f 3f       	cpi	r24, 0xFF	; 255
    26d4:	19 f4       	brne	.+6      	; 0x26dc <xQueueGenericSend+0xdc>
    26d6:	e9 81       	ldd	r30, Y+1	; 0x01
    26d8:	fa 81       	ldd	r31, Y+2	; 0x02
    26da:	16 8e       	std	Z+30, r1	; 0x1e
    26dc:	0f 90       	pop	r0
    26de:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    26e0:	ce 01       	movw	r24, r28
    26e2:	05 96       	adiw	r24, 0x05	; 5
    26e4:	9e 01       	movw	r18, r28
    26e6:	24 5f       	subi	r18, 0xF4	; 244
    26e8:	3f 4f       	sbci	r19, 0xFF	; 255
    26ea:	b9 01       	movw	r22, r18
    26ec:	0e 94 da 1e 	call	0x3db4	; 0x3db4 <xTaskCheckForTimeOut>
    26f0:	88 23       	and	r24, r24
    26f2:	09 f5       	brne	.+66     	; 0x2736 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    26f4:	89 81       	ldd	r24, Y+1	; 0x01
    26f6:	9a 81       	ldd	r25, Y+2	; 0x02
    26f8:	0e 94 4c 17 	call	0x2e98	; 0x2e98 <prvIsQueueFull>
    26fc:	88 23       	and	r24, r24
    26fe:	a1 f0       	breq	.+40     	; 0x2728 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2700:	89 81       	ldd	r24, Y+1	; 0x01
    2702:	9a 81       	ldd	r25, Y+2	; 0x02
    2704:	08 96       	adiw	r24, 0x08	; 8
    2706:	2c 85       	ldd	r18, Y+12	; 0x0c
    2708:	3d 85       	ldd	r19, Y+13	; 0x0d
    270a:	b9 01       	movw	r22, r18
    270c:	0e 94 79 1d 	call	0x3af2	; 0x3af2 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2710:	89 81       	ldd	r24, Y+1	; 0x01
    2712:	9a 81       	ldd	r25, Y+2	; 0x02
    2714:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2718:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <xTaskResumeAll>
    271c:	88 23       	and	r24, r24
    271e:	09 f0       	breq	.+2      	; 0x2722 <xQueueGenericSend+0x122>
    2720:	85 cf       	rjmp	.-246    	; 0x262c <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    2722:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vPortYield>
    2726:	82 cf       	rjmp	.-252    	; 0x262c <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2728:	89 81       	ldd	r24, Y+1	; 0x01
    272a:	9a 81       	ldd	r25, Y+2	; 0x02
    272c:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2730:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <xTaskResumeAll>
    2734:	7b cf       	rjmp	.-266    	; 0x262c <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2736:	89 81       	ldd	r24, Y+1	; 0x01
    2738:	9a 81       	ldd	r25, Y+2	; 0x02
    273a:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    273e:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2742:	1f 86       	std	Y+15, r1	; 0x0f
    2744:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
}
    2746:	2f 96       	adiw	r28, 0x0f	; 15
    2748:	0f b6       	in	r0, 0x3f	; 63
    274a:	f8 94       	cli
    274c:	de bf       	out	0x3e, r29	; 62
    274e:	0f be       	out	0x3f, r0	; 63
    2750:	cd bf       	out	0x3d, r28	; 61
    2752:	cf 91       	pop	r28
    2754:	df 91       	pop	r29
    2756:	08 95       	ret

00002758 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    2758:	df 93       	push	r29
    275a:	cf 93       	push	r28
    275c:	cd b7       	in	r28, 0x3d	; 61
    275e:	de b7       	in	r29, 0x3e	; 62
    2760:	2b 97       	sbiw	r28, 0x0b	; 11
    2762:	0f b6       	in	r0, 0x3f	; 63
    2764:	f8 94       	cli
    2766:	de bf       	out	0x3e, r29	; 62
    2768:	0f be       	out	0x3f, r0	; 63
    276a:	cd bf       	out	0x3d, r28	; 61
    276c:	9e 83       	std	Y+6, r25	; 0x06
    276e:	8d 83       	std	Y+5, r24	; 0x05
    2770:	78 87       	std	Y+8, r23	; 0x08
    2772:	6f 83       	std	Y+7, r22	; 0x07
    2774:	5a 87       	std	Y+10, r21	; 0x0a
    2776:	49 87       	std	Y+9, r20	; 0x09
    2778:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    277a:	8d 81       	ldd	r24, Y+5	; 0x05
    277c:	9e 81       	ldd	r25, Y+6	; 0x06
    277e:	9a 83       	std	Y+2, r25	; 0x02
    2780:	89 83       	std	Y+1, r24	; 0x01
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2782:	1b 82       	std	Y+3, r1	; 0x03
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2784:	e9 81       	ldd	r30, Y+1	; 0x01
    2786:	fa 81       	ldd	r31, Y+2	; 0x02
    2788:	92 8d       	ldd	r25, Z+26	; 0x1a
    278a:	e9 81       	ldd	r30, Y+1	; 0x01
    278c:	fa 81       	ldd	r31, Y+2	; 0x02
    278e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2790:	98 17       	cp	r25, r24
    2792:	18 f0       	brcs	.+6      	; 0x279a <xQueueGenericSendFromISR+0x42>
    2794:	8b 85       	ldd	r24, Y+11	; 0x0b
    2796:	82 30       	cpi	r24, 0x02	; 2
    2798:	b1 f5       	brne	.+108    	; 0x2806 <xQueueGenericSendFromISR+0xae>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    279a:	89 81       	ldd	r24, Y+1	; 0x01
    279c:	9a 81       	ldd	r25, Y+2	; 0x02
    279e:	2f 81       	ldd	r18, Y+7	; 0x07
    27a0:	38 85       	ldd	r19, Y+8	; 0x08
    27a2:	b9 01       	movw	r22, r18
    27a4:	4b 85       	ldd	r20, Y+11	; 0x0b
    27a6:	0e 94 d5 15 	call	0x2baa	; 0x2baa <prvCopyDataToQueue>
    27aa:	88 23       	and	r24, r24
    27ac:	41 f0       	breq	.+16     	; 0x27be <xQueueGenericSendFromISR+0x66>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    27ae:	89 85       	ldd	r24, Y+9	; 0x09
    27b0:	9a 85       	ldd	r25, Y+10	; 0x0a
    27b2:	00 97       	sbiw	r24, 0x00	; 0
    27b4:	21 f0       	breq	.+8      	; 0x27be <xQueueGenericSendFromISR+0x66>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    27b6:	e9 85       	ldd	r30, Y+9	; 0x09
    27b8:	fa 85       	ldd	r31, Y+10	; 0x0a
    27ba:	81 e0       	ldi	r24, 0x01	; 1
    27bc:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    27be:	e9 81       	ldd	r30, Y+1	; 0x01
    27c0:	fa 81       	ldd	r31, Y+2	; 0x02
    27c2:	86 8d       	ldd	r24, Z+30	; 0x1e
    27c4:	8f 3f       	cpi	r24, 0xFF	; 255
    27c6:	a9 f4       	brne	.+42     	; 0x27f2 <xQueueGenericSendFromISR+0x9a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    27c8:	e9 81       	ldd	r30, Y+1	; 0x01
    27ca:	fa 81       	ldd	r31, Y+2	; 0x02
    27cc:	81 89       	ldd	r24, Z+17	; 0x11
    27ce:	88 23       	and	r24, r24
    27d0:	b9 f0       	breq	.+46     	; 0x2800 <xQueueGenericSendFromISR+0xa8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    27d2:	89 81       	ldd	r24, Y+1	; 0x01
    27d4:	9a 81       	ldd	r25, Y+2	; 0x02
    27d6:	41 96       	adiw	r24, 0x11	; 17
    27d8:	0e 94 f1 1d 	call	0x3be2	; 0x3be2 <xTaskRemoveFromEventList>
    27dc:	88 23       	and	r24, r24
    27de:	81 f0       	breq	.+32     	; 0x2800 <xQueueGenericSendFromISR+0xa8>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    27e0:	89 85       	ldd	r24, Y+9	; 0x09
    27e2:	9a 85       	ldd	r25, Y+10	; 0x0a
    27e4:	00 97       	sbiw	r24, 0x00	; 0
    27e6:	61 f0       	breq	.+24     	; 0x2800 <xQueueGenericSendFromISR+0xa8>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    27e8:	e9 85       	ldd	r30, Y+9	; 0x09
    27ea:	fa 85       	ldd	r31, Y+10	; 0x0a
    27ec:	81 e0       	ldi	r24, 0x01	; 1
    27ee:	80 83       	st	Z, r24
    27f0:	07 c0       	rjmp	.+14     	; 0x2800 <xQueueGenericSendFromISR+0xa8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    27f2:	e9 81       	ldd	r30, Y+1	; 0x01
    27f4:	fa 81       	ldd	r31, Y+2	; 0x02
    27f6:	86 8d       	ldd	r24, Z+30	; 0x1e
    27f8:	8f 5f       	subi	r24, 0xFF	; 255
    27fa:	e9 81       	ldd	r30, Y+1	; 0x01
    27fc:	fa 81       	ldd	r31, Y+2	; 0x02
    27fe:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2800:	81 e0       	ldi	r24, 0x01	; 1
    2802:	8c 83       	std	Y+4, r24	; 0x04
    2804:	01 c0       	rjmp	.+2      	; 0x2808 <xQueueGenericSendFromISR+0xb0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2806:	1c 82       	std	Y+4, r1	; 0x04
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2808:	8c 81       	ldd	r24, Y+4	; 0x04
}
    280a:	2b 96       	adiw	r28, 0x0b	; 11
    280c:	0f b6       	in	r0, 0x3f	; 63
    280e:	f8 94       	cli
    2810:	de bf       	out	0x3e, r29	; 62
    2812:	0f be       	out	0x3f, r0	; 63
    2814:	cd bf       	out	0x3d, r28	; 61
    2816:	cf 91       	pop	r28
    2818:	df 91       	pop	r29
    281a:	08 95       	ret

0000281c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    281c:	df 93       	push	r29
    281e:	cf 93       	push	r28
    2820:	cd b7       	in	r28, 0x3d	; 61
    2822:	de b7       	in	r29, 0x3e	; 62
    2824:	60 97       	sbiw	r28, 0x10	; 16
    2826:	0f b6       	in	r0, 0x3f	; 63
    2828:	f8 94       	cli
    282a:	de bf       	out	0x3e, r29	; 62
    282c:	0f be       	out	0x3f, r0	; 63
    282e:	cd bf       	out	0x3d, r28	; 61
    2830:	9a 87       	std	Y+10, r25	; 0x0a
    2832:	89 87       	std	Y+9, r24	; 0x09
    2834:	7c 87       	std	Y+12, r23	; 0x0c
    2836:	6b 87       	std	Y+11, r22	; 0x0b
    2838:	5e 87       	std	Y+14, r21	; 0x0e
    283a:	4d 87       	std	Y+13, r20	; 0x0d
    283c:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    283e:	1d 82       	std	Y+5, r1	; 0x05
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2840:	89 85       	ldd	r24, Y+9	; 0x09
    2842:	9a 85       	ldd	r25, Y+10	; 0x0a
    2844:	9a 83       	std	Y+2, r25	; 0x02
    2846:	89 83       	std	Y+1, r24	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2848:	0f b6       	in	r0, 0x3f	; 63
    284a:	f8 94       	cli
    284c:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    284e:	e9 81       	ldd	r30, Y+1	; 0x01
    2850:	fa 81       	ldd	r31, Y+2	; 0x02
    2852:	82 8d       	ldd	r24, Z+26	; 0x1a
    2854:	88 23       	and	r24, r24
    2856:	09 f4       	brne	.+2      	; 0x285a <xQueueGenericReceive+0x3e>
    2858:	3f c0       	rjmp	.+126    	; 0x28d8 <xQueueGenericReceive+0xbc>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    285a:	e9 81       	ldd	r30, Y+1	; 0x01
    285c:	fa 81       	ldd	r31, Y+2	; 0x02
    285e:	86 81       	ldd	r24, Z+6	; 0x06
    2860:	97 81       	ldd	r25, Z+7	; 0x07
    2862:	9c 83       	std	Y+4, r25	; 0x04
    2864:	8b 83       	std	Y+3, r24	; 0x03

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2866:	89 81       	ldd	r24, Y+1	; 0x01
    2868:	9a 81       	ldd	r25, Y+2	; 0x02
    286a:	2b 85       	ldd	r18, Y+11	; 0x0b
    286c:	3c 85       	ldd	r19, Y+12	; 0x0c
    286e:	b9 01       	movw	r22, r18
    2870:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2874:	8f 85       	ldd	r24, Y+15	; 0x0f
    2876:	88 23       	and	r24, r24
    2878:	b1 f4       	brne	.+44     	; 0x28a6 <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    287a:	e9 81       	ldd	r30, Y+1	; 0x01
    287c:	fa 81       	ldd	r31, Y+2	; 0x02
    287e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2880:	81 50       	subi	r24, 0x01	; 1
    2882:	e9 81       	ldd	r30, Y+1	; 0x01
    2884:	fa 81       	ldd	r31, Y+2	; 0x02
    2886:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2888:	e9 81       	ldd	r30, Y+1	; 0x01
    288a:	fa 81       	ldd	r31, Y+2	; 0x02
    288c:	80 85       	ldd	r24, Z+8	; 0x08
    288e:	88 23       	and	r24, r24
    2890:	f1 f0       	breq	.+60     	; 0x28ce <xQueueGenericReceive+0xb2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2892:	89 81       	ldd	r24, Y+1	; 0x01
    2894:	9a 81       	ldd	r25, Y+2	; 0x02
    2896:	08 96       	adiw	r24, 0x08	; 8
    2898:	0e 94 f1 1d 	call	0x3be2	; 0x3be2 <xTaskRemoveFromEventList>
    289c:	81 30       	cpi	r24, 0x01	; 1
    289e:	b9 f4       	brne	.+46     	; 0x28ce <xQueueGenericReceive+0xb2>
						{
							queueYIELD_IF_USING_PREEMPTION();
    28a0:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vPortYield>
    28a4:	14 c0       	rjmp	.+40     	; 0x28ce <xQueueGenericReceive+0xb2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    28a6:	e9 81       	ldd	r30, Y+1	; 0x01
    28a8:	fa 81       	ldd	r31, Y+2	; 0x02
    28aa:	8b 81       	ldd	r24, Y+3	; 0x03
    28ac:	9c 81       	ldd	r25, Y+4	; 0x04
    28ae:	97 83       	std	Z+7, r25	; 0x07
    28b0:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    28b2:	e9 81       	ldd	r30, Y+1	; 0x01
    28b4:	fa 81       	ldd	r31, Y+2	; 0x02
    28b6:	81 89       	ldd	r24, Z+17	; 0x11
    28b8:	88 23       	and	r24, r24
    28ba:	49 f0       	breq	.+18     	; 0x28ce <xQueueGenericReceive+0xb2>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    28bc:	89 81       	ldd	r24, Y+1	; 0x01
    28be:	9a 81       	ldd	r25, Y+2	; 0x02
    28c0:	41 96       	adiw	r24, 0x11	; 17
    28c2:	0e 94 f1 1d 	call	0x3be2	; 0x3be2 <xTaskRemoveFromEventList>
    28c6:	88 23       	and	r24, r24
    28c8:	11 f0       	breq	.+4      	; 0x28ce <xQueueGenericReceive+0xb2>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    28ca:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    28ce:	0f 90       	pop	r0
    28d0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    28d2:	81 e0       	ldi	r24, 0x01	; 1
    28d4:	88 8b       	std	Y+16, r24	; 0x10
    28d6:	5c c0       	rjmp	.+184    	; 0x2990 <xQueueGenericReceive+0x174>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    28d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    28da:	9e 85       	ldd	r25, Y+14	; 0x0e
    28dc:	00 97       	sbiw	r24, 0x00	; 0
    28de:	21 f4       	brne	.+8      	; 0x28e8 <xQueueGenericReceive+0xcc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    28e0:	0f 90       	pop	r0
    28e2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    28e4:	18 8a       	std	Y+16, r1	; 0x10
    28e6:	54 c0       	rjmp	.+168    	; 0x2990 <xQueueGenericReceive+0x174>
				}
				else if( xEntryTimeSet == pdFALSE )
    28e8:	8d 81       	ldd	r24, Y+5	; 0x05
    28ea:	88 23       	and	r24, r24
    28ec:	31 f4       	brne	.+12     	; 0x28fa <xQueueGenericReceive+0xde>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    28ee:	ce 01       	movw	r24, r28
    28f0:	06 96       	adiw	r24, 0x06	; 6
    28f2:	0e 94 c1 1e 	call	0x3d82	; 0x3d82 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    28f6:	81 e0       	ldi	r24, 0x01	; 1
    28f8:	8d 83       	std	Y+5, r24	; 0x05
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    28fa:	0f 90       	pop	r0
    28fc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    28fe:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2902:	0f b6       	in	r0, 0x3f	; 63
    2904:	f8 94       	cli
    2906:	0f 92       	push	r0
    2908:	e9 81       	ldd	r30, Y+1	; 0x01
    290a:	fa 81       	ldd	r31, Y+2	; 0x02
    290c:	85 8d       	ldd	r24, Z+29	; 0x1d
    290e:	8f 3f       	cpi	r24, 0xFF	; 255
    2910:	19 f4       	brne	.+6      	; 0x2918 <xQueueGenericReceive+0xfc>
    2912:	e9 81       	ldd	r30, Y+1	; 0x01
    2914:	fa 81       	ldd	r31, Y+2	; 0x02
    2916:	15 8e       	std	Z+29, r1	; 0x1d
    2918:	e9 81       	ldd	r30, Y+1	; 0x01
    291a:	fa 81       	ldd	r31, Y+2	; 0x02
    291c:	86 8d       	ldd	r24, Z+30	; 0x1e
    291e:	8f 3f       	cpi	r24, 0xFF	; 255
    2920:	19 f4       	brne	.+6      	; 0x2928 <xQueueGenericReceive+0x10c>
    2922:	e9 81       	ldd	r30, Y+1	; 0x01
    2924:	fa 81       	ldd	r31, Y+2	; 0x02
    2926:	16 8e       	std	Z+30, r1	; 0x1e
    2928:	0f 90       	pop	r0
    292a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    292c:	ce 01       	movw	r24, r28
    292e:	06 96       	adiw	r24, 0x06	; 6
    2930:	9e 01       	movw	r18, r28
    2932:	23 5f       	subi	r18, 0xF3	; 243
    2934:	3f 4f       	sbci	r19, 0xFF	; 255
    2936:	b9 01       	movw	r22, r18
    2938:	0e 94 da 1e 	call	0x3db4	; 0x3db4 <xTaskCheckForTimeOut>
    293c:	88 23       	and	r24, r24
    293e:	09 f5       	brne	.+66     	; 0x2982 <xQueueGenericReceive+0x166>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2940:	89 81       	ldd	r24, Y+1	; 0x01
    2942:	9a 81       	ldd	r25, Y+2	; 0x02
    2944:	0e 94 17 17 	call	0x2e2e	; 0x2e2e <prvIsQueueEmpty>
    2948:	88 23       	and	r24, r24
    294a:	a1 f0       	breq	.+40     	; 0x2974 <xQueueGenericReceive+0x158>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    294c:	89 81       	ldd	r24, Y+1	; 0x01
    294e:	9a 81       	ldd	r25, Y+2	; 0x02
    2950:	41 96       	adiw	r24, 0x11	; 17
    2952:	2d 85       	ldd	r18, Y+13	; 0x0d
    2954:	3e 85       	ldd	r19, Y+14	; 0x0e
    2956:	b9 01       	movw	r22, r18
    2958:	0e 94 79 1d 	call	0x3af2	; 0x3af2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    295c:	89 81       	ldd	r24, Y+1	; 0x01
    295e:	9a 81       	ldd	r25, Y+2	; 0x02
    2960:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2964:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <xTaskResumeAll>
    2968:	88 23       	and	r24, r24
    296a:	09 f0       	breq	.+2      	; 0x296e <xQueueGenericReceive+0x152>
    296c:	6d cf       	rjmp	.-294    	; 0x2848 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    296e:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vPortYield>
    2972:	6a cf       	rjmp	.-300    	; 0x2848 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2974:	89 81       	ldd	r24, Y+1	; 0x01
    2976:	9a 81       	ldd	r25, Y+2	; 0x02
    2978:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    297c:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <xTaskResumeAll>
    2980:	63 cf       	rjmp	.-314    	; 0x2848 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2982:	89 81       	ldd	r24, Y+1	; 0x01
    2984:	9a 81       	ldd	r25, Y+2	; 0x02
    2986:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    298a:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    298e:	18 8a       	std	Y+16, r1	; 0x10
    2990:	88 89       	ldd	r24, Y+16	; 0x10
		}
	}
}
    2992:	60 96       	adiw	r28, 0x10	; 16
    2994:	0f b6       	in	r0, 0x3f	; 63
    2996:	f8 94       	cli
    2998:	de bf       	out	0x3e, r29	; 62
    299a:	0f be       	out	0x3f, r0	; 63
    299c:	cd bf       	out	0x3d, r28	; 61
    299e:	cf 91       	pop	r28
    29a0:	df 91       	pop	r29
    29a2:	08 95       	ret

000029a4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    29a4:	df 93       	push	r29
    29a6:	cf 93       	push	r28
    29a8:	cd b7       	in	r28, 0x3d	; 61
    29aa:	de b7       	in	r29, 0x3e	; 62
    29ac:	2a 97       	sbiw	r28, 0x0a	; 10
    29ae:	0f b6       	in	r0, 0x3f	; 63
    29b0:	f8 94       	cli
    29b2:	de bf       	out	0x3e, r29	; 62
    29b4:	0f be       	out	0x3f, r0	; 63
    29b6:	cd bf       	out	0x3d, r28	; 61
    29b8:	9e 83       	std	Y+6, r25	; 0x06
    29ba:	8d 83       	std	Y+5, r24	; 0x05
    29bc:	78 87       	std	Y+8, r23	; 0x08
    29be:	6f 83       	std	Y+7, r22	; 0x07
    29c0:	5a 87       	std	Y+10, r21	; 0x0a
    29c2:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    29c4:	8d 81       	ldd	r24, Y+5	; 0x05
    29c6:	9e 81       	ldd	r25, Y+6	; 0x06
    29c8:	9a 83       	std	Y+2, r25	; 0x02
    29ca:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    29cc:	1b 82       	std	Y+3, r1	; 0x03
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    29ce:	e9 81       	ldd	r30, Y+1	; 0x01
    29d0:	fa 81       	ldd	r31, Y+2	; 0x02
    29d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    29d4:	88 23       	and	r24, r24
    29d6:	91 f1       	breq	.+100    	; 0x2a3c <xQueueReceiveFromISR+0x98>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    29d8:	89 81       	ldd	r24, Y+1	; 0x01
    29da:	9a 81       	ldd	r25, Y+2	; 0x02
    29dc:	2f 81       	ldd	r18, Y+7	; 0x07
    29de:	38 85       	ldd	r19, Y+8	; 0x08
    29e0:	b9 01       	movw	r22, r18
    29e2:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    29e6:	e9 81       	ldd	r30, Y+1	; 0x01
    29e8:	fa 81       	ldd	r31, Y+2	; 0x02
    29ea:	82 8d       	ldd	r24, Z+26	; 0x1a
    29ec:	81 50       	subi	r24, 0x01	; 1
    29ee:	e9 81       	ldd	r30, Y+1	; 0x01
    29f0:	fa 81       	ldd	r31, Y+2	; 0x02
    29f2:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    29f4:	e9 81       	ldd	r30, Y+1	; 0x01
    29f6:	fa 81       	ldd	r31, Y+2	; 0x02
    29f8:	85 8d       	ldd	r24, Z+29	; 0x1d
    29fa:	8f 3f       	cpi	r24, 0xFF	; 255
    29fc:	a9 f4       	brne	.+42     	; 0x2a28 <xQueueReceiveFromISR+0x84>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    29fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2a00:	fa 81       	ldd	r31, Y+2	; 0x02
    2a02:	80 85       	ldd	r24, Z+8	; 0x08
    2a04:	88 23       	and	r24, r24
    2a06:	b9 f0       	breq	.+46     	; 0x2a36 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2a08:	89 81       	ldd	r24, Y+1	; 0x01
    2a0a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a0c:	08 96       	adiw	r24, 0x08	; 8
    2a0e:	0e 94 f1 1d 	call	0x3be2	; 0x3be2 <xTaskRemoveFromEventList>
    2a12:	88 23       	and	r24, r24
    2a14:	81 f0       	breq	.+32     	; 0x2a36 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2a16:	89 85       	ldd	r24, Y+9	; 0x09
    2a18:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a1a:	00 97       	sbiw	r24, 0x00	; 0
    2a1c:	61 f0       	breq	.+24     	; 0x2a36 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2a1e:	e9 85       	ldd	r30, Y+9	; 0x09
    2a20:	fa 85       	ldd	r31, Y+10	; 0x0a
    2a22:	81 e0       	ldi	r24, 0x01	; 1
    2a24:	80 83       	st	Z, r24
    2a26:	07 c0       	rjmp	.+14     	; 0x2a36 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2a28:	e9 81       	ldd	r30, Y+1	; 0x01
    2a2a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a2c:	85 8d       	ldd	r24, Z+29	; 0x1d
    2a2e:	8f 5f       	subi	r24, 0xFF	; 255
    2a30:	e9 81       	ldd	r30, Y+1	; 0x01
    2a32:	fa 81       	ldd	r31, Y+2	; 0x02
    2a34:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2a36:	81 e0       	ldi	r24, 0x01	; 1
    2a38:	8c 83       	std	Y+4, r24	; 0x04
    2a3a:	01 c0       	rjmp	.+2      	; 0x2a3e <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    2a3c:	1c 82       	std	Y+4, r1	; 0x04
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2a3e:	8c 81       	ldd	r24, Y+4	; 0x04
}
    2a40:	2a 96       	adiw	r28, 0x0a	; 10
    2a42:	0f b6       	in	r0, 0x3f	; 63
    2a44:	f8 94       	cli
    2a46:	de bf       	out	0x3e, r29	; 62
    2a48:	0f be       	out	0x3f, r0	; 63
    2a4a:	cd bf       	out	0x3d, r28	; 61
    2a4c:	cf 91       	pop	r28
    2a4e:	df 91       	pop	r29
    2a50:	08 95       	ret

00002a52 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2a52:	df 93       	push	r29
    2a54:	cf 93       	push	r28
    2a56:	cd b7       	in	r28, 0x3d	; 61
    2a58:	de b7       	in	r29, 0x3e	; 62
    2a5a:	2a 97       	sbiw	r28, 0x0a	; 10
    2a5c:	0f b6       	in	r0, 0x3f	; 63
    2a5e:	f8 94       	cli
    2a60:	de bf       	out	0x3e, r29	; 62
    2a62:	0f be       	out	0x3f, r0	; 63
    2a64:	cd bf       	out	0x3d, r28	; 61
    2a66:	98 87       	std	Y+8, r25	; 0x08
    2a68:	8f 83       	std	Y+7, r24	; 0x07
    2a6a:	7a 87       	std	Y+10, r23	; 0x0a
    2a6c:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2a6e:	8f 81       	ldd	r24, Y+7	; 0x07
    2a70:	98 85       	ldd	r25, Y+8	; 0x08
    2a72:	9a 83       	std	Y+2, r25	; 0x02
    2a74:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2a76:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2a78:	e9 81       	ldd	r30, Y+1	; 0x01
    2a7a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a7c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a7e:	88 23       	and	r24, r24
    2a80:	b1 f0       	breq	.+44     	; 0x2aae <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2a82:	e9 81       	ldd	r30, Y+1	; 0x01
    2a84:	fa 81       	ldd	r31, Y+2	; 0x02
    2a86:	86 81       	ldd	r24, Z+6	; 0x06
    2a88:	97 81       	ldd	r25, Z+7	; 0x07
    2a8a:	9c 83       	std	Y+4, r25	; 0x04
    2a8c:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2a8e:	89 81       	ldd	r24, Y+1	; 0x01
    2a90:	9a 81       	ldd	r25, Y+2	; 0x02
    2a92:	29 85       	ldd	r18, Y+9	; 0x09
    2a94:	3a 85       	ldd	r19, Y+10	; 0x0a
    2a96:	b9 01       	movw	r22, r18
    2a98:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2a9c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a9e:	fa 81       	ldd	r31, Y+2	; 0x02
    2aa0:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa2:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa4:	97 83       	std	Z+7, r25	; 0x07
    2aa6:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    2aa8:	81 e0       	ldi	r24, 0x01	; 1
    2aaa:	8e 83       	std	Y+6, r24	; 0x06
    2aac:	01 c0       	rjmp	.+2      	; 0x2ab0 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    2aae:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2ab0:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2ab2:	2a 96       	adiw	r28, 0x0a	; 10
    2ab4:	0f b6       	in	r0, 0x3f	; 63
    2ab6:	f8 94       	cli
    2ab8:	de bf       	out	0x3e, r29	; 62
    2aba:	0f be       	out	0x3f, r0	; 63
    2abc:	cd bf       	out	0x3d, r28	; 61
    2abe:	cf 91       	pop	r28
    2ac0:	df 91       	pop	r29
    2ac2:	08 95       	ret

00002ac4 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2ac4:	df 93       	push	r29
    2ac6:	cf 93       	push	r28
    2ac8:	00 d0       	rcall	.+0      	; 0x2aca <uxQueueMessagesWaiting+0x6>
    2aca:	0f 92       	push	r0
    2acc:	cd b7       	in	r28, 0x3d	; 61
    2ace:	de b7       	in	r29, 0x3e	; 62
    2ad0:	9b 83       	std	Y+3, r25	; 0x03
    2ad2:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    2ad4:	0f b6       	in	r0, 0x3f	; 63
    2ad6:	f8 94       	cli
    2ad8:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2ada:	ea 81       	ldd	r30, Y+2	; 0x02
    2adc:	fb 81       	ldd	r31, Y+3	; 0x03
    2ade:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ae0:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2ae2:	0f 90       	pop	r0
    2ae4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2ae6:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2ae8:	0f 90       	pop	r0
    2aea:	0f 90       	pop	r0
    2aec:	0f 90       	pop	r0
    2aee:	cf 91       	pop	r28
    2af0:	df 91       	pop	r29
    2af2:	08 95       	ret

00002af4 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2af4:	df 93       	push	r29
    2af6:	cf 93       	push	r28
    2af8:	00 d0       	rcall	.+0      	; 0x2afa <uxQueueSpacesAvailable+0x6>
    2afa:	00 d0       	rcall	.+0      	; 0x2afc <uxQueueSpacesAvailable+0x8>
    2afc:	0f 92       	push	r0
    2afe:	cd b7       	in	r28, 0x3d	; 61
    2b00:	de b7       	in	r29, 0x3e	; 62
    2b02:	9d 83       	std	Y+5, r25	; 0x05
    2b04:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    2b06:	8c 81       	ldd	r24, Y+4	; 0x04
    2b08:	9d 81       	ldd	r25, Y+5	; 0x05
    2b0a:	9a 83       	std	Y+2, r25	; 0x02
    2b0c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2b0e:	0f b6       	in	r0, 0x3f	; 63
    2b10:	f8 94       	cli
    2b12:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2b14:	e9 81       	ldd	r30, Y+1	; 0x01
    2b16:	fa 81       	ldd	r31, Y+2	; 0x02
    2b18:	93 8d       	ldd	r25, Z+27	; 0x1b
    2b1a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b1c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b1e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b20:	29 2f       	mov	r18, r25
    2b22:	28 1b       	sub	r18, r24
    2b24:	82 2f       	mov	r24, r18
    2b26:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2b28:	0f 90       	pop	r0
    2b2a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2b2c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2b2e:	0f 90       	pop	r0
    2b30:	0f 90       	pop	r0
    2b32:	0f 90       	pop	r0
    2b34:	0f 90       	pop	r0
    2b36:	0f 90       	pop	r0
    2b38:	cf 91       	pop	r28
    2b3a:	df 91       	pop	r29
    2b3c:	08 95       	ret

00002b3e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2b3e:	df 93       	push	r29
    2b40:	cf 93       	push	r28
    2b42:	00 d0       	rcall	.+0      	; 0x2b44 <uxQueueMessagesWaitingFromISR+0x6>
    2b44:	0f 92       	push	r0
    2b46:	cd b7       	in	r28, 0x3d	; 61
    2b48:	de b7       	in	r29, 0x3e	; 62
    2b4a:	9b 83       	std	Y+3, r25	; 0x03
    2b4c:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2b4e:	ea 81       	ldd	r30, Y+2	; 0x02
    2b50:	fb 81       	ldd	r31, Y+3	; 0x03
    2b52:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b54:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    2b56:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2b58:	0f 90       	pop	r0
    2b5a:	0f 90       	pop	r0
    2b5c:	0f 90       	pop	r0
    2b5e:	cf 91       	pop	r28
    2b60:	df 91       	pop	r29
    2b62:	08 95       	ret

00002b64 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2b64:	df 93       	push	r29
    2b66:	cf 93       	push	r28
    2b68:	00 d0       	rcall	.+0      	; 0x2b6a <vQueueDelete+0x6>
    2b6a:	00 d0       	rcall	.+0      	; 0x2b6c <vQueueDelete+0x8>
    2b6c:	cd b7       	in	r28, 0x3d	; 61
    2b6e:	de b7       	in	r29, 0x3e	; 62
    2b70:	9c 83       	std	Y+4, r25	; 0x04
    2b72:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2b74:	8b 81       	ldd	r24, Y+3	; 0x03
    2b76:	9c 81       	ldd	r25, Y+4	; 0x04
    2b78:	9a 83       	std	Y+2, r25	; 0x02
    2b7a:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	if( pxQueue->pcHead != NULL )
    2b7c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b7e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b80:	80 81       	ld	r24, Z
    2b82:	91 81       	ldd	r25, Z+1	; 0x01
    2b84:	00 97       	sbiw	r24, 0x00	; 0
    2b86:	31 f0       	breq	.+12     	; 0x2b94 <vQueueDelete+0x30>
	{
		vPortFree( pxQueue->pcHead );
    2b88:	e9 81       	ldd	r30, Y+1	; 0x01
    2b8a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b8c:	80 81       	ld	r24, Z
    2b8e:	91 81       	ldd	r25, Z+1	; 0x01
    2b90:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <vPortFree>
	}
	vPortFree( pxQueue );
    2b94:	89 81       	ldd	r24, Y+1	; 0x01
    2b96:	9a 81       	ldd	r25, Y+2	; 0x02
    2b98:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <vPortFree>
}
    2b9c:	0f 90       	pop	r0
    2b9e:	0f 90       	pop	r0
    2ba0:	0f 90       	pop	r0
    2ba2:	0f 90       	pop	r0
    2ba4:	cf 91       	pop	r28
    2ba6:	df 91       	pop	r29
    2ba8:	08 95       	ret

00002baa <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2baa:	df 93       	push	r29
    2bac:	cf 93       	push	r28
    2bae:	00 d0       	rcall	.+0      	; 0x2bb0 <prvCopyDataToQueue+0x6>
    2bb0:	00 d0       	rcall	.+0      	; 0x2bb2 <prvCopyDataToQueue+0x8>
    2bb2:	00 d0       	rcall	.+0      	; 0x2bb4 <prvCopyDataToQueue+0xa>
    2bb4:	cd b7       	in	r28, 0x3d	; 61
    2bb6:	de b7       	in	r29, 0x3e	; 62
    2bb8:	9b 83       	std	Y+3, r25	; 0x03
    2bba:	8a 83       	std	Y+2, r24	; 0x02
    2bbc:	7d 83       	std	Y+5, r23	; 0x05
    2bbe:	6c 83       	std	Y+4, r22	; 0x04
    2bc0:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    2bc2:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2bc4:	ea 81       	ldd	r30, Y+2	; 0x02
    2bc6:	fb 81       	ldd	r31, Y+3	; 0x03
    2bc8:	84 8d       	ldd	r24, Z+28	; 0x1c
    2bca:	88 23       	and	r24, r24
    2bcc:	09 f4       	brne	.+2      	; 0x2bd0 <prvCopyDataToQueue+0x26>
    2bce:	83 c0       	rjmp	.+262    	; 0x2cd6 <prvCopyDataToQueue+0x12c>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2bd0:	8e 81       	ldd	r24, Y+6	; 0x06
    2bd2:	88 23       	and	r24, r24
    2bd4:	99 f5       	brne	.+102    	; 0x2c3c <prvCopyDataToQueue+0x92>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    2bd6:	ea 81       	ldd	r30, Y+2	; 0x02
    2bd8:	fb 81       	ldd	r31, Y+3	; 0x03
    2bda:	64 81       	ldd	r22, Z+4	; 0x04
    2bdc:	75 81       	ldd	r23, Z+5	; 0x05
    2bde:	ea 81       	ldd	r30, Y+2	; 0x02
    2be0:	fb 81       	ldd	r31, Y+3	; 0x03
    2be2:	84 8d       	ldd	r24, Z+28	; 0x1c
    2be4:	48 2f       	mov	r20, r24
    2be6:	50 e0       	ldi	r21, 0x00	; 0
    2be8:	2c 81       	ldd	r18, Y+4	; 0x04
    2bea:	3d 81       	ldd	r19, Y+5	; 0x05
    2bec:	cb 01       	movw	r24, r22
    2bee:	b9 01       	movw	r22, r18
    2bf0:	0e 94 c2 2e 	call	0x5d84	; 0x5d84 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2bf4:	ea 81       	ldd	r30, Y+2	; 0x02
    2bf6:	fb 81       	ldd	r31, Y+3	; 0x03
    2bf8:	24 81       	ldd	r18, Z+4	; 0x04
    2bfa:	35 81       	ldd	r19, Z+5	; 0x05
    2bfc:	ea 81       	ldd	r30, Y+2	; 0x02
    2bfe:	fb 81       	ldd	r31, Y+3	; 0x03
    2c00:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c02:	88 2f       	mov	r24, r24
    2c04:	90 e0       	ldi	r25, 0x00	; 0
    2c06:	82 0f       	add	r24, r18
    2c08:	93 1f       	adc	r25, r19
    2c0a:	ea 81       	ldd	r30, Y+2	; 0x02
    2c0c:	fb 81       	ldd	r31, Y+3	; 0x03
    2c0e:	95 83       	std	Z+5, r25	; 0x05
    2c10:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2c12:	ea 81       	ldd	r30, Y+2	; 0x02
    2c14:	fb 81       	ldd	r31, Y+3	; 0x03
    2c16:	24 81       	ldd	r18, Z+4	; 0x04
    2c18:	35 81       	ldd	r19, Z+5	; 0x05
    2c1a:	ea 81       	ldd	r30, Y+2	; 0x02
    2c1c:	fb 81       	ldd	r31, Y+3	; 0x03
    2c1e:	82 81       	ldd	r24, Z+2	; 0x02
    2c20:	93 81       	ldd	r25, Z+3	; 0x03
    2c22:	28 17       	cp	r18, r24
    2c24:	39 07       	cpc	r19, r25
    2c26:	08 f4       	brcc	.+2      	; 0x2c2a <prvCopyDataToQueue+0x80>
    2c28:	56 c0       	rjmp	.+172    	; 0x2cd6 <prvCopyDataToQueue+0x12c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2c2a:	ea 81       	ldd	r30, Y+2	; 0x02
    2c2c:	fb 81       	ldd	r31, Y+3	; 0x03
    2c2e:	80 81       	ld	r24, Z
    2c30:	91 81       	ldd	r25, Z+1	; 0x01
    2c32:	ea 81       	ldd	r30, Y+2	; 0x02
    2c34:	fb 81       	ldd	r31, Y+3	; 0x03
    2c36:	95 83       	std	Z+5, r25	; 0x05
    2c38:	84 83       	std	Z+4, r24	; 0x04
    2c3a:	4d c0       	rjmp	.+154    	; 0x2cd6 <prvCopyDataToQueue+0x12c>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2c3c:	ea 81       	ldd	r30, Y+2	; 0x02
    2c3e:	fb 81       	ldd	r31, Y+3	; 0x03
    2c40:	66 81       	ldd	r22, Z+6	; 0x06
    2c42:	77 81       	ldd	r23, Z+7	; 0x07
    2c44:	ea 81       	ldd	r30, Y+2	; 0x02
    2c46:	fb 81       	ldd	r31, Y+3	; 0x03
    2c48:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c4a:	48 2f       	mov	r20, r24
    2c4c:	50 e0       	ldi	r21, 0x00	; 0
    2c4e:	2c 81       	ldd	r18, Y+4	; 0x04
    2c50:	3d 81       	ldd	r19, Y+5	; 0x05
    2c52:	cb 01       	movw	r24, r22
    2c54:	b9 01       	movw	r22, r18
    2c56:	0e 94 c2 2e 	call	0x5d84	; 0x5d84 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    2c5a:	ea 81       	ldd	r30, Y+2	; 0x02
    2c5c:	fb 81       	ldd	r31, Y+3	; 0x03
    2c5e:	26 81       	ldd	r18, Z+6	; 0x06
    2c60:	37 81       	ldd	r19, Z+7	; 0x07
    2c62:	ea 81       	ldd	r30, Y+2	; 0x02
    2c64:	fb 81       	ldd	r31, Y+3	; 0x03
    2c66:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c68:	88 2f       	mov	r24, r24
    2c6a:	90 e0       	ldi	r25, 0x00	; 0
    2c6c:	90 95       	com	r25
    2c6e:	81 95       	neg	r24
    2c70:	9f 4f       	sbci	r25, 0xFF	; 255
    2c72:	82 0f       	add	r24, r18
    2c74:	93 1f       	adc	r25, r19
    2c76:	ea 81       	ldd	r30, Y+2	; 0x02
    2c78:	fb 81       	ldd	r31, Y+3	; 0x03
    2c7a:	97 83       	std	Z+7, r25	; 0x07
    2c7c:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2c7e:	ea 81       	ldd	r30, Y+2	; 0x02
    2c80:	fb 81       	ldd	r31, Y+3	; 0x03
    2c82:	26 81       	ldd	r18, Z+6	; 0x06
    2c84:	37 81       	ldd	r19, Z+7	; 0x07
    2c86:	ea 81       	ldd	r30, Y+2	; 0x02
    2c88:	fb 81       	ldd	r31, Y+3	; 0x03
    2c8a:	80 81       	ld	r24, Z
    2c8c:	91 81       	ldd	r25, Z+1	; 0x01
    2c8e:	28 17       	cp	r18, r24
    2c90:	39 07       	cpc	r19, r25
    2c92:	90 f4       	brcc	.+36     	; 0x2cb8 <prvCopyDataToQueue+0x10e>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    2c94:	ea 81       	ldd	r30, Y+2	; 0x02
    2c96:	fb 81       	ldd	r31, Y+3	; 0x03
    2c98:	22 81       	ldd	r18, Z+2	; 0x02
    2c9a:	33 81       	ldd	r19, Z+3	; 0x03
    2c9c:	ea 81       	ldd	r30, Y+2	; 0x02
    2c9e:	fb 81       	ldd	r31, Y+3	; 0x03
    2ca0:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ca2:	88 2f       	mov	r24, r24
    2ca4:	90 e0       	ldi	r25, 0x00	; 0
    2ca6:	90 95       	com	r25
    2ca8:	81 95       	neg	r24
    2caa:	9f 4f       	sbci	r25, 0xFF	; 255
    2cac:	82 0f       	add	r24, r18
    2cae:	93 1f       	adc	r25, r19
    2cb0:	ea 81       	ldd	r30, Y+2	; 0x02
    2cb2:	fb 81       	ldd	r31, Y+3	; 0x03
    2cb4:	97 83       	std	Z+7, r25	; 0x07
    2cb6:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2cb8:	8e 81       	ldd	r24, Y+6	; 0x06
    2cba:	82 30       	cpi	r24, 0x02	; 2
    2cbc:	61 f4       	brne	.+24     	; 0x2cd6 <prvCopyDataToQueue+0x12c>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2cbe:	ea 81       	ldd	r30, Y+2	; 0x02
    2cc0:	fb 81       	ldd	r31, Y+3	; 0x03
    2cc2:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cc4:	88 23       	and	r24, r24
    2cc6:	39 f0       	breq	.+14     	; 0x2cd6 <prvCopyDataToQueue+0x12c>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    2cc8:	ea 81       	ldd	r30, Y+2	; 0x02
    2cca:	fb 81       	ldd	r31, Y+3	; 0x03
    2ccc:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cce:	81 50       	subi	r24, 0x01	; 1
    2cd0:	ea 81       	ldd	r30, Y+2	; 0x02
    2cd2:	fb 81       	ldd	r31, Y+3	; 0x03
    2cd4:	82 8f       	std	Z+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2cd6:	ea 81       	ldd	r30, Y+2	; 0x02
    2cd8:	fb 81       	ldd	r31, Y+3	; 0x03
    2cda:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cdc:	8f 5f       	subi	r24, 0xFF	; 255
    2cde:	ea 81       	ldd	r30, Y+2	; 0x02
    2ce0:	fb 81       	ldd	r31, Y+3	; 0x03
    2ce2:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    2ce4:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ce6:	26 96       	adiw	r28, 0x06	; 6
    2ce8:	0f b6       	in	r0, 0x3f	; 63
    2cea:	f8 94       	cli
    2cec:	de bf       	out	0x3e, r29	; 62
    2cee:	0f be       	out	0x3f, r0	; 63
    2cf0:	cd bf       	out	0x3d, r28	; 61
    2cf2:	cf 91       	pop	r28
    2cf4:	df 91       	pop	r29
    2cf6:	08 95       	ret

00002cf8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2cf8:	df 93       	push	r29
    2cfa:	cf 93       	push	r28
    2cfc:	00 d0       	rcall	.+0      	; 0x2cfe <prvCopyDataFromQueue+0x6>
    2cfe:	00 d0       	rcall	.+0      	; 0x2d00 <prvCopyDataFromQueue+0x8>
    2d00:	cd b7       	in	r28, 0x3d	; 61
    2d02:	de b7       	in	r29, 0x3e	; 62
    2d04:	9a 83       	std	Y+2, r25	; 0x02
    2d06:	89 83       	std	Y+1, r24	; 0x01
    2d08:	7c 83       	std	Y+4, r23	; 0x04
    2d0a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2d0c:	e9 81       	ldd	r30, Y+1	; 0x01
    2d0e:	fa 81       	ldd	r31, Y+2	; 0x02
    2d10:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d12:	88 23       	and	r24, r24
    2d14:	89 f1       	breq	.+98     	; 0x2d78 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    2d16:	e9 81       	ldd	r30, Y+1	; 0x01
    2d18:	fa 81       	ldd	r31, Y+2	; 0x02
    2d1a:	26 81       	ldd	r18, Z+6	; 0x06
    2d1c:	37 81       	ldd	r19, Z+7	; 0x07
    2d1e:	e9 81       	ldd	r30, Y+1	; 0x01
    2d20:	fa 81       	ldd	r31, Y+2	; 0x02
    2d22:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d24:	88 2f       	mov	r24, r24
    2d26:	90 e0       	ldi	r25, 0x00	; 0
    2d28:	82 0f       	add	r24, r18
    2d2a:	93 1f       	adc	r25, r19
    2d2c:	e9 81       	ldd	r30, Y+1	; 0x01
    2d2e:	fa 81       	ldd	r31, Y+2	; 0x02
    2d30:	97 83       	std	Z+7, r25	; 0x07
    2d32:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2d34:	e9 81       	ldd	r30, Y+1	; 0x01
    2d36:	fa 81       	ldd	r31, Y+2	; 0x02
    2d38:	26 81       	ldd	r18, Z+6	; 0x06
    2d3a:	37 81       	ldd	r19, Z+7	; 0x07
    2d3c:	e9 81       	ldd	r30, Y+1	; 0x01
    2d3e:	fa 81       	ldd	r31, Y+2	; 0x02
    2d40:	82 81       	ldd	r24, Z+2	; 0x02
    2d42:	93 81       	ldd	r25, Z+3	; 0x03
    2d44:	28 17       	cp	r18, r24
    2d46:	39 07       	cpc	r19, r25
    2d48:	40 f0       	brcs	.+16     	; 0x2d5a <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2d4a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d4c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d4e:	80 81       	ld	r24, Z
    2d50:	91 81       	ldd	r25, Z+1	; 0x01
    2d52:	e9 81       	ldd	r30, Y+1	; 0x01
    2d54:	fa 81       	ldd	r31, Y+2	; 0x02
    2d56:	97 83       	std	Z+7, r25	; 0x07
    2d58:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    2d5a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d5c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d5e:	46 81       	ldd	r20, Z+6	; 0x06
    2d60:	57 81       	ldd	r21, Z+7	; 0x07
    2d62:	e9 81       	ldd	r30, Y+1	; 0x01
    2d64:	fa 81       	ldd	r31, Y+2	; 0x02
    2d66:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d68:	28 2f       	mov	r18, r24
    2d6a:	30 e0       	ldi	r19, 0x00	; 0
    2d6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d70:	ba 01       	movw	r22, r20
    2d72:	a9 01       	movw	r20, r18
    2d74:	0e 94 c2 2e 	call	0x5d84	; 0x5d84 <memcpy>
	}
}
    2d78:	0f 90       	pop	r0
    2d7a:	0f 90       	pop	r0
    2d7c:	0f 90       	pop	r0
    2d7e:	0f 90       	pop	r0
    2d80:	cf 91       	pop	r28
    2d82:	df 91       	pop	r29
    2d84:	08 95       	ret

00002d86 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2d86:	df 93       	push	r29
    2d88:	cf 93       	push	r28
    2d8a:	00 d0       	rcall	.+0      	; 0x2d8c <prvUnlockQueue+0x6>
    2d8c:	cd b7       	in	r28, 0x3d	; 61
    2d8e:	de b7       	in	r29, 0x3e	; 62
    2d90:	9a 83       	std	Y+2, r25	; 0x02
    2d92:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2d94:	0f b6       	in	r0, 0x3f	; 63
    2d96:	f8 94       	cli
    2d98:	0f 92       	push	r0
    2d9a:	15 c0       	rjmp	.+42     	; 0x2dc6 <prvUnlockQueue+0x40>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2d9c:	e9 81       	ldd	r30, Y+1	; 0x01
    2d9e:	fa 81       	ldd	r31, Y+2	; 0x02
    2da0:	81 89       	ldd	r24, Z+17	; 0x11
    2da2:	88 23       	and	r24, r24
    2da4:	a9 f0       	breq	.+42     	; 0x2dd0 <prvUnlockQueue+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2da6:	89 81       	ldd	r24, Y+1	; 0x01
    2da8:	9a 81       	ldd	r25, Y+2	; 0x02
    2daa:	41 96       	adiw	r24, 0x11	; 17
    2dac:	0e 94 f1 1d 	call	0x3be2	; 0x3be2 <xTaskRemoveFromEventList>
    2db0:	88 23       	and	r24, r24
    2db2:	11 f0       	breq	.+4      	; 0x2db8 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    2db4:	0e 94 3d 1f 	call	0x3e7a	; 0x3e7a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2db8:	e9 81       	ldd	r30, Y+1	; 0x01
    2dba:	fa 81       	ldd	r31, Y+2	; 0x02
    2dbc:	86 8d       	ldd	r24, Z+30	; 0x1e
    2dbe:	81 50       	subi	r24, 0x01	; 1
    2dc0:	e9 81       	ldd	r30, Y+1	; 0x01
    2dc2:	fa 81       	ldd	r31, Y+2	; 0x02
    2dc4:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2dc6:	e9 81       	ldd	r30, Y+1	; 0x01
    2dc8:	fa 81       	ldd	r31, Y+2	; 0x02
    2dca:	86 8d       	ldd	r24, Z+30	; 0x1e
    2dcc:	18 16       	cp	r1, r24
    2dce:	34 f3       	brlt	.-52     	; 0x2d9c <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2dd0:	e9 81       	ldd	r30, Y+1	; 0x01
    2dd2:	fa 81       	ldd	r31, Y+2	; 0x02
    2dd4:	8f ef       	ldi	r24, 0xFF	; 255
    2dd6:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2dd8:	0f 90       	pop	r0
    2dda:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2ddc:	0f b6       	in	r0, 0x3f	; 63
    2dde:	f8 94       	cli
    2de0:	0f 92       	push	r0
    2de2:	15 c0       	rjmp	.+42     	; 0x2e0e <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2de4:	e9 81       	ldd	r30, Y+1	; 0x01
    2de6:	fa 81       	ldd	r31, Y+2	; 0x02
    2de8:	80 85       	ldd	r24, Z+8	; 0x08
    2dea:	88 23       	and	r24, r24
    2dec:	a9 f0       	breq	.+42     	; 0x2e18 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2dee:	89 81       	ldd	r24, Y+1	; 0x01
    2df0:	9a 81       	ldd	r25, Y+2	; 0x02
    2df2:	08 96       	adiw	r24, 0x08	; 8
    2df4:	0e 94 f1 1d 	call	0x3be2	; 0x3be2 <xTaskRemoveFromEventList>
    2df8:	88 23       	and	r24, r24
    2dfa:	11 f0       	breq	.+4      	; 0x2e00 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    2dfc:	0e 94 3d 1f 	call	0x3e7a	; 0x3e7a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    2e00:	e9 81       	ldd	r30, Y+1	; 0x01
    2e02:	fa 81       	ldd	r31, Y+2	; 0x02
    2e04:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e06:	81 50       	subi	r24, 0x01	; 1
    2e08:	e9 81       	ldd	r30, Y+1	; 0x01
    2e0a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e0c:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2e0e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e10:	fa 81       	ldd	r31, Y+2	; 0x02
    2e12:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e14:	18 16       	cp	r1, r24
    2e16:	34 f3       	brlt	.-52     	; 0x2de4 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2e18:	e9 81       	ldd	r30, Y+1	; 0x01
    2e1a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e1c:	8f ef       	ldi	r24, 0xFF	; 255
    2e1e:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2e20:	0f 90       	pop	r0
    2e22:	0f be       	out	0x3f, r0	; 63
}
    2e24:	0f 90       	pop	r0
    2e26:	0f 90       	pop	r0
    2e28:	cf 91       	pop	r28
    2e2a:	df 91       	pop	r29
    2e2c:	08 95       	ret

00002e2e <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2e2e:	df 93       	push	r29
    2e30:	cf 93       	push	r28
    2e32:	00 d0       	rcall	.+0      	; 0x2e34 <prvIsQueueEmpty+0x6>
    2e34:	0f 92       	push	r0
    2e36:	cd b7       	in	r28, 0x3d	; 61
    2e38:	de b7       	in	r29, 0x3e	; 62
    2e3a:	9b 83       	std	Y+3, r25	; 0x03
    2e3c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2e3e:	0f b6       	in	r0, 0x3f	; 63
    2e40:	f8 94       	cli
    2e42:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2e44:	ea 81       	ldd	r30, Y+2	; 0x02
    2e46:	fb 81       	ldd	r31, Y+3	; 0x03
    2e48:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e4a:	88 23       	and	r24, r24
    2e4c:	19 f4       	brne	.+6      	; 0x2e54 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2e4e:	81 e0       	ldi	r24, 0x01	; 1
    2e50:	89 83       	std	Y+1, r24	; 0x01
    2e52:	01 c0       	rjmp	.+2      	; 0x2e56 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2e54:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2e56:	0f 90       	pop	r0
    2e58:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2e5a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2e5c:	0f 90       	pop	r0
    2e5e:	0f 90       	pop	r0
    2e60:	0f 90       	pop	r0
    2e62:	cf 91       	pop	r28
    2e64:	df 91       	pop	r29
    2e66:	08 95       	ret

00002e68 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2e68:	df 93       	push	r29
    2e6a:	cf 93       	push	r28
    2e6c:	00 d0       	rcall	.+0      	; 0x2e6e <xQueueIsQueueEmptyFromISR+0x6>
    2e6e:	0f 92       	push	r0
    2e70:	cd b7       	in	r28, 0x3d	; 61
    2e72:	de b7       	in	r29, 0x3e	; 62
    2e74:	9b 83       	std	Y+3, r25	; 0x03
    2e76:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2e78:	ea 81       	ldd	r30, Y+2	; 0x02
    2e7a:	fb 81       	ldd	r31, Y+3	; 0x03
    2e7c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e7e:	88 23       	and	r24, r24
    2e80:	19 f4       	brne	.+6      	; 0x2e88 <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    2e82:	81 e0       	ldi	r24, 0x01	; 1
    2e84:	89 83       	std	Y+1, r24	; 0x01
    2e86:	01 c0       	rjmp	.+2      	; 0x2e8a <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    2e88:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2e8a:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2e8c:	0f 90       	pop	r0
    2e8e:	0f 90       	pop	r0
    2e90:	0f 90       	pop	r0
    2e92:	cf 91       	pop	r28
    2e94:	df 91       	pop	r29
    2e96:	08 95       	ret

00002e98 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2e98:	df 93       	push	r29
    2e9a:	cf 93       	push	r28
    2e9c:	00 d0       	rcall	.+0      	; 0x2e9e <prvIsQueueFull+0x6>
    2e9e:	0f 92       	push	r0
    2ea0:	cd b7       	in	r28, 0x3d	; 61
    2ea2:	de b7       	in	r29, 0x3e	; 62
    2ea4:	9b 83       	std	Y+3, r25	; 0x03
    2ea6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2ea8:	0f b6       	in	r0, 0x3f	; 63
    2eaa:	f8 94       	cli
    2eac:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2eae:	ea 81       	ldd	r30, Y+2	; 0x02
    2eb0:	fb 81       	ldd	r31, Y+3	; 0x03
    2eb2:	92 8d       	ldd	r25, Z+26	; 0x1a
    2eb4:	ea 81       	ldd	r30, Y+2	; 0x02
    2eb6:	fb 81       	ldd	r31, Y+3	; 0x03
    2eb8:	83 8d       	ldd	r24, Z+27	; 0x1b
    2eba:	98 17       	cp	r25, r24
    2ebc:	19 f4       	brne	.+6      	; 0x2ec4 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    2ebe:	81 e0       	ldi	r24, 0x01	; 1
    2ec0:	89 83       	std	Y+1, r24	; 0x01
    2ec2:	01 c0       	rjmp	.+2      	; 0x2ec6 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2ec4:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2ec6:	0f 90       	pop	r0
    2ec8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2eca:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ecc:	0f 90       	pop	r0
    2ece:	0f 90       	pop	r0
    2ed0:	0f 90       	pop	r0
    2ed2:	cf 91       	pop	r28
    2ed4:	df 91       	pop	r29
    2ed6:	08 95       	ret

00002ed8 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2ed8:	df 93       	push	r29
    2eda:	cf 93       	push	r28
    2edc:	00 d0       	rcall	.+0      	; 0x2ede <xQueueIsQueueFullFromISR+0x6>
    2ede:	0f 92       	push	r0
    2ee0:	cd b7       	in	r28, 0x3d	; 61
    2ee2:	de b7       	in	r29, 0x3e	; 62
    2ee4:	9b 83       	std	Y+3, r25	; 0x03
    2ee6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    2ee8:	ea 81       	ldd	r30, Y+2	; 0x02
    2eea:	fb 81       	ldd	r31, Y+3	; 0x03
    2eec:	92 8d       	ldd	r25, Z+26	; 0x1a
    2eee:	ea 81       	ldd	r30, Y+2	; 0x02
    2ef0:	fb 81       	ldd	r31, Y+3	; 0x03
    2ef2:	83 8d       	ldd	r24, Z+27	; 0x1b
    2ef4:	98 17       	cp	r25, r24
    2ef6:	19 f4       	brne	.+6      	; 0x2efe <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    2ef8:	81 e0       	ldi	r24, 0x01	; 1
    2efa:	89 83       	std	Y+1, r24	; 0x01
    2efc:	01 c0       	rjmp	.+2      	; 0x2f00 <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    2efe:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2f00:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2f02:	0f 90       	pop	r0
    2f04:	0f 90       	pop	r0
    2f06:	0f 90       	pop	r0
    2f08:	cf 91       	pop	r28
    2f0a:	df 91       	pop	r29
    2f0c:	08 95       	ret

00002f0e <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    2f0e:	df 93       	push	r29
    2f10:	cf 93       	push	r28
    2f12:	cd b7       	in	r28, 0x3d	; 61
    2f14:	de b7       	in	r29, 0x3e	; 62
    2f16:	2a 97       	sbiw	r28, 0x0a	; 10
    2f18:	0f b6       	in	r0, 0x3f	; 63
    2f1a:	f8 94       	cli
    2f1c:	de bf       	out	0x3e, r29	; 62
    2f1e:	0f be       	out	0x3f, r0	; 63
    2f20:	cd bf       	out	0x3d, r28	; 61
    2f22:	9d 83       	std	Y+5, r25	; 0x05
    2f24:	8c 83       	std	Y+4, r24	; 0x04
    2f26:	7f 83       	std	Y+7, r23	; 0x07
    2f28:	6e 83       	std	Y+6, r22	; 0x06
    2f2a:	59 87       	std	Y+9, r21	; 0x09
    2f2c:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2f2e:	8c 81       	ldd	r24, Y+4	; 0x04
    2f30:	9d 81       	ldd	r25, Y+5	; 0x05
    2f32:	9a 83       	std	Y+2, r25	; 0x02
    2f34:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    2f36:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2f38:	89 81       	ldd	r24, Y+1	; 0x01
    2f3a:	9a 81       	ldd	r25, Y+2	; 0x02
    2f3c:	0e 94 4c 17 	call	0x2e98	; 0x2e98 <prvIsQueueFull>
    2f40:	88 23       	and	r24, r24
    2f42:	a9 f0       	breq	.+42     	; 0x2f6e <xQueueCRSend+0x60>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    2f44:	88 85       	ldd	r24, Y+8	; 0x08
    2f46:	99 85       	ldd	r25, Y+9	; 0x09
    2f48:	00 97       	sbiw	r24, 0x00	; 0
    2f4a:	71 f0       	breq	.+28     	; 0x2f68 <xQueueCRSend+0x5a>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    2f4c:	89 81       	ldd	r24, Y+1	; 0x01
    2f4e:	9a 81       	ldd	r25, Y+2	; 0x02
    2f50:	9c 01       	movw	r18, r24
    2f52:	28 5f       	subi	r18, 0xF8	; 248
    2f54:	3f 4f       	sbci	r19, 0xFF	; 255
    2f56:	88 85       	ldd	r24, Y+8	; 0x08
    2f58:	99 85       	ldd	r25, Y+9	; 0x09
    2f5a:	b9 01       	movw	r22, r18
    2f5c:	0e 94 21 07 	call	0xe42	; 0xe42 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    2f60:	78 94       	sei
					return errQUEUE_BLOCKED;
    2f62:	8c ef       	ldi	r24, 0xFC	; 252
    2f64:	8a 87       	std	Y+10, r24	; 0x0a
    2f66:	2a c0       	rjmp	.+84     	; 0x2fbc <xQueueCRSend+0xae>
				}
				else
				{
					portENABLE_INTERRUPTS();
    2f68:	78 94       	sei
					return errQUEUE_FULL;
    2f6a:	1a 86       	std	Y+10, r1	; 0x0a
    2f6c:	27 c0       	rjmp	.+78     	; 0x2fbc <xQueueCRSend+0xae>
				}
			}
		}
		portENABLE_INTERRUPTS();
    2f6e:	78 94       	sei

		portDISABLE_INTERRUPTS();
    2f70:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2f72:	e9 81       	ldd	r30, Y+1	; 0x01
    2f74:	fa 81       	ldd	r31, Y+2	; 0x02
    2f76:	92 8d       	ldd	r25, Z+26	; 0x1a
    2f78:	e9 81       	ldd	r30, Y+1	; 0x01
    2f7a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f7c:	83 8d       	ldd	r24, Z+27	; 0x1b
    2f7e:	98 17       	cp	r25, r24
    2f80:	c8 f4       	brcc	.+50     	; 0x2fb4 <xQueueCRSend+0xa6>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2f82:	89 81       	ldd	r24, Y+1	; 0x01
    2f84:	9a 81       	ldd	r25, Y+2	; 0x02
    2f86:	2e 81       	ldd	r18, Y+6	; 0x06
    2f88:	3f 81       	ldd	r19, Y+7	; 0x07
    2f8a:	b9 01       	movw	r22, r18
    2f8c:	40 e0       	ldi	r20, 0x00	; 0
    2f8e:	0e 94 d5 15 	call	0x2baa	; 0x2baa <prvCopyDataToQueue>
				xReturn = pdPASS;
    2f92:	81 e0       	ldi	r24, 0x01	; 1
    2f94:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2f96:	e9 81       	ldd	r30, Y+1	; 0x01
    2f98:	fa 81       	ldd	r31, Y+2	; 0x02
    2f9a:	81 89       	ldd	r24, Z+17	; 0x11
    2f9c:	88 23       	and	r24, r24
    2f9e:	59 f0       	breq	.+22     	; 0x2fb6 <xQueueCRSend+0xa8>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2fa0:	89 81       	ldd	r24, Y+1	; 0x01
    2fa2:	9a 81       	ldd	r25, Y+2	; 0x02
    2fa4:	41 96       	adiw	r24, 0x11	; 17
    2fa6:	0e 94 2d 09 	call	0x125a	; 0x125a <xCoRoutineRemoveFromEventList>
    2faa:	88 23       	and	r24, r24
    2fac:	21 f0       	breq	.+8      	; 0x2fb6 <xQueueCRSend+0xa8>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    2fae:	8b ef       	ldi	r24, 0xFB	; 251
    2fb0:	8b 83       	std	Y+3, r24	; 0x03
    2fb2:	01 c0       	rjmp	.+2      	; 0x2fb6 <xQueueCRSend+0xa8>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    2fb4:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    2fb6:	78 94       	sei

		return xReturn;
    2fb8:	8b 81       	ldd	r24, Y+3	; 0x03
    2fba:	8a 87       	std	Y+10, r24	; 0x0a
    2fbc:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    2fbe:	2a 96       	adiw	r28, 0x0a	; 10
    2fc0:	0f b6       	in	r0, 0x3f	; 63
    2fc2:	f8 94       	cli
    2fc4:	de bf       	out	0x3e, r29	; 62
    2fc6:	0f be       	out	0x3f, r0	; 63
    2fc8:	cd bf       	out	0x3d, r28	; 61
    2fca:	cf 91       	pop	r28
    2fcc:	df 91       	pop	r29
    2fce:	08 95       	ret

00002fd0 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    2fd0:	df 93       	push	r29
    2fd2:	cf 93       	push	r28
    2fd4:	cd b7       	in	r28, 0x3d	; 61
    2fd6:	de b7       	in	r29, 0x3e	; 62
    2fd8:	2a 97       	sbiw	r28, 0x0a	; 10
    2fda:	0f b6       	in	r0, 0x3f	; 63
    2fdc:	f8 94       	cli
    2fde:	de bf       	out	0x3e, r29	; 62
    2fe0:	0f be       	out	0x3f, r0	; 63
    2fe2:	cd bf       	out	0x3d, r28	; 61
    2fe4:	9d 83       	std	Y+5, r25	; 0x05
    2fe6:	8c 83       	std	Y+4, r24	; 0x04
    2fe8:	7f 83       	std	Y+7, r23	; 0x07
    2fea:	6e 83       	std	Y+6, r22	; 0x06
    2fec:	59 87       	std	Y+9, r21	; 0x09
    2fee:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2ff0:	8c 81       	ldd	r24, Y+4	; 0x04
    2ff2:	9d 81       	ldd	r25, Y+5	; 0x05
    2ff4:	9a 83       	std	Y+2, r25	; 0x02
    2ff6:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    2ff8:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2ffa:	e9 81       	ldd	r30, Y+1	; 0x01
    2ffc:	fa 81       	ldd	r31, Y+2	; 0x02
    2ffe:	82 8d       	ldd	r24, Z+26	; 0x1a
    3000:	88 23       	and	r24, r24
    3002:	a9 f4       	brne	.+42     	; 0x302e <xQueueCRReceive+0x5e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    3004:	88 85       	ldd	r24, Y+8	; 0x08
    3006:	99 85       	ldd	r25, Y+9	; 0x09
    3008:	00 97       	sbiw	r24, 0x00	; 0
    300a:	71 f0       	breq	.+28     	; 0x3028 <xQueueCRReceive+0x58>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    300c:	89 81       	ldd	r24, Y+1	; 0x01
    300e:	9a 81       	ldd	r25, Y+2	; 0x02
    3010:	9c 01       	movw	r18, r24
    3012:	2f 5e       	subi	r18, 0xEF	; 239
    3014:	3f 4f       	sbci	r19, 0xFF	; 255
    3016:	88 85       	ldd	r24, Y+8	; 0x08
    3018:	99 85       	ldd	r25, Y+9	; 0x09
    301a:	b9 01       	movw	r22, r18
    301c:	0e 94 21 07 	call	0xe42	; 0xe42 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    3020:	78 94       	sei
					return errQUEUE_BLOCKED;
    3022:	8c ef       	ldi	r24, 0xFC	; 252
    3024:	8a 87       	std	Y+10, r24	; 0x0a
    3026:	58 c0       	rjmp	.+176    	; 0x30d8 <xQueueCRReceive+0x108>
				}
				else
				{
					portENABLE_INTERRUPTS();
    3028:	78 94       	sei
					return errQUEUE_FULL;
    302a:	1a 86       	std	Y+10, r1	; 0x0a
    302c:	55 c0       	rjmp	.+170    	; 0x30d8 <xQueueCRReceive+0x108>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    302e:	78 94       	sei

		portDISABLE_INTERRUPTS();
    3030:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3032:	e9 81       	ldd	r30, Y+1	; 0x01
    3034:	fa 81       	ldd	r31, Y+2	; 0x02
    3036:	82 8d       	ldd	r24, Z+26	; 0x1a
    3038:	88 23       	and	r24, r24
    303a:	09 f4       	brne	.+2      	; 0x303e <xQueueCRReceive+0x6e>
    303c:	49 c0       	rjmp	.+146    	; 0x30d0 <xQueueCRReceive+0x100>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    303e:	e9 81       	ldd	r30, Y+1	; 0x01
    3040:	fa 81       	ldd	r31, Y+2	; 0x02
    3042:	26 81       	ldd	r18, Z+6	; 0x06
    3044:	37 81       	ldd	r19, Z+7	; 0x07
    3046:	e9 81       	ldd	r30, Y+1	; 0x01
    3048:	fa 81       	ldd	r31, Y+2	; 0x02
    304a:	84 8d       	ldd	r24, Z+28	; 0x1c
    304c:	88 2f       	mov	r24, r24
    304e:	90 e0       	ldi	r25, 0x00	; 0
    3050:	82 0f       	add	r24, r18
    3052:	93 1f       	adc	r25, r19
    3054:	e9 81       	ldd	r30, Y+1	; 0x01
    3056:	fa 81       	ldd	r31, Y+2	; 0x02
    3058:	97 83       	std	Z+7, r25	; 0x07
    305a:	86 83       	std	Z+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    305c:	e9 81       	ldd	r30, Y+1	; 0x01
    305e:	fa 81       	ldd	r31, Y+2	; 0x02
    3060:	26 81       	ldd	r18, Z+6	; 0x06
    3062:	37 81       	ldd	r19, Z+7	; 0x07
    3064:	e9 81       	ldd	r30, Y+1	; 0x01
    3066:	fa 81       	ldd	r31, Y+2	; 0x02
    3068:	82 81       	ldd	r24, Z+2	; 0x02
    306a:	93 81       	ldd	r25, Z+3	; 0x03
    306c:	28 17       	cp	r18, r24
    306e:	39 07       	cpc	r19, r25
    3070:	40 f0       	brcs	.+16     	; 0x3082 <xQueueCRReceive+0xb2>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    3072:	e9 81       	ldd	r30, Y+1	; 0x01
    3074:	fa 81       	ldd	r31, Y+2	; 0x02
    3076:	80 81       	ld	r24, Z
    3078:	91 81       	ldd	r25, Z+1	; 0x01
    307a:	e9 81       	ldd	r30, Y+1	; 0x01
    307c:	fa 81       	ldd	r31, Y+2	; 0x02
    307e:	97 83       	std	Z+7, r25	; 0x07
    3080:	86 83       	std	Z+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    3082:	e9 81       	ldd	r30, Y+1	; 0x01
    3084:	fa 81       	ldd	r31, Y+2	; 0x02
    3086:	82 8d       	ldd	r24, Z+26	; 0x1a
    3088:	81 50       	subi	r24, 0x01	; 1
    308a:	e9 81       	ldd	r30, Y+1	; 0x01
    308c:	fa 81       	ldd	r31, Y+2	; 0x02
    308e:	82 8f       	std	Z+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3090:	e9 81       	ldd	r30, Y+1	; 0x01
    3092:	fa 81       	ldd	r31, Y+2	; 0x02
    3094:	46 81       	ldd	r20, Z+6	; 0x06
    3096:	57 81       	ldd	r21, Z+7	; 0x07
    3098:	e9 81       	ldd	r30, Y+1	; 0x01
    309a:	fa 81       	ldd	r31, Y+2	; 0x02
    309c:	84 8d       	ldd	r24, Z+28	; 0x1c
    309e:	28 2f       	mov	r18, r24
    30a0:	30 e0       	ldi	r19, 0x00	; 0
    30a2:	8e 81       	ldd	r24, Y+6	; 0x06
    30a4:	9f 81       	ldd	r25, Y+7	; 0x07
    30a6:	ba 01       	movw	r22, r20
    30a8:	a9 01       	movw	r20, r18
    30aa:	0e 94 c2 2e 	call	0x5d84	; 0x5d84 <memcpy>

				xReturn = pdPASS;
    30ae:	81 e0       	ldi	r24, 0x01	; 1
    30b0:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    30b2:	e9 81       	ldd	r30, Y+1	; 0x01
    30b4:	fa 81       	ldd	r31, Y+2	; 0x02
    30b6:	80 85       	ldd	r24, Z+8	; 0x08
    30b8:	88 23       	and	r24, r24
    30ba:	59 f0       	breq	.+22     	; 0x30d2 <xQueueCRReceive+0x102>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    30bc:	89 81       	ldd	r24, Y+1	; 0x01
    30be:	9a 81       	ldd	r25, Y+2	; 0x02
    30c0:	08 96       	adiw	r24, 0x08	; 8
    30c2:	0e 94 2d 09 	call	0x125a	; 0x125a <xCoRoutineRemoveFromEventList>
    30c6:	88 23       	and	r24, r24
    30c8:	21 f0       	breq	.+8      	; 0x30d2 <xQueueCRReceive+0x102>
					{
						xReturn = errQUEUE_YIELD;
    30ca:	8b ef       	ldi	r24, 0xFB	; 251
    30cc:	8b 83       	std	Y+3, r24	; 0x03
    30ce:	01 c0       	rjmp	.+2      	; 0x30d2 <xQueueCRReceive+0x102>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    30d0:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    30d2:	78 94       	sei

		return xReturn;
    30d4:	8b 81       	ldd	r24, Y+3	; 0x03
    30d6:	8a 87       	std	Y+10, r24	; 0x0a
    30d8:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    30da:	2a 96       	adiw	r28, 0x0a	; 10
    30dc:	0f b6       	in	r0, 0x3f	; 63
    30de:	f8 94       	cli
    30e0:	de bf       	out	0x3e, r29	; 62
    30e2:	0f be       	out	0x3f, r0	; 63
    30e4:	cd bf       	out	0x3d, r28	; 61
    30e6:	cf 91       	pop	r28
    30e8:	df 91       	pop	r29
    30ea:	08 95       	ret

000030ec <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    30ec:	df 93       	push	r29
    30ee:	cf 93       	push	r28
    30f0:	cd b7       	in	r28, 0x3d	; 61
    30f2:	de b7       	in	r29, 0x3e	; 62
    30f4:	28 97       	sbiw	r28, 0x08	; 8
    30f6:	0f b6       	in	r0, 0x3f	; 63
    30f8:	f8 94       	cli
    30fa:	de bf       	out	0x3e, r29	; 62
    30fc:	0f be       	out	0x3f, r0	; 63
    30fe:	cd bf       	out	0x3d, r28	; 61
    3100:	9c 83       	std	Y+4, r25	; 0x04
    3102:	8b 83       	std	Y+3, r24	; 0x03
    3104:	7e 83       	std	Y+6, r23	; 0x06
    3106:	6d 83       	std	Y+5, r22	; 0x05
    3108:	4f 83       	std	Y+7, r20	; 0x07
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    310a:	8b 81       	ldd	r24, Y+3	; 0x03
    310c:	9c 81       	ldd	r25, Y+4	; 0x04
    310e:	9a 83       	std	Y+2, r25	; 0x02
    3110:	89 83       	std	Y+1, r24	; 0x01

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3112:	e9 81       	ldd	r30, Y+1	; 0x01
    3114:	fa 81       	ldd	r31, Y+2	; 0x02
    3116:	92 8d       	ldd	r25, Z+26	; 0x1a
    3118:	e9 81       	ldd	r30, Y+1	; 0x01
    311a:	fa 81       	ldd	r31, Y+2	; 0x02
    311c:	83 8d       	ldd	r24, Z+27	; 0x1b
    311e:	98 17       	cp	r25, r24
    3120:	d0 f4       	brcc	.+52     	; 0x3156 <xQueueCRSendFromISR+0x6a>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    3122:	89 81       	ldd	r24, Y+1	; 0x01
    3124:	9a 81       	ldd	r25, Y+2	; 0x02
    3126:	2d 81       	ldd	r18, Y+5	; 0x05
    3128:	3e 81       	ldd	r19, Y+6	; 0x06
    312a:	b9 01       	movw	r22, r18
    312c:	40 e0       	ldi	r20, 0x00	; 0
    312e:	0e 94 d5 15 	call	0x2baa	; 0x2baa <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    3132:	8f 81       	ldd	r24, Y+7	; 0x07
    3134:	88 23       	and	r24, r24
    3136:	79 f4       	brne	.+30     	; 0x3156 <xQueueCRSendFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3138:	e9 81       	ldd	r30, Y+1	; 0x01
    313a:	fa 81       	ldd	r31, Y+2	; 0x02
    313c:	81 89       	ldd	r24, Z+17	; 0x11
    313e:	88 23       	and	r24, r24
    3140:	51 f0       	breq	.+20     	; 0x3156 <xQueueCRSendFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3142:	89 81       	ldd	r24, Y+1	; 0x01
    3144:	9a 81       	ldd	r25, Y+2	; 0x02
    3146:	41 96       	adiw	r24, 0x11	; 17
    3148:	0e 94 2d 09 	call	0x125a	; 0x125a <xCoRoutineRemoveFromEventList>
    314c:	88 23       	and	r24, r24
    314e:	19 f0       	breq	.+6      	; 0x3156 <xQueueCRSendFromISR+0x6a>
					{
						return pdTRUE;
    3150:	81 e0       	ldi	r24, 0x01	; 1
    3152:	88 87       	std	Y+8, r24	; 0x08
    3154:	02 c0       	rjmp	.+4      	; 0x315a <xQueueCRSendFromISR+0x6e>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    3156:	8f 81       	ldd	r24, Y+7	; 0x07
    3158:	88 87       	std	Y+8, r24	; 0x08
    315a:	88 85       	ldd	r24, Y+8	; 0x08
	}
    315c:	28 96       	adiw	r28, 0x08	; 8
    315e:	0f b6       	in	r0, 0x3f	; 63
    3160:	f8 94       	cli
    3162:	de bf       	out	0x3e, r29	; 62
    3164:	0f be       	out	0x3f, r0	; 63
    3166:	cd bf       	out	0x3d, r28	; 61
    3168:	cf 91       	pop	r28
    316a:	df 91       	pop	r29
    316c:	08 95       	ret

0000316e <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    316e:	df 93       	push	r29
    3170:	cf 93       	push	r28
    3172:	cd b7       	in	r28, 0x3d	; 61
    3174:	de b7       	in	r29, 0x3e	; 62
    3176:	29 97       	sbiw	r28, 0x09	; 9
    3178:	0f b6       	in	r0, 0x3f	; 63
    317a:	f8 94       	cli
    317c:	de bf       	out	0x3e, r29	; 62
    317e:	0f be       	out	0x3f, r0	; 63
    3180:	cd bf       	out	0x3d, r28	; 61
    3182:	9d 83       	std	Y+5, r25	; 0x05
    3184:	8c 83       	std	Y+4, r24	; 0x04
    3186:	7f 83       	std	Y+7, r23	; 0x07
    3188:	6e 83       	std	Y+6, r22	; 0x06
    318a:	59 87       	std	Y+9, r21	; 0x09
    318c:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    318e:	8c 81       	ldd	r24, Y+4	; 0x04
    3190:	9d 81       	ldd	r25, Y+5	; 0x05
    3192:	9a 83       	std	Y+2, r25	; 0x02
    3194:	89 83       	std	Y+1, r24	; 0x01

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3196:	e9 81       	ldd	r30, Y+1	; 0x01
    3198:	fa 81       	ldd	r31, Y+2	; 0x02
    319a:	82 8d       	ldd	r24, Z+26	; 0x1a
    319c:	88 23       	and	r24, r24
    319e:	09 f4       	brne	.+2      	; 0x31a2 <xQueueCRReceiveFromISR+0x34>
    31a0:	50 c0       	rjmp	.+160    	; 0x3242 <xQueueCRReceiveFromISR+0xd4>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    31a2:	e9 81       	ldd	r30, Y+1	; 0x01
    31a4:	fa 81       	ldd	r31, Y+2	; 0x02
    31a6:	26 81       	ldd	r18, Z+6	; 0x06
    31a8:	37 81       	ldd	r19, Z+7	; 0x07
    31aa:	e9 81       	ldd	r30, Y+1	; 0x01
    31ac:	fa 81       	ldd	r31, Y+2	; 0x02
    31ae:	84 8d       	ldd	r24, Z+28	; 0x1c
    31b0:	88 2f       	mov	r24, r24
    31b2:	90 e0       	ldi	r25, 0x00	; 0
    31b4:	82 0f       	add	r24, r18
    31b6:	93 1f       	adc	r25, r19
    31b8:	e9 81       	ldd	r30, Y+1	; 0x01
    31ba:	fa 81       	ldd	r31, Y+2	; 0x02
    31bc:	97 83       	std	Z+7, r25	; 0x07
    31be:	86 83       	std	Z+6, r24	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    31c0:	e9 81       	ldd	r30, Y+1	; 0x01
    31c2:	fa 81       	ldd	r31, Y+2	; 0x02
    31c4:	26 81       	ldd	r18, Z+6	; 0x06
    31c6:	37 81       	ldd	r19, Z+7	; 0x07
    31c8:	e9 81       	ldd	r30, Y+1	; 0x01
    31ca:	fa 81       	ldd	r31, Y+2	; 0x02
    31cc:	82 81       	ldd	r24, Z+2	; 0x02
    31ce:	93 81       	ldd	r25, Z+3	; 0x03
    31d0:	28 17       	cp	r18, r24
    31d2:	39 07       	cpc	r19, r25
    31d4:	40 f0       	brcs	.+16     	; 0x31e6 <xQueueCRReceiveFromISR+0x78>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    31d6:	e9 81       	ldd	r30, Y+1	; 0x01
    31d8:	fa 81       	ldd	r31, Y+2	; 0x02
    31da:	80 81       	ld	r24, Z
    31dc:	91 81       	ldd	r25, Z+1	; 0x01
    31de:	e9 81       	ldd	r30, Y+1	; 0x01
    31e0:	fa 81       	ldd	r31, Y+2	; 0x02
    31e2:	97 83       	std	Z+7, r25	; 0x07
    31e4:	86 83       	std	Z+6, r24	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    31e6:	e9 81       	ldd	r30, Y+1	; 0x01
    31e8:	fa 81       	ldd	r31, Y+2	; 0x02
    31ea:	82 8d       	ldd	r24, Z+26	; 0x1a
    31ec:	81 50       	subi	r24, 0x01	; 1
    31ee:	e9 81       	ldd	r30, Y+1	; 0x01
    31f0:	fa 81       	ldd	r31, Y+2	; 0x02
    31f2:	82 8f       	std	Z+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    31f4:	e9 81       	ldd	r30, Y+1	; 0x01
    31f6:	fa 81       	ldd	r31, Y+2	; 0x02
    31f8:	46 81       	ldd	r20, Z+6	; 0x06
    31fa:	57 81       	ldd	r21, Z+7	; 0x07
    31fc:	e9 81       	ldd	r30, Y+1	; 0x01
    31fe:	fa 81       	ldd	r31, Y+2	; 0x02
    3200:	84 8d       	ldd	r24, Z+28	; 0x1c
    3202:	28 2f       	mov	r18, r24
    3204:	30 e0       	ldi	r19, 0x00	; 0
    3206:	8e 81       	ldd	r24, Y+6	; 0x06
    3208:	9f 81       	ldd	r25, Y+7	; 0x07
    320a:	ba 01       	movw	r22, r20
    320c:	a9 01       	movw	r20, r18
    320e:	0e 94 c2 2e 	call	0x5d84	; 0x5d84 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    3212:	e8 85       	ldd	r30, Y+8	; 0x08
    3214:	f9 85       	ldd	r31, Y+9	; 0x09
    3216:	80 81       	ld	r24, Z
    3218:	88 23       	and	r24, r24
    321a:	81 f4       	brne	.+32     	; 0x323c <xQueueCRReceiveFromISR+0xce>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    321c:	e9 81       	ldd	r30, Y+1	; 0x01
    321e:	fa 81       	ldd	r31, Y+2	; 0x02
    3220:	80 85       	ldd	r24, Z+8	; 0x08
    3222:	88 23       	and	r24, r24
    3224:	59 f0       	breq	.+22     	; 0x323c <xQueueCRReceiveFromISR+0xce>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3226:	89 81       	ldd	r24, Y+1	; 0x01
    3228:	9a 81       	ldd	r25, Y+2	; 0x02
    322a:	08 96       	adiw	r24, 0x08	; 8
    322c:	0e 94 2d 09 	call	0x125a	; 0x125a <xCoRoutineRemoveFromEventList>
    3230:	88 23       	and	r24, r24
    3232:	21 f0       	breq	.+8      	; 0x323c <xQueueCRReceiveFromISR+0xce>
					{
						*pxCoRoutineWoken = pdTRUE;
    3234:	e8 85       	ldd	r30, Y+8	; 0x08
    3236:	f9 85       	ldd	r31, Y+9	; 0x09
    3238:	81 e0       	ldi	r24, 0x01	; 1
    323a:	80 83       	st	Z, r24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    323c:	81 e0       	ldi	r24, 0x01	; 1
    323e:	8b 83       	std	Y+3, r24	; 0x03
    3240:	01 c0       	rjmp	.+2      	; 0x3244 <xQueueCRReceiveFromISR+0xd6>
		}
		else
		{
			xReturn = pdFAIL;
    3242:	1b 82       	std	Y+3, r1	; 0x03
		}

		return xReturn;
    3244:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    3246:	29 96       	adiw	r28, 0x09	; 9
    3248:	0f b6       	in	r0, 0x3f	; 63
    324a:	f8 94       	cli
    324c:	de bf       	out	0x3e, r29	; 62
    324e:	0f be       	out	0x3f, r0	; 63
    3250:	cd bf       	out	0x3d, r28	; 61
    3252:	cf 91       	pop	r28
    3254:	df 91       	pop	r29
    3256:	08 95       	ret

00003258 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3258:	af 92       	push	r10
    325a:	bf 92       	push	r11
    325c:	cf 92       	push	r12
    325e:	df 92       	push	r13
    3260:	ef 92       	push	r14
    3262:	ff 92       	push	r15
    3264:	0f 93       	push	r16
    3266:	1f 93       	push	r17
    3268:	df 93       	push	r29
    326a:	cf 93       	push	r28
    326c:	cd b7       	in	r28, 0x3d	; 61
    326e:	de b7       	in	r29, 0x3e	; 62
    3270:	64 97       	sbiw	r28, 0x14	; 20
    3272:	0f b6       	in	r0, 0x3f	; 63
    3274:	f8 94       	cli
    3276:	de bf       	out	0x3e, r29	; 62
    3278:	0f be       	out	0x3f, r0	; 63
    327a:	cd bf       	out	0x3d, r28	; 61
    327c:	9f 83       	std	Y+7, r25	; 0x07
    327e:	8e 83       	std	Y+6, r24	; 0x06
    3280:	79 87       	std	Y+9, r23	; 0x09
    3282:	68 87       	std	Y+8, r22	; 0x08
    3284:	5b 87       	std	Y+11, r21	; 0x0b
    3286:	4a 87       	std	Y+10, r20	; 0x0a
    3288:	3d 87       	std	Y+13, r19	; 0x0d
    328a:	2c 87       	std	Y+12, r18	; 0x0c
    328c:	0e 87       	std	Y+14, r16	; 0x0e
    328e:	f8 8a       	std	Y+16, r15	; 0x10
    3290:	ef 86       	std	Y+15, r14	; 0x0f
    3292:	da 8a       	std	Y+18, r13	; 0x12
    3294:	c9 8a       	std	Y+17, r12	; 0x11
    3296:	bc 8a       	std	Y+20, r11	; 0x14
    3298:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    329a:	8a 85       	ldd	r24, Y+10	; 0x0a
    329c:	9b 85       	ldd	r25, Y+11	; 0x0b
    329e:	29 89       	ldd	r18, Y+17	; 0x11
    32a0:	3a 89       	ldd	r19, Y+18	; 0x12
    32a2:	b9 01       	movw	r22, r18
    32a4:	0e 94 8f 20 	call	0x411e	; 0x411e <prvAllocateTCBAndStack>
    32a8:	9c 83       	std	Y+4, r25	; 0x04
    32aa:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    32ac:	8b 81       	ldd	r24, Y+3	; 0x03
    32ae:	9c 81       	ldd	r25, Y+4	; 0x04
    32b0:	00 97       	sbiw	r24, 0x00	; 0
    32b2:	09 f4       	brne	.+2      	; 0x32b6 <xTaskGenericCreate+0x5e>
    32b4:	8d c0       	rjmp	.+282    	; 0x33d0 <xTaskGenericCreate+0x178>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    32b6:	eb 81       	ldd	r30, Y+3	; 0x03
    32b8:	fc 81       	ldd	r31, Y+4	; 0x04
    32ba:	27 89       	ldd	r18, Z+23	; 0x17
    32bc:	30 8d       	ldd	r19, Z+24	; 0x18
    32be:	8a 85       	ldd	r24, Y+10	; 0x0a
    32c0:	9b 85       	ldd	r25, Y+11	; 0x0b
    32c2:	01 97       	sbiw	r24, 0x01	; 1
    32c4:	82 0f       	add	r24, r18
    32c6:	93 1f       	adc	r25, r19
    32c8:	9a 83       	std	Y+2, r25	; 0x02
    32ca:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    32cc:	8b 81       	ldd	r24, Y+3	; 0x03
    32ce:	9c 81       	ldd	r25, Y+4	; 0x04
    32d0:	28 85       	ldd	r18, Y+8	; 0x08
    32d2:	39 85       	ldd	r19, Y+9	; 0x09
    32d4:	eb 89       	ldd	r30, Y+19	; 0x13
    32d6:	fc 89       	ldd	r31, Y+20	; 0x14
    32d8:	aa 85       	ldd	r26, Y+10	; 0x0a
    32da:	bb 85       	ldd	r27, Y+11	; 0x0b
    32dc:	b9 01       	movw	r22, r18
    32de:	4e 85       	ldd	r20, Y+14	; 0x0e
    32e0:	9f 01       	movw	r18, r30
    32e2:	8d 01       	movw	r16, r26
    32e4:	0e 94 57 1f 	call	0x3eae	; 0x3eae <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    32e8:	89 81       	ldd	r24, Y+1	; 0x01
    32ea:	9a 81       	ldd	r25, Y+2	; 0x02
    32ec:	2e 81       	ldd	r18, Y+6	; 0x06
    32ee:	3f 81       	ldd	r19, Y+7	; 0x07
    32f0:	4c 85       	ldd	r20, Y+12	; 0x0c
    32f2:	5d 85       	ldd	r21, Y+13	; 0x0d
    32f4:	b9 01       	movw	r22, r18
    32f6:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <pxPortInitialiseStack>
    32fa:	eb 81       	ldd	r30, Y+3	; 0x03
    32fc:	fc 81       	ldd	r31, Y+4	; 0x04
    32fe:	91 83       	std	Z+1, r25	; 0x01
    3300:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    3302:	8f 85       	ldd	r24, Y+15	; 0x0f
    3304:	98 89       	ldd	r25, Y+16	; 0x10
    3306:	00 97       	sbiw	r24, 0x00	; 0
    3308:	31 f0       	breq	.+12     	; 0x3316 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    330a:	ef 85       	ldd	r30, Y+15	; 0x0f
    330c:	f8 89       	ldd	r31, Y+16	; 0x10
    330e:	8b 81       	ldd	r24, Y+3	; 0x03
    3310:	9c 81       	ldd	r25, Y+4	; 0x04
    3312:	91 83       	std	Z+1, r25	; 0x01
    3314:	80 83       	st	Z, r24
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    3316:	0f b6       	in	r0, 0x3f	; 63
    3318:	f8 94       	cli
    331a:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    331c:	80 91 a2 07 	lds	r24, 0x07A2
    3320:	8f 5f       	subi	r24, 0xFF	; 255
    3322:	80 93 a2 07 	sts	0x07A2, r24
			if( pxCurrentTCB == NULL )
    3326:	80 91 9f 07 	lds	r24, 0x079F
    332a:	90 91 a0 07 	lds	r25, 0x07A0
    332e:	00 97       	sbiw	r24, 0x00	; 0
    3330:	69 f4       	brne	.+26     	; 0x334c <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    3332:	8b 81       	ldd	r24, Y+3	; 0x03
    3334:	9c 81       	ldd	r25, Y+4	; 0x04
    3336:	90 93 a0 07 	sts	0x07A0, r25
    333a:	80 93 9f 07 	sts	0x079F, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    333e:	80 91 a2 07 	lds	r24, 0x07A2
    3342:	81 30       	cpi	r24, 0x01	; 1
    3344:	a9 f4       	brne	.+42     	; 0x3370 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    3346:	0e 94 ca 1f 	call	0x3f94	; 0x3f94 <prvInitialiseTaskLists>
    334a:	12 c0       	rjmp	.+36     	; 0x3370 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    334c:	80 91 a6 07 	lds	r24, 0x07A6
    3350:	88 23       	and	r24, r24
    3352:	71 f4       	brne	.+28     	; 0x3370 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    3354:	e0 91 9f 07 	lds	r30, 0x079F
    3358:	f0 91 a0 07 	lds	r31, 0x07A0
    335c:	96 89       	ldd	r25, Z+22	; 0x16
    335e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3360:	89 17       	cp	r24, r25
    3362:	30 f0       	brcs	.+12     	; 0x3370 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    3364:	8b 81       	ldd	r24, Y+3	; 0x03
    3366:	9c 81       	ldd	r25, Y+4	; 0x04
    3368:	90 93 a0 07 	sts	0x07A0, r25
    336c:	80 93 9f 07 	sts	0x079F, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    3370:	80 91 aa 07 	lds	r24, 0x07AA
    3374:	8f 5f       	subi	r24, 0xFF	; 255
    3376:	80 93 aa 07 	sts	0x07AA, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    337a:	eb 81       	ldd	r30, Y+3	; 0x03
    337c:	fc 81       	ldd	r31, Y+4	; 0x04
    337e:	96 89       	ldd	r25, Z+22	; 0x16
    3380:	80 91 a5 07 	lds	r24, 0x07A5
    3384:	89 17       	cp	r24, r25
    3386:	28 f4       	brcc	.+10     	; 0x3392 <xTaskGenericCreate+0x13a>
    3388:	eb 81       	ldd	r30, Y+3	; 0x03
    338a:	fc 81       	ldd	r31, Y+4	; 0x04
    338c:	86 89       	ldd	r24, Z+22	; 0x16
    338e:	80 93 a5 07 	sts	0x07A5, r24
    3392:	eb 81       	ldd	r30, Y+3	; 0x03
    3394:	fc 81       	ldd	r31, Y+4	; 0x04
    3396:	86 89       	ldd	r24, Z+22	; 0x16
    3398:	28 2f       	mov	r18, r24
    339a:	30 e0       	ldi	r19, 0x00	; 0
    339c:	c9 01       	movw	r24, r18
    339e:	88 0f       	add	r24, r24
    33a0:	99 1f       	adc	r25, r25
    33a2:	88 0f       	add	r24, r24
    33a4:	99 1f       	adc	r25, r25
    33a6:	88 0f       	add	r24, r24
    33a8:	99 1f       	adc	r25, r25
    33aa:	82 0f       	add	r24, r18
    33ac:	93 1f       	adc	r25, r19
    33ae:	ac 01       	movw	r20, r24
    33b0:	44 55       	subi	r20, 0x54	; 84
    33b2:	58 4f       	sbci	r21, 0xF8	; 248
    33b4:	8b 81       	ldd	r24, Y+3	; 0x03
    33b6:	9c 81       	ldd	r25, Y+4	; 0x04
    33b8:	9c 01       	movw	r18, r24
    33ba:	2e 5f       	subi	r18, 0xFE	; 254
    33bc:	3f 4f       	sbci	r19, 0xFF	; 255
    33be:	ca 01       	movw	r24, r20
    33c0:	b9 01       	movw	r22, r18
    33c2:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsertEnd>

			xReturn = pdPASS;
    33c6:	81 e0       	ldi	r24, 0x01	; 1
    33c8:	8d 83       	std	Y+5, r24	; 0x05
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    33ca:	0f 90       	pop	r0
    33cc:	0f be       	out	0x3f, r0	; 63
    33ce:	02 c0       	rjmp	.+4      	; 0x33d4 <xTaskGenericCreate+0x17c>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    33d0:	8f ef       	ldi	r24, 0xFF	; 255
    33d2:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    33d4:	8d 81       	ldd	r24, Y+5	; 0x05
    33d6:	81 30       	cpi	r24, 0x01	; 1
    33d8:	71 f4       	brne	.+28     	; 0x33f6 <xTaskGenericCreate+0x19e>
	{
		if( xSchedulerRunning != pdFALSE )
    33da:	80 91 a6 07 	lds	r24, 0x07A6
    33de:	88 23       	and	r24, r24
    33e0:	51 f0       	breq	.+20     	; 0x33f6 <xTaskGenericCreate+0x19e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    33e2:	e0 91 9f 07 	lds	r30, 0x079F
    33e6:	f0 91 a0 07 	lds	r31, 0x07A0
    33ea:	96 89       	ldd	r25, Z+22	; 0x16
    33ec:	8e 85       	ldd	r24, Y+14	; 0x0e
    33ee:	98 17       	cp	r25, r24
    33f0:	10 f4       	brcc	.+4      	; 0x33f6 <xTaskGenericCreate+0x19e>
			{
				taskYIELD_IF_USING_PREEMPTION();
    33f2:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    33f6:	8d 81       	ldd	r24, Y+5	; 0x05
}
    33f8:	64 96       	adiw	r28, 0x14	; 20
    33fa:	0f b6       	in	r0, 0x3f	; 63
    33fc:	f8 94       	cli
    33fe:	de bf       	out	0x3e, r29	; 62
    3400:	0f be       	out	0x3f, r0	; 63
    3402:	cd bf       	out	0x3d, r28	; 61
    3404:	cf 91       	pop	r28
    3406:	df 91       	pop	r29
    3408:	1f 91       	pop	r17
    340a:	0f 91       	pop	r16
    340c:	ff 90       	pop	r15
    340e:	ef 90       	pop	r14
    3410:	df 90       	pop	r13
    3412:	cf 90       	pop	r12
    3414:	bf 90       	pop	r11
    3416:	af 90       	pop	r10
    3418:	08 95       	ret

0000341a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    341a:	df 93       	push	r29
    341c:	cf 93       	push	r28
    341e:	00 d0       	rcall	.+0      	; 0x3420 <vTaskDelete+0x6>
    3420:	00 d0       	rcall	.+0      	; 0x3422 <vTaskDelete+0x8>
    3422:	00 d0       	rcall	.+0      	; 0x3424 <vTaskDelete+0xa>
    3424:	cd b7       	in	r28, 0x3d	; 61
    3426:	de b7       	in	r29, 0x3e	; 62
    3428:	9c 83       	std	Y+4, r25	; 0x04
    342a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    342c:	0f b6       	in	r0, 0x3f	; 63
    342e:	f8 94       	cli
    3430:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3432:	8b 81       	ldd	r24, Y+3	; 0x03
    3434:	9c 81       	ldd	r25, Y+4	; 0x04
    3436:	00 97       	sbiw	r24, 0x00	; 0
    3438:	39 f4       	brne	.+14     	; 0x3448 <vTaskDelete+0x2e>
    343a:	80 91 9f 07 	lds	r24, 0x079F
    343e:	90 91 a0 07 	lds	r25, 0x07A0
    3442:	9e 83       	std	Y+6, r25	; 0x06
    3444:	8d 83       	std	Y+5, r24	; 0x05
    3446:	04 c0       	rjmp	.+8      	; 0x3450 <vTaskDelete+0x36>
    3448:	8b 81       	ldd	r24, Y+3	; 0x03
    344a:	9c 81       	ldd	r25, Y+4	; 0x04
    344c:	9e 83       	std	Y+6, r25	; 0x06
    344e:	8d 83       	std	Y+5, r24	; 0x05
    3450:	8d 81       	ldd	r24, Y+5	; 0x05
    3452:	9e 81       	ldd	r25, Y+6	; 0x06
    3454:	9a 83       	std	Y+2, r25	; 0x02
    3456:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3458:	89 81       	ldd	r24, Y+1	; 0x01
    345a:	9a 81       	ldd	r25, Y+2	; 0x02
    345c:	02 96       	adiw	r24, 0x02	; 2
    345e:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3462:	e9 81       	ldd	r30, Y+1	; 0x01
    3464:	fa 81       	ldd	r31, Y+2	; 0x02
    3466:	84 89       	ldd	r24, Z+20	; 0x14
    3468:	95 89       	ldd	r25, Z+21	; 0x15
    346a:	00 97       	sbiw	r24, 0x00	; 0
    346c:	29 f0       	breq	.+10     	; 0x3478 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    346e:	89 81       	ldd	r24, Y+1	; 0x01
    3470:	9a 81       	ldd	r25, Y+2	; 0x02
    3472:	0c 96       	adiw	r24, 0x0c	; 12
    3474:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    3478:	89 81       	ldd	r24, Y+1	; 0x01
    347a:	9a 81       	ldd	r25, Y+2	; 0x02
    347c:	9c 01       	movw	r18, r24
    347e:	2e 5f       	subi	r18, 0xFE	; 254
    3480:	3f 4f       	sbci	r19, 0xFF	; 255
    3482:	8f ee       	ldi	r24, 0xEF	; 239
    3484:	97 e0       	ldi	r25, 0x07	; 7
    3486:	b9 01       	movw	r22, r18
    3488:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    348c:	80 91 a1 07 	lds	r24, 0x07A1
    3490:	8f 5f       	subi	r24, 0xFF	; 255
    3492:	80 93 a1 07 	sts	0x07A1, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    3496:	80 91 aa 07 	lds	r24, 0x07AA
    349a:	8f 5f       	subi	r24, 0xFF	; 255
    349c:	80 93 aa 07 	sts	0x07AA, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    34a0:	0f 90       	pop	r0
    34a2:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    34a4:	80 91 a6 07 	lds	r24, 0x07A6
    34a8:	88 23       	and	r24, r24
    34aa:	99 f0       	breq	.+38     	; 0x34d2 <vTaskDelete+0xb8>
		{
			if( pxTCB == pxCurrentTCB )
    34ac:	20 91 9f 07 	lds	r18, 0x079F
    34b0:	30 91 a0 07 	lds	r19, 0x07A0
    34b4:	89 81       	ldd	r24, Y+1	; 0x01
    34b6:	9a 81       	ldd	r25, Y+2	; 0x02
    34b8:	82 17       	cp	r24, r18
    34ba:	93 07       	cpc	r25, r19
    34bc:	19 f4       	brne	.+6      	; 0x34c4 <vTaskDelete+0xaa>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    34be:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vPortYield>
    34c2:	07 c0       	rjmp	.+14     	; 0x34d2 <vTaskDelete+0xb8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    34c4:	0f b6       	in	r0, 0x3f	; 63
    34c6:	f8 94       	cli
    34c8:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    34ca:	0e 94 e9 20 	call	0x41d2	; 0x41d2 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    34ce:	0f 90       	pop	r0
    34d0:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    34d2:	26 96       	adiw	r28, 0x06	; 6
    34d4:	0f b6       	in	r0, 0x3f	; 63
    34d6:	f8 94       	cli
    34d8:	de bf       	out	0x3e, r29	; 62
    34da:	0f be       	out	0x3f, r0	; 63
    34dc:	cd bf       	out	0x3d, r28	; 61
    34de:	cf 91       	pop	r28
    34e0:	df 91       	pop	r29
    34e2:	08 95       	ret

000034e4 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    34e4:	df 93       	push	r29
    34e6:	cf 93       	push	r28
    34e8:	cd b7       	in	r28, 0x3d	; 61
    34ea:	de b7       	in	r29, 0x3e	; 62
    34ec:	2a 97       	sbiw	r28, 0x0a	; 10
    34ee:	0f b6       	in	r0, 0x3f	; 63
    34f0:	f8 94       	cli
    34f2:	de bf       	out	0x3e, r29	; 62
    34f4:	0f be       	out	0x3f, r0	; 63
    34f6:	cd bf       	out	0x3d, r28	; 61
    34f8:	98 87       	std	Y+8, r25	; 0x08
    34fa:	8f 83       	std	Y+7, r24	; 0x07
    34fc:	7a 87       	std	Y+10, r23	; 0x0a
    34fe:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3500:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    3502:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3506:	80 91 a3 07 	lds	r24, 0x07A3
    350a:	90 91 a4 07 	lds	r25, 0x07A4
    350e:	9a 83       	std	Y+2, r25	; 0x02
    3510:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3512:	ef 81       	ldd	r30, Y+7	; 0x07
    3514:	f8 85       	ldd	r31, Y+8	; 0x08
    3516:	20 81       	ld	r18, Z
    3518:	31 81       	ldd	r19, Z+1	; 0x01
    351a:	89 85       	ldd	r24, Y+9	; 0x09
    351c:	9a 85       	ldd	r25, Y+10	; 0x0a
    351e:	82 0f       	add	r24, r18
    3520:	93 1f       	adc	r25, r19
    3522:	9e 83       	std	Y+6, r25	; 0x06
    3524:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    3526:	ef 81       	ldd	r30, Y+7	; 0x07
    3528:	f8 85       	ldd	r31, Y+8	; 0x08
    352a:	20 81       	ld	r18, Z
    352c:	31 81       	ldd	r19, Z+1	; 0x01
    352e:	89 81       	ldd	r24, Y+1	; 0x01
    3530:	9a 81       	ldd	r25, Y+2	; 0x02
    3532:	82 17       	cp	r24, r18
    3534:	93 07       	cpc	r25, r19
    3536:	98 f4       	brcc	.+38     	; 0x355e <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3538:	ef 81       	ldd	r30, Y+7	; 0x07
    353a:	f8 85       	ldd	r31, Y+8	; 0x08
    353c:	20 81       	ld	r18, Z
    353e:	31 81       	ldd	r19, Z+1	; 0x01
    3540:	8d 81       	ldd	r24, Y+5	; 0x05
    3542:	9e 81       	ldd	r25, Y+6	; 0x06
    3544:	82 17       	cp	r24, r18
    3546:	93 07       	cpc	r25, r19
    3548:	e0 f4       	brcc	.+56     	; 0x3582 <vTaskDelayUntil+0x9e>
    354a:	2d 81       	ldd	r18, Y+5	; 0x05
    354c:	3e 81       	ldd	r19, Y+6	; 0x06
    354e:	89 81       	ldd	r24, Y+1	; 0x01
    3550:	9a 81       	ldd	r25, Y+2	; 0x02
    3552:	82 17       	cp	r24, r18
    3554:	93 07       	cpc	r25, r19
    3556:	a8 f4       	brcc	.+42     	; 0x3582 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3558:	81 e0       	ldi	r24, 0x01	; 1
    355a:	8b 83       	std	Y+3, r24	; 0x03
    355c:	12 c0       	rjmp	.+36     	; 0x3582 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    355e:	ef 81       	ldd	r30, Y+7	; 0x07
    3560:	f8 85       	ldd	r31, Y+8	; 0x08
    3562:	20 81       	ld	r18, Z
    3564:	31 81       	ldd	r19, Z+1	; 0x01
    3566:	8d 81       	ldd	r24, Y+5	; 0x05
    3568:	9e 81       	ldd	r25, Y+6	; 0x06
    356a:	82 17       	cp	r24, r18
    356c:	93 07       	cpc	r25, r19
    356e:	38 f0       	brcs	.+14     	; 0x357e <vTaskDelayUntil+0x9a>
    3570:	2d 81       	ldd	r18, Y+5	; 0x05
    3572:	3e 81       	ldd	r19, Y+6	; 0x06
    3574:	89 81       	ldd	r24, Y+1	; 0x01
    3576:	9a 81       	ldd	r25, Y+2	; 0x02
    3578:	82 17       	cp	r24, r18
    357a:	93 07       	cpc	r25, r19
    357c:	10 f4       	brcc	.+4      	; 0x3582 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    357e:	81 e0       	ldi	r24, 0x01	; 1
    3580:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    3582:	ef 81       	ldd	r30, Y+7	; 0x07
    3584:	f8 85       	ldd	r31, Y+8	; 0x08
    3586:	8d 81       	ldd	r24, Y+5	; 0x05
    3588:	9e 81       	ldd	r25, Y+6	; 0x06
    358a:	91 83       	std	Z+1, r25	; 0x01
    358c:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    358e:	8b 81       	ldd	r24, Y+3	; 0x03
    3590:	88 23       	and	r24, r24
    3592:	59 f0       	breq	.+22     	; 0x35aa <vTaskDelayUntil+0xc6>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3594:	80 91 9f 07 	lds	r24, 0x079F
    3598:	90 91 a0 07 	lds	r25, 0x07A0
    359c:	02 96       	adiw	r24, 0x02	; 2
    359e:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    35a2:	8d 81       	ldd	r24, Y+5	; 0x05
    35a4:	9e 81       	ldd	r25, Y+6	; 0x06
    35a6:	0e 94 46 20 	call	0x408c	; 0x408c <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    35aa:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <xTaskResumeAll>
    35ae:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    35b0:	8c 81       	ldd	r24, Y+4	; 0x04
    35b2:	88 23       	and	r24, r24
    35b4:	11 f4       	brne	.+4      	; 0x35ba <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    35b6:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    35ba:	2a 96       	adiw	r28, 0x0a	; 10
    35bc:	0f b6       	in	r0, 0x3f	; 63
    35be:	f8 94       	cli
    35c0:	de bf       	out	0x3e, r29	; 62
    35c2:	0f be       	out	0x3f, r0	; 63
    35c4:	cd bf       	out	0x3d, r28	; 61
    35c6:	cf 91       	pop	r28
    35c8:	df 91       	pop	r29
    35ca:	08 95       	ret

000035cc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    35cc:	df 93       	push	r29
    35ce:	cf 93       	push	r28
    35d0:	00 d0       	rcall	.+0      	; 0x35d2 <vTaskDelay+0x6>
    35d2:	00 d0       	rcall	.+0      	; 0x35d4 <vTaskDelay+0x8>
    35d4:	0f 92       	push	r0
    35d6:	cd b7       	in	r28, 0x3d	; 61
    35d8:	de b7       	in	r29, 0x3e	; 62
    35da:	9d 83       	std	Y+5, r25	; 0x05
    35dc:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    35de:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    35e0:	8c 81       	ldd	r24, Y+4	; 0x04
    35e2:	9d 81       	ldd	r25, Y+5	; 0x05
    35e4:	00 97       	sbiw	r24, 0x00	; 0
    35e6:	d1 f0       	breq	.+52     	; 0x361c <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    35e8:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    35ec:	20 91 a3 07 	lds	r18, 0x07A3
    35f0:	30 91 a4 07 	lds	r19, 0x07A4
    35f4:	8c 81       	ldd	r24, Y+4	; 0x04
    35f6:	9d 81       	ldd	r25, Y+5	; 0x05
    35f8:	82 0f       	add	r24, r18
    35fa:	93 1f       	adc	r25, r19
    35fc:	9b 83       	std	Y+3, r25	; 0x03
    35fe:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3600:	80 91 9f 07 	lds	r24, 0x079F
    3604:	90 91 a0 07 	lds	r25, 0x07A0
    3608:	02 96       	adiw	r24, 0x02	; 2
    360a:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    360e:	8a 81       	ldd	r24, Y+2	; 0x02
    3610:	9b 81       	ldd	r25, Y+3	; 0x03
    3612:	0e 94 46 20 	call	0x408c	; 0x408c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3616:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <xTaskResumeAll>
    361a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    361c:	89 81       	ldd	r24, Y+1	; 0x01
    361e:	88 23       	and	r24, r24
    3620:	11 f4       	brne	.+4      	; 0x3626 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    3622:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3626:	0f 90       	pop	r0
    3628:	0f 90       	pop	r0
    362a:	0f 90       	pop	r0
    362c:	0f 90       	pop	r0
    362e:	0f 90       	pop	r0
    3630:	cf 91       	pop	r28
    3632:	df 91       	pop	r29
    3634:	08 95       	ret

00003636 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3636:	af 92       	push	r10
    3638:	bf 92       	push	r11
    363a:	cf 92       	push	r12
    363c:	df 92       	push	r13
    363e:	ef 92       	push	r14
    3640:	ff 92       	push	r15
    3642:	0f 93       	push	r16
    3644:	df 93       	push	r29
    3646:	cf 93       	push	r28
    3648:	0f 92       	push	r0
    364a:	cd b7       	in	r28, 0x3d	; 61
    364c:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    364e:	87 e4       	ldi	r24, 0x47	; 71
    3650:	9f e1       	ldi	r25, 0x1F	; 31
    3652:	28 e7       	ldi	r18, 0x78	; 120
    3654:	30 e0       	ldi	r19, 0x00	; 0
    3656:	b9 01       	movw	r22, r18
    3658:	45 e5       	ldi	r20, 0x55	; 85
    365a:	50 e0       	ldi	r21, 0x00	; 0
    365c:	20 e0       	ldi	r18, 0x00	; 0
    365e:	30 e0       	ldi	r19, 0x00	; 0
    3660:	00 e0       	ldi	r16, 0x00	; 0
    3662:	ee 24       	eor	r14, r14
    3664:	ff 24       	eor	r15, r15
    3666:	cc 24       	eor	r12, r12
    3668:	dd 24       	eor	r13, r13
    366a:	aa 24       	eor	r10, r10
    366c:	bb 24       	eor	r11, r11
    366e:	0e 94 2c 19 	call	0x3258	; 0x3258 <xTaskGenericCreate>
    3672:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    3674:	89 81       	ldd	r24, Y+1	; 0x01
    3676:	81 30       	cpi	r24, 0x01	; 1
    3678:	51 f4       	brne	.+20     	; 0x368e <vTaskStartScheduler+0x58>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    367a:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    367c:	81 e0       	ldi	r24, 0x01	; 1
    367e:	80 93 a6 07 	sts	0x07A6, r24
		xTickCount = ( TickType_t ) 0U;
    3682:	10 92 a4 07 	sts	0x07A4, r1
    3686:	10 92 a3 07 	sts	0x07A3, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    368a:	0e 94 ac 10 	call	0x2158	; 0x2158 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    368e:	0f 90       	pop	r0
    3690:	cf 91       	pop	r28
    3692:	df 91       	pop	r29
    3694:	0f 91       	pop	r16
    3696:	ff 90       	pop	r15
    3698:	ef 90       	pop	r14
    369a:	df 90       	pop	r13
    369c:	cf 90       	pop	r12
    369e:	bf 90       	pop	r11
    36a0:	af 90       	pop	r10
    36a2:	08 95       	ret

000036a4 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    36a4:	df 93       	push	r29
    36a6:	cf 93       	push	r28
    36a8:	cd b7       	in	r28, 0x3d	; 61
    36aa:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    36ac:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    36ae:	10 92 a6 07 	sts	0x07A6, r1
	vPortEndScheduler();
    36b2:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <vPortEndScheduler>
}
    36b6:	cf 91       	pop	r28
    36b8:	df 91       	pop	r29
    36ba:	08 95       	ret

000036bc <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    36bc:	df 93       	push	r29
    36be:	cf 93       	push	r28
    36c0:	cd b7       	in	r28, 0x3d	; 61
    36c2:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    36c4:	80 91 ab 07 	lds	r24, 0x07AB
    36c8:	8f 5f       	subi	r24, 0xFF	; 255
    36ca:	80 93 ab 07 	sts	0x07AB, r24
}
    36ce:	cf 91       	pop	r28
    36d0:	df 91       	pop	r29
    36d2:	08 95       	ret

000036d4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    36d4:	df 93       	push	r29
    36d6:	cf 93       	push	r28
    36d8:	00 d0       	rcall	.+0      	; 0x36da <xTaskResumeAll+0x6>
    36da:	0f 92       	push	r0
    36dc:	cd b7       	in	r28, 0x3d	; 61
    36de:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    36e0:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    36e2:	0f b6       	in	r0, 0x3f	; 63
    36e4:	f8 94       	cli
    36e6:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    36e8:	80 91 ab 07 	lds	r24, 0x07AB
    36ec:	81 50       	subi	r24, 0x01	; 1
    36ee:	80 93 ab 07 	sts	0x07AB, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    36f2:	80 91 ab 07 	lds	r24, 0x07AB
    36f6:	88 23       	and	r24, r24
    36f8:	09 f0       	breq	.+2      	; 0x36fc <xTaskResumeAll+0x28>
    36fa:	6d c0       	rjmp	.+218    	; 0x37d6 <xTaskResumeAll+0x102>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    36fc:	80 91 a2 07 	lds	r24, 0x07A2
    3700:	88 23       	and	r24, r24
    3702:	09 f4       	brne	.+2      	; 0x3706 <xTaskResumeAll+0x32>
    3704:	68 c0       	rjmp	.+208    	; 0x37d6 <xTaskResumeAll+0x102>
    3706:	45 c0       	rjmp	.+138    	; 0x3792 <xTaskResumeAll+0xbe>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    3708:	e0 91 eb 07 	lds	r30, 0x07EB
    370c:	f0 91 ec 07 	lds	r31, 0x07EC
    3710:	86 81       	ldd	r24, Z+6	; 0x06
    3712:	97 81       	ldd	r25, Z+7	; 0x07
    3714:	9b 83       	std	Y+3, r25	; 0x03
    3716:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3718:	8a 81       	ldd	r24, Y+2	; 0x02
    371a:	9b 81       	ldd	r25, Y+3	; 0x03
    371c:	0c 96       	adiw	r24, 0x0c	; 12
    371e:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3722:	8a 81       	ldd	r24, Y+2	; 0x02
    3724:	9b 81       	ldd	r25, Y+3	; 0x03
    3726:	02 96       	adiw	r24, 0x02	; 2
    3728:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    372c:	ea 81       	ldd	r30, Y+2	; 0x02
    372e:	fb 81       	ldd	r31, Y+3	; 0x03
    3730:	96 89       	ldd	r25, Z+22	; 0x16
    3732:	80 91 a5 07 	lds	r24, 0x07A5
    3736:	89 17       	cp	r24, r25
    3738:	28 f4       	brcc	.+10     	; 0x3744 <xTaskResumeAll+0x70>
    373a:	ea 81       	ldd	r30, Y+2	; 0x02
    373c:	fb 81       	ldd	r31, Y+3	; 0x03
    373e:	86 89       	ldd	r24, Z+22	; 0x16
    3740:	80 93 a5 07 	sts	0x07A5, r24
    3744:	ea 81       	ldd	r30, Y+2	; 0x02
    3746:	fb 81       	ldd	r31, Y+3	; 0x03
    3748:	86 89       	ldd	r24, Z+22	; 0x16
    374a:	28 2f       	mov	r18, r24
    374c:	30 e0       	ldi	r19, 0x00	; 0
    374e:	c9 01       	movw	r24, r18
    3750:	88 0f       	add	r24, r24
    3752:	99 1f       	adc	r25, r25
    3754:	88 0f       	add	r24, r24
    3756:	99 1f       	adc	r25, r25
    3758:	88 0f       	add	r24, r24
    375a:	99 1f       	adc	r25, r25
    375c:	82 0f       	add	r24, r18
    375e:	93 1f       	adc	r25, r19
    3760:	ac 01       	movw	r20, r24
    3762:	44 55       	subi	r20, 0x54	; 84
    3764:	58 4f       	sbci	r21, 0xF8	; 248
    3766:	8a 81       	ldd	r24, Y+2	; 0x02
    3768:	9b 81       	ldd	r25, Y+3	; 0x03
    376a:	9c 01       	movw	r18, r24
    376c:	2e 5f       	subi	r18, 0xFE	; 254
    376e:	3f 4f       	sbci	r19, 0xFF	; 255
    3770:	ca 01       	movw	r24, r20
    3772:	b9 01       	movw	r22, r18
    3774:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3778:	ea 81       	ldd	r30, Y+2	; 0x02
    377a:	fb 81       	ldd	r31, Y+3	; 0x03
    377c:	96 89       	ldd	r25, Z+22	; 0x16
    377e:	e0 91 9f 07 	lds	r30, 0x079F
    3782:	f0 91 a0 07 	lds	r31, 0x07A0
    3786:	86 89       	ldd	r24, Z+22	; 0x16
    3788:	98 17       	cp	r25, r24
    378a:	18 f0       	brcs	.+6      	; 0x3792 <xTaskResumeAll+0xbe>
					{
						xYieldPending = pdTRUE;
    378c:	81 e0       	ldi	r24, 0x01	; 1
    378e:	80 93 a8 07 	sts	0x07A8, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3792:	80 91 e6 07 	lds	r24, 0x07E6
    3796:	88 23       	and	r24, r24
    3798:	09 f0       	breq	.+2      	; 0x379c <xTaskResumeAll+0xc8>
    379a:	b6 cf       	rjmp	.-148    	; 0x3708 <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    379c:	80 91 a7 07 	lds	r24, 0x07A7
    37a0:	88 23       	and	r24, r24
    37a2:	89 f0       	breq	.+34     	; 0x37c6 <xTaskResumeAll+0xf2>
    37a4:	0c c0       	rjmp	.+24     	; 0x37be <xTaskResumeAll+0xea>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    37a6:	0e 94 29 1c 	call	0x3852	; 0x3852 <xTaskIncrementTick>
    37aa:	88 23       	and	r24, r24
    37ac:	19 f0       	breq	.+6      	; 0x37b4 <xTaskResumeAll+0xe0>
						{
							xYieldPending = pdTRUE;
    37ae:	81 e0       	ldi	r24, 0x01	; 1
    37b0:	80 93 a8 07 	sts	0x07A8, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    37b4:	80 91 a7 07 	lds	r24, 0x07A7
    37b8:	81 50       	subi	r24, 0x01	; 1
    37ba:	80 93 a7 07 	sts	0x07A7, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    37be:	80 91 a7 07 	lds	r24, 0x07A7
    37c2:	88 23       	and	r24, r24
    37c4:	81 f7       	brne	.-32     	; 0x37a6 <xTaskResumeAll+0xd2>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    37c6:	80 91 a8 07 	lds	r24, 0x07A8
    37ca:	81 30       	cpi	r24, 0x01	; 1
    37cc:	21 f4       	brne	.+8      	; 0x37d6 <xTaskResumeAll+0x102>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    37ce:	81 e0       	ldi	r24, 0x01	; 1
    37d0:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    37d2:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    37d6:	0f 90       	pop	r0
    37d8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    37da:	89 81       	ldd	r24, Y+1	; 0x01
}
    37dc:	0f 90       	pop	r0
    37de:	0f 90       	pop	r0
    37e0:	0f 90       	pop	r0
    37e2:	cf 91       	pop	r28
    37e4:	df 91       	pop	r29
    37e6:	08 95       	ret

000037e8 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    37e8:	df 93       	push	r29
    37ea:	cf 93       	push	r28
    37ec:	00 d0       	rcall	.+0      	; 0x37ee <xTaskGetTickCount+0x6>
    37ee:	cd b7       	in	r28, 0x3d	; 61
    37f0:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    37f2:	0f b6       	in	r0, 0x3f	; 63
    37f4:	f8 94       	cli
    37f6:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    37f8:	80 91 a3 07 	lds	r24, 0x07A3
    37fc:	90 91 a4 07 	lds	r25, 0x07A4
    3800:	9a 83       	std	Y+2, r25	; 0x02
    3802:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3804:	0f 90       	pop	r0
    3806:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3808:	89 81       	ldd	r24, Y+1	; 0x01
    380a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    380c:	0f 90       	pop	r0
    380e:	0f 90       	pop	r0
    3810:	cf 91       	pop	r28
    3812:	df 91       	pop	r29
    3814:	08 95       	ret

00003816 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3816:	df 93       	push	r29
    3818:	cf 93       	push	r28
    381a:	00 d0       	rcall	.+0      	; 0x381c <xTaskGetTickCountFromISR+0x6>
    381c:	0f 92       	push	r0
    381e:	cd b7       	in	r28, 0x3d	; 61
    3820:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3822:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    3824:	80 91 a3 07 	lds	r24, 0x07A3
    3828:	90 91 a4 07 	lds	r25, 0x07A4
    382c:	9b 83       	std	Y+3, r25	; 0x03
    382e:	8a 83       	std	Y+2, r24	; 0x02
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3830:	8a 81       	ldd	r24, Y+2	; 0x02
    3832:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3834:	0f 90       	pop	r0
    3836:	0f 90       	pop	r0
    3838:	0f 90       	pop	r0
    383a:	cf 91       	pop	r28
    383c:	df 91       	pop	r29
    383e:	08 95       	ret

00003840 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3840:	df 93       	push	r29
    3842:	cf 93       	push	r28
    3844:	cd b7       	in	r28, 0x3d	; 61
    3846:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    3848:	80 91 a2 07 	lds	r24, 0x07A2
}
    384c:	cf 91       	pop	r28
    384e:	df 91       	pop	r29
    3850:	08 95       	ret

00003852 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3852:	df 93       	push	r29
    3854:	cf 93       	push	r28
    3856:	cd b7       	in	r28, 0x3d	; 61
    3858:	de b7       	in	r29, 0x3e	; 62
    385a:	29 97       	sbiw	r28, 0x09	; 9
    385c:	0f b6       	in	r0, 0x3f	; 63
    385e:	f8 94       	cli
    3860:	de bf       	out	0x3e, r29	; 62
    3862:	0f be       	out	0x3f, r0	; 63
    3864:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    3866:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3868:	80 91 ab 07 	lds	r24, 0x07AB
    386c:	88 23       	and	r24, r24
    386e:	09 f0       	breq	.+2      	; 0x3872 <xTaskIncrementTick+0x20>
    3870:	c2 c0       	rjmp	.+388    	; 0x39f6 <xTaskIncrementTick+0x1a4>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    3872:	80 91 a3 07 	lds	r24, 0x07A3
    3876:	90 91 a4 07 	lds	r25, 0x07A4
    387a:	01 96       	adiw	r24, 0x01	; 1
    387c:	90 93 a4 07 	sts	0x07A4, r25
    3880:	80 93 a3 07 	sts	0x07A3, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3884:	80 91 a3 07 	lds	r24, 0x07A3
    3888:	90 91 a4 07 	lds	r25, 0x07A4
    388c:	9c 83       	std	Y+4, r25	; 0x04
    388e:	8b 83       	std	Y+3, r24	; 0x03

			if( xConstTickCount == ( TickType_t ) 0U )
    3890:	8b 81       	ldd	r24, Y+3	; 0x03
    3892:	9c 81       	ldd	r25, Y+4	; 0x04
    3894:	00 97       	sbiw	r24, 0x00	; 0
    3896:	d9 f4       	brne	.+54     	; 0x38ce <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    3898:	80 91 e2 07 	lds	r24, 0x07E2
    389c:	90 91 e3 07 	lds	r25, 0x07E3
    38a0:	9a 83       	std	Y+2, r25	; 0x02
    38a2:	89 83       	std	Y+1, r24	; 0x01
    38a4:	80 91 e4 07 	lds	r24, 0x07E4
    38a8:	90 91 e5 07 	lds	r25, 0x07E5
    38ac:	90 93 e3 07 	sts	0x07E3, r25
    38b0:	80 93 e2 07 	sts	0x07E2, r24
    38b4:	89 81       	ldd	r24, Y+1	; 0x01
    38b6:	9a 81       	ldd	r25, Y+2	; 0x02
    38b8:	90 93 e5 07 	sts	0x07E5, r25
    38bc:	80 93 e4 07 	sts	0x07E4, r24
    38c0:	80 91 a9 07 	lds	r24, 0x07A9
    38c4:	8f 5f       	subi	r24, 0xFF	; 255
    38c6:	80 93 a9 07 	sts	0x07A9, r24
    38ca:	0e 94 e9 20 	call	0x41d2	; 0x41d2 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    38ce:	20 91 7d 01 	lds	r18, 0x017D
    38d2:	30 91 7e 01 	lds	r19, 0x017E
    38d6:	8b 81       	ldd	r24, Y+3	; 0x03
    38d8:	9c 81       	ldd	r25, Y+4	; 0x04
    38da:	82 17       	cp	r24, r18
    38dc:	93 07       	cpc	r25, r19
    38de:	08 f4       	brcc	.+2      	; 0x38e2 <xTaskIncrementTick+0x90>
    38e0:	71 c0       	rjmp	.+226    	; 0x39c4 <xTaskIncrementTick+0x172>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    38e2:	e0 91 e2 07 	lds	r30, 0x07E2
    38e6:	f0 91 e3 07 	lds	r31, 0x07E3
    38ea:	80 81       	ld	r24, Z
    38ec:	88 23       	and	r24, r24
    38ee:	39 f4       	brne	.+14     	; 0x38fe <xTaskIncrementTick+0xac>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    38f0:	8f ef       	ldi	r24, 0xFF	; 255
    38f2:	9f ef       	ldi	r25, 0xFF	; 255
    38f4:	90 93 7e 01 	sts	0x017E, r25
    38f8:	80 93 7d 01 	sts	0x017D, r24
    38fc:	63 c0       	rjmp	.+198    	; 0x39c4 <xTaskIncrementTick+0x172>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    38fe:	e0 91 e2 07 	lds	r30, 0x07E2
    3902:	f0 91 e3 07 	lds	r31, 0x07E3
    3906:	05 80       	ldd	r0, Z+5	; 0x05
    3908:	f6 81       	ldd	r31, Z+6	; 0x06
    390a:	e0 2d       	mov	r30, r0
    390c:	86 81       	ldd	r24, Z+6	; 0x06
    390e:	97 81       	ldd	r25, Z+7	; 0x07
    3910:	99 87       	std	Y+9, r25	; 0x09
    3912:	88 87       	std	Y+8, r24	; 0x08
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    3914:	e8 85       	ldd	r30, Y+8	; 0x08
    3916:	f9 85       	ldd	r31, Y+9	; 0x09
    3918:	82 81       	ldd	r24, Z+2	; 0x02
    391a:	93 81       	ldd	r25, Z+3	; 0x03
    391c:	9f 83       	std	Y+7, r25	; 0x07
    391e:	8e 83       	std	Y+6, r24	; 0x06

						if( xConstTickCount < xItemValue )
    3920:	2b 81       	ldd	r18, Y+3	; 0x03
    3922:	3c 81       	ldd	r19, Y+4	; 0x04
    3924:	8e 81       	ldd	r24, Y+6	; 0x06
    3926:	9f 81       	ldd	r25, Y+7	; 0x07
    3928:	28 17       	cp	r18, r24
    392a:	39 07       	cpc	r19, r25
    392c:	38 f4       	brcc	.+14     	; 0x393c <xTaskIncrementTick+0xea>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    392e:	8e 81       	ldd	r24, Y+6	; 0x06
    3930:	9f 81       	ldd	r25, Y+7	; 0x07
    3932:	90 93 7e 01 	sts	0x017E, r25
    3936:	80 93 7d 01 	sts	0x017D, r24
    393a:	44 c0       	rjmp	.+136    	; 0x39c4 <xTaskIncrementTick+0x172>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    393c:	88 85       	ldd	r24, Y+8	; 0x08
    393e:	99 85       	ldd	r25, Y+9	; 0x09
    3940:	02 96       	adiw	r24, 0x02	; 2
    3942:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3946:	e8 85       	ldd	r30, Y+8	; 0x08
    3948:	f9 85       	ldd	r31, Y+9	; 0x09
    394a:	84 89       	ldd	r24, Z+20	; 0x14
    394c:	95 89       	ldd	r25, Z+21	; 0x15
    394e:	00 97       	sbiw	r24, 0x00	; 0
    3950:	29 f0       	breq	.+10     	; 0x395c <xTaskIncrementTick+0x10a>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3952:	88 85       	ldd	r24, Y+8	; 0x08
    3954:	99 85       	ldd	r25, Y+9	; 0x09
    3956:	0c 96       	adiw	r24, 0x0c	; 12
    3958:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    395c:	e8 85       	ldd	r30, Y+8	; 0x08
    395e:	f9 85       	ldd	r31, Y+9	; 0x09
    3960:	96 89       	ldd	r25, Z+22	; 0x16
    3962:	80 91 a5 07 	lds	r24, 0x07A5
    3966:	89 17       	cp	r24, r25
    3968:	28 f4       	brcc	.+10     	; 0x3974 <xTaskIncrementTick+0x122>
    396a:	e8 85       	ldd	r30, Y+8	; 0x08
    396c:	f9 85       	ldd	r31, Y+9	; 0x09
    396e:	86 89       	ldd	r24, Z+22	; 0x16
    3970:	80 93 a5 07 	sts	0x07A5, r24
    3974:	e8 85       	ldd	r30, Y+8	; 0x08
    3976:	f9 85       	ldd	r31, Y+9	; 0x09
    3978:	86 89       	ldd	r24, Z+22	; 0x16
    397a:	28 2f       	mov	r18, r24
    397c:	30 e0       	ldi	r19, 0x00	; 0
    397e:	c9 01       	movw	r24, r18
    3980:	88 0f       	add	r24, r24
    3982:	99 1f       	adc	r25, r25
    3984:	88 0f       	add	r24, r24
    3986:	99 1f       	adc	r25, r25
    3988:	88 0f       	add	r24, r24
    398a:	99 1f       	adc	r25, r25
    398c:	82 0f       	add	r24, r18
    398e:	93 1f       	adc	r25, r19
    3990:	ac 01       	movw	r20, r24
    3992:	44 55       	subi	r20, 0x54	; 84
    3994:	58 4f       	sbci	r21, 0xF8	; 248
    3996:	88 85       	ldd	r24, Y+8	; 0x08
    3998:	99 85       	ldd	r25, Y+9	; 0x09
    399a:	9c 01       	movw	r18, r24
    399c:	2e 5f       	subi	r18, 0xFE	; 254
    399e:	3f 4f       	sbci	r19, 0xFF	; 255
    39a0:	ca 01       	movw	r24, r20
    39a2:	b9 01       	movw	r22, r18
    39a4:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    39a8:	e8 85       	ldd	r30, Y+8	; 0x08
    39aa:	f9 85       	ldd	r31, Y+9	; 0x09
    39ac:	96 89       	ldd	r25, Z+22	; 0x16
    39ae:	e0 91 9f 07 	lds	r30, 0x079F
    39b2:	f0 91 a0 07 	lds	r31, 0x07A0
    39b6:	86 89       	ldd	r24, Z+22	; 0x16
    39b8:	98 17       	cp	r25, r24
    39ba:	08 f4       	brcc	.+2      	; 0x39be <xTaskIncrementTick+0x16c>
    39bc:	92 cf       	rjmp	.-220    	; 0x38e2 <xTaskIncrementTick+0x90>
							{
								xSwitchRequired = pdTRUE;
    39be:	81 e0       	ldi	r24, 0x01	; 1
    39c0:	8d 83       	std	Y+5, r24	; 0x05
    39c2:	8f cf       	rjmp	.-226    	; 0x38e2 <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    39c4:	e0 91 9f 07 	lds	r30, 0x079F
    39c8:	f0 91 a0 07 	lds	r31, 0x07A0
    39cc:	86 89       	ldd	r24, Z+22	; 0x16
    39ce:	28 2f       	mov	r18, r24
    39d0:	30 e0       	ldi	r19, 0x00	; 0
    39d2:	c9 01       	movw	r24, r18
    39d4:	88 0f       	add	r24, r24
    39d6:	99 1f       	adc	r25, r25
    39d8:	88 0f       	add	r24, r24
    39da:	99 1f       	adc	r25, r25
    39dc:	88 0f       	add	r24, r24
    39de:	99 1f       	adc	r25, r25
    39e0:	82 0f       	add	r24, r18
    39e2:	93 1f       	adc	r25, r19
    39e4:	fc 01       	movw	r30, r24
    39e6:	e4 55       	subi	r30, 0x54	; 84
    39e8:	f8 4f       	sbci	r31, 0xF8	; 248
    39ea:	80 81       	ld	r24, Z
    39ec:	82 30       	cpi	r24, 0x02	; 2
    39ee:	40 f0       	brcs	.+16     	; 0x3a00 <xTaskIncrementTick+0x1ae>
			{
				xSwitchRequired = pdTRUE;
    39f0:	81 e0       	ldi	r24, 0x01	; 1
    39f2:	8d 83       	std	Y+5, r24	; 0x05
    39f4:	05 c0       	rjmp	.+10     	; 0x3a00 <xTaskIncrementTick+0x1ae>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    39f6:	80 91 a7 07 	lds	r24, 0x07A7
    39fa:	8f 5f       	subi	r24, 0xFF	; 255
    39fc:	80 93 a7 07 	sts	0x07A7, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    3a00:	80 91 a8 07 	lds	r24, 0x07A8
    3a04:	88 23       	and	r24, r24
    3a06:	11 f0       	breq	.+4      	; 0x3a0c <xTaskIncrementTick+0x1ba>
		{
			xSwitchRequired = pdTRUE;
    3a08:	81 e0       	ldi	r24, 0x01	; 1
    3a0a:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    3a0c:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3a0e:	29 96       	adiw	r28, 0x09	; 9
    3a10:	0f b6       	in	r0, 0x3f	; 63
    3a12:	f8 94       	cli
    3a14:	de bf       	out	0x3e, r29	; 62
    3a16:	0f be       	out	0x3f, r0	; 63
    3a18:	cd bf       	out	0x3d, r28	; 61
    3a1a:	cf 91       	pop	r28
    3a1c:	df 91       	pop	r29
    3a1e:	08 95       	ret

00003a20 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3a20:	df 93       	push	r29
    3a22:	cf 93       	push	r28
    3a24:	00 d0       	rcall	.+0      	; 0x3a26 <vTaskSwitchContext+0x6>
    3a26:	cd b7       	in	r28, 0x3d	; 61
    3a28:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3a2a:	80 91 ab 07 	lds	r24, 0x07AB
    3a2e:	88 23       	and	r24, r24
    3a30:	21 f0       	breq	.+8      	; 0x3a3a <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3a32:	81 e0       	ldi	r24, 0x01	; 1
    3a34:	80 93 a8 07 	sts	0x07A8, r24
    3a38:	57 c0       	rjmp	.+174    	; 0x3ae8 <vTaskSwitchContext+0xc8>
	}
	else
	{
		xYieldPending = pdFALSE;
    3a3a:	10 92 a8 07 	sts	0x07A8, r1
    3a3e:	05 c0       	rjmp	.+10     	; 0x3a4a <vTaskSwitchContext+0x2a>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    3a40:	80 91 a5 07 	lds	r24, 0x07A5
    3a44:	81 50       	subi	r24, 0x01	; 1
    3a46:	80 93 a5 07 	sts	0x07A5, r24
    3a4a:	80 91 a5 07 	lds	r24, 0x07A5
    3a4e:	28 2f       	mov	r18, r24
    3a50:	30 e0       	ldi	r19, 0x00	; 0
    3a52:	c9 01       	movw	r24, r18
    3a54:	88 0f       	add	r24, r24
    3a56:	99 1f       	adc	r25, r25
    3a58:	88 0f       	add	r24, r24
    3a5a:	99 1f       	adc	r25, r25
    3a5c:	88 0f       	add	r24, r24
    3a5e:	99 1f       	adc	r25, r25
    3a60:	82 0f       	add	r24, r18
    3a62:	93 1f       	adc	r25, r19
    3a64:	fc 01       	movw	r30, r24
    3a66:	e4 55       	subi	r30, 0x54	; 84
    3a68:	f8 4f       	sbci	r31, 0xF8	; 248
    3a6a:	80 81       	ld	r24, Z
    3a6c:	88 23       	and	r24, r24
    3a6e:	41 f3       	breq	.-48     	; 0x3a40 <vTaskSwitchContext+0x20>
    3a70:	80 91 a5 07 	lds	r24, 0x07A5
    3a74:	28 2f       	mov	r18, r24
    3a76:	30 e0       	ldi	r19, 0x00	; 0
    3a78:	c9 01       	movw	r24, r18
    3a7a:	88 0f       	add	r24, r24
    3a7c:	99 1f       	adc	r25, r25
    3a7e:	88 0f       	add	r24, r24
    3a80:	99 1f       	adc	r25, r25
    3a82:	88 0f       	add	r24, r24
    3a84:	99 1f       	adc	r25, r25
    3a86:	82 0f       	add	r24, r18
    3a88:	93 1f       	adc	r25, r19
    3a8a:	84 55       	subi	r24, 0x54	; 84
    3a8c:	98 4f       	sbci	r25, 0xF8	; 248
    3a8e:	9a 83       	std	Y+2, r25	; 0x02
    3a90:	89 83       	std	Y+1, r24	; 0x01
    3a92:	e9 81       	ldd	r30, Y+1	; 0x01
    3a94:	fa 81       	ldd	r31, Y+2	; 0x02
    3a96:	01 80       	ldd	r0, Z+1	; 0x01
    3a98:	f2 81       	ldd	r31, Z+2	; 0x02
    3a9a:	e0 2d       	mov	r30, r0
    3a9c:	82 81       	ldd	r24, Z+2	; 0x02
    3a9e:	93 81       	ldd	r25, Z+3	; 0x03
    3aa0:	e9 81       	ldd	r30, Y+1	; 0x01
    3aa2:	fa 81       	ldd	r31, Y+2	; 0x02
    3aa4:	92 83       	std	Z+2, r25	; 0x02
    3aa6:	81 83       	std	Z+1, r24	; 0x01
    3aa8:	e9 81       	ldd	r30, Y+1	; 0x01
    3aaa:	fa 81       	ldd	r31, Y+2	; 0x02
    3aac:	21 81       	ldd	r18, Z+1	; 0x01
    3aae:	32 81       	ldd	r19, Z+2	; 0x02
    3ab0:	89 81       	ldd	r24, Y+1	; 0x01
    3ab2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ab4:	03 96       	adiw	r24, 0x03	; 3
    3ab6:	28 17       	cp	r18, r24
    3ab8:	39 07       	cpc	r19, r25
    3aba:	59 f4       	brne	.+22     	; 0x3ad2 <vTaskSwitchContext+0xb2>
    3abc:	e9 81       	ldd	r30, Y+1	; 0x01
    3abe:	fa 81       	ldd	r31, Y+2	; 0x02
    3ac0:	01 80       	ldd	r0, Z+1	; 0x01
    3ac2:	f2 81       	ldd	r31, Z+2	; 0x02
    3ac4:	e0 2d       	mov	r30, r0
    3ac6:	82 81       	ldd	r24, Z+2	; 0x02
    3ac8:	93 81       	ldd	r25, Z+3	; 0x03
    3aca:	e9 81       	ldd	r30, Y+1	; 0x01
    3acc:	fa 81       	ldd	r31, Y+2	; 0x02
    3ace:	92 83       	std	Z+2, r25	; 0x02
    3ad0:	81 83       	std	Z+1, r24	; 0x01
    3ad2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ad4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ad6:	01 80       	ldd	r0, Z+1	; 0x01
    3ad8:	f2 81       	ldd	r31, Z+2	; 0x02
    3ada:	e0 2d       	mov	r30, r0
    3adc:	86 81       	ldd	r24, Z+6	; 0x06
    3ade:	97 81       	ldd	r25, Z+7	; 0x07
    3ae0:	90 93 a0 07 	sts	0x07A0, r25
    3ae4:	80 93 9f 07 	sts	0x079F, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3ae8:	0f 90       	pop	r0
    3aea:	0f 90       	pop	r0
    3aec:	cf 91       	pop	r28
    3aee:	df 91       	pop	r29
    3af0:	08 95       	ret

00003af2 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3af2:	df 93       	push	r29
    3af4:	cf 93       	push	r28
    3af6:	00 d0       	rcall	.+0      	; 0x3af8 <vTaskPlaceOnEventList+0x6>
    3af8:	00 d0       	rcall	.+0      	; 0x3afa <vTaskPlaceOnEventList+0x8>
    3afa:	00 d0       	rcall	.+0      	; 0x3afc <vTaskPlaceOnEventList+0xa>
    3afc:	cd b7       	in	r28, 0x3d	; 61
    3afe:	de b7       	in	r29, 0x3e	; 62
    3b00:	9c 83       	std	Y+4, r25	; 0x04
    3b02:	8b 83       	std	Y+3, r24	; 0x03
    3b04:	7e 83       	std	Y+6, r23	; 0x06
    3b06:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3b08:	80 91 9f 07 	lds	r24, 0x079F
    3b0c:	90 91 a0 07 	lds	r25, 0x07A0
    3b10:	9c 01       	movw	r18, r24
    3b12:	24 5f       	subi	r18, 0xF4	; 244
    3b14:	3f 4f       	sbci	r19, 0xFF	; 255
    3b16:	8b 81       	ldd	r24, Y+3	; 0x03
    3b18:	9c 81       	ldd	r25, Y+4	; 0x04
    3b1a:	b9 01       	movw	r22, r18
    3b1c:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3b20:	80 91 9f 07 	lds	r24, 0x079F
    3b24:	90 91 a0 07 	lds	r25, 0x07A0
    3b28:	02 96       	adiw	r24, 0x02	; 2
    3b2a:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    3b2e:	20 91 a3 07 	lds	r18, 0x07A3
    3b32:	30 91 a4 07 	lds	r19, 0x07A4
    3b36:	8d 81       	ldd	r24, Y+5	; 0x05
    3b38:	9e 81       	ldd	r25, Y+6	; 0x06
    3b3a:	82 0f       	add	r24, r18
    3b3c:	93 1f       	adc	r25, r19
    3b3e:	9a 83       	std	Y+2, r25	; 0x02
    3b40:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3b42:	89 81       	ldd	r24, Y+1	; 0x01
    3b44:	9a 81       	ldd	r25, Y+2	; 0x02
    3b46:	0e 94 46 20 	call	0x408c	; 0x408c <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3b4a:	26 96       	adiw	r28, 0x06	; 6
    3b4c:	0f b6       	in	r0, 0x3f	; 63
    3b4e:	f8 94       	cli
    3b50:	de bf       	out	0x3e, r29	; 62
    3b52:	0f be       	out	0x3f, r0	; 63
    3b54:	cd bf       	out	0x3d, r28	; 61
    3b56:	cf 91       	pop	r28
    3b58:	df 91       	pop	r29
    3b5a:	08 95       	ret

00003b5c <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3b5c:	df 93       	push	r29
    3b5e:	cf 93       	push	r28
    3b60:	cd b7       	in	r28, 0x3d	; 61
    3b62:	de b7       	in	r29, 0x3e	; 62
    3b64:	28 97       	sbiw	r28, 0x08	; 8
    3b66:	0f b6       	in	r0, 0x3f	; 63
    3b68:	f8 94       	cli
    3b6a:	de bf       	out	0x3e, r29	; 62
    3b6c:	0f be       	out	0x3f, r0	; 63
    3b6e:	cd bf       	out	0x3d, r28	; 61
    3b70:	9c 83       	std	Y+4, r25	; 0x04
    3b72:	8b 83       	std	Y+3, r24	; 0x03
    3b74:	7e 83       	std	Y+6, r23	; 0x06
    3b76:	6d 83       	std	Y+5, r22	; 0x05
    3b78:	58 87       	std	Y+8, r21	; 0x08
    3b7a:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3b7c:	e0 91 9f 07 	lds	r30, 0x079F
    3b80:	f0 91 a0 07 	lds	r31, 0x07A0
    3b84:	8d 81       	ldd	r24, Y+5	; 0x05
    3b86:	9e 81       	ldd	r25, Y+6	; 0x06
    3b88:	90 68       	ori	r25, 0x80	; 128
    3b8a:	95 87       	std	Z+13, r25	; 0x0d
    3b8c:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3b8e:	80 91 9f 07 	lds	r24, 0x079F
    3b92:	90 91 a0 07 	lds	r25, 0x07A0
    3b96:	9c 01       	movw	r18, r24
    3b98:	24 5f       	subi	r18, 0xF4	; 244
    3b9a:	3f 4f       	sbci	r19, 0xFF	; 255
    3b9c:	8b 81       	ldd	r24, Y+3	; 0x03
    3b9e:	9c 81       	ldd	r25, Y+4	; 0x04
    3ba0:	b9 01       	movw	r22, r18
    3ba2:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3ba6:	80 91 9f 07 	lds	r24, 0x079F
    3baa:	90 91 a0 07 	lds	r25, 0x07A0
    3bae:	02 96       	adiw	r24, 0x02	; 2
    3bb0:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    3bb4:	20 91 a3 07 	lds	r18, 0x07A3
    3bb8:	30 91 a4 07 	lds	r19, 0x07A4
    3bbc:	8f 81       	ldd	r24, Y+7	; 0x07
    3bbe:	98 85       	ldd	r25, Y+8	; 0x08
    3bc0:	82 0f       	add	r24, r18
    3bc2:	93 1f       	adc	r25, r19
    3bc4:	9a 83       	std	Y+2, r25	; 0x02
    3bc6:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3bc8:	89 81       	ldd	r24, Y+1	; 0x01
    3bca:	9a 81       	ldd	r25, Y+2	; 0x02
    3bcc:	0e 94 46 20 	call	0x408c	; 0x408c <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3bd0:	28 96       	adiw	r28, 0x08	; 8
    3bd2:	0f b6       	in	r0, 0x3f	; 63
    3bd4:	f8 94       	cli
    3bd6:	de bf       	out	0x3e, r29	; 62
    3bd8:	0f be       	out	0x3f, r0	; 63
    3bda:	cd bf       	out	0x3d, r28	; 61
    3bdc:	cf 91       	pop	r28
    3bde:	df 91       	pop	r29
    3be0:	08 95       	ret

00003be2 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3be2:	df 93       	push	r29
    3be4:	cf 93       	push	r28
    3be6:	00 d0       	rcall	.+0      	; 0x3be8 <xTaskRemoveFromEventList+0x6>
    3be8:	00 d0       	rcall	.+0      	; 0x3bea <xTaskRemoveFromEventList+0x8>
    3bea:	0f 92       	push	r0
    3bec:	cd b7       	in	r28, 0x3d	; 61
    3bee:	de b7       	in	r29, 0x3e	; 62
    3bf0:	9d 83       	std	Y+5, r25	; 0x05
    3bf2:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3bf4:	ec 81       	ldd	r30, Y+4	; 0x04
    3bf6:	fd 81       	ldd	r31, Y+5	; 0x05
    3bf8:	05 80       	ldd	r0, Z+5	; 0x05
    3bfa:	f6 81       	ldd	r31, Z+6	; 0x06
    3bfc:	e0 2d       	mov	r30, r0
    3bfe:	86 81       	ldd	r24, Z+6	; 0x06
    3c00:	97 81       	ldd	r25, Z+7	; 0x07
    3c02:	9b 83       	std	Y+3, r25	; 0x03
    3c04:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3c06:	8a 81       	ldd	r24, Y+2	; 0x02
    3c08:	9b 81       	ldd	r25, Y+3	; 0x03
    3c0a:	0c 96       	adiw	r24, 0x0c	; 12
    3c0c:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3c10:	80 91 ab 07 	lds	r24, 0x07AB
    3c14:	88 23       	and	r24, r24
    3c16:	61 f5       	brne	.+88     	; 0x3c70 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3c18:	8a 81       	ldd	r24, Y+2	; 0x02
    3c1a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c1c:	02 96       	adiw	r24, 0x02	; 2
    3c1e:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3c22:	ea 81       	ldd	r30, Y+2	; 0x02
    3c24:	fb 81       	ldd	r31, Y+3	; 0x03
    3c26:	96 89       	ldd	r25, Z+22	; 0x16
    3c28:	80 91 a5 07 	lds	r24, 0x07A5
    3c2c:	89 17       	cp	r24, r25
    3c2e:	28 f4       	brcc	.+10     	; 0x3c3a <xTaskRemoveFromEventList+0x58>
    3c30:	ea 81       	ldd	r30, Y+2	; 0x02
    3c32:	fb 81       	ldd	r31, Y+3	; 0x03
    3c34:	86 89       	ldd	r24, Z+22	; 0x16
    3c36:	80 93 a5 07 	sts	0x07A5, r24
    3c3a:	ea 81       	ldd	r30, Y+2	; 0x02
    3c3c:	fb 81       	ldd	r31, Y+3	; 0x03
    3c3e:	86 89       	ldd	r24, Z+22	; 0x16
    3c40:	28 2f       	mov	r18, r24
    3c42:	30 e0       	ldi	r19, 0x00	; 0
    3c44:	c9 01       	movw	r24, r18
    3c46:	88 0f       	add	r24, r24
    3c48:	99 1f       	adc	r25, r25
    3c4a:	88 0f       	add	r24, r24
    3c4c:	99 1f       	adc	r25, r25
    3c4e:	88 0f       	add	r24, r24
    3c50:	99 1f       	adc	r25, r25
    3c52:	82 0f       	add	r24, r18
    3c54:	93 1f       	adc	r25, r19
    3c56:	ac 01       	movw	r20, r24
    3c58:	44 55       	subi	r20, 0x54	; 84
    3c5a:	58 4f       	sbci	r21, 0xF8	; 248
    3c5c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c5e:	9b 81       	ldd	r25, Y+3	; 0x03
    3c60:	9c 01       	movw	r18, r24
    3c62:	2e 5f       	subi	r18, 0xFE	; 254
    3c64:	3f 4f       	sbci	r19, 0xFF	; 255
    3c66:	ca 01       	movw	r24, r20
    3c68:	b9 01       	movw	r22, r18
    3c6a:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsertEnd>
    3c6e:	0a c0       	rjmp	.+20     	; 0x3c84 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3c70:	8a 81       	ldd	r24, Y+2	; 0x02
    3c72:	9b 81       	ldd	r25, Y+3	; 0x03
    3c74:	9c 01       	movw	r18, r24
    3c76:	24 5f       	subi	r18, 0xF4	; 244
    3c78:	3f 4f       	sbci	r19, 0xFF	; 255
    3c7a:	86 ee       	ldi	r24, 0xE6	; 230
    3c7c:	97 e0       	ldi	r25, 0x07	; 7
    3c7e:	b9 01       	movw	r22, r18
    3c80:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3c84:	ea 81       	ldd	r30, Y+2	; 0x02
    3c86:	fb 81       	ldd	r31, Y+3	; 0x03
    3c88:	96 89       	ldd	r25, Z+22	; 0x16
    3c8a:	e0 91 9f 07 	lds	r30, 0x079F
    3c8e:	f0 91 a0 07 	lds	r31, 0x07A0
    3c92:	86 89       	ldd	r24, Z+22	; 0x16
    3c94:	89 17       	cp	r24, r25
    3c96:	30 f4       	brcc	.+12     	; 0x3ca4 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    3c98:	81 e0       	ldi	r24, 0x01	; 1
    3c9a:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3c9c:	81 e0       	ldi	r24, 0x01	; 1
    3c9e:	80 93 a8 07 	sts	0x07A8, r24
    3ca2:	01 c0       	rjmp	.+2      	; 0x3ca6 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    3ca4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3ca6:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ca8:	0f 90       	pop	r0
    3caa:	0f 90       	pop	r0
    3cac:	0f 90       	pop	r0
    3cae:	0f 90       	pop	r0
    3cb0:	0f 90       	pop	r0
    3cb2:	cf 91       	pop	r28
    3cb4:	df 91       	pop	r29
    3cb6:	08 95       	ret

00003cb8 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    3cb8:	df 93       	push	r29
    3cba:	cf 93       	push	r28
    3cbc:	cd b7       	in	r28, 0x3d	; 61
    3cbe:	de b7       	in	r29, 0x3e	; 62
    3cc0:	27 97       	sbiw	r28, 0x07	; 7
    3cc2:	0f b6       	in	r0, 0x3f	; 63
    3cc4:	f8 94       	cli
    3cc6:	de bf       	out	0x3e, r29	; 62
    3cc8:	0f be       	out	0x3f, r0	; 63
    3cca:	cd bf       	out	0x3d, r28	; 61
    3ccc:	9d 83       	std	Y+5, r25	; 0x05
    3cce:	8c 83       	std	Y+4, r24	; 0x04
    3cd0:	7f 83       	std	Y+7, r23	; 0x07
    3cd2:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3cd4:	8e 81       	ldd	r24, Y+6	; 0x06
    3cd6:	9f 81       	ldd	r25, Y+7	; 0x07
    3cd8:	90 68       	ori	r25, 0x80	; 128
    3cda:	ec 81       	ldd	r30, Y+4	; 0x04
    3cdc:	fd 81       	ldd	r31, Y+5	; 0x05
    3cde:	91 83       	std	Z+1, r25	; 0x01
    3ce0:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    3ce2:	ec 81       	ldd	r30, Y+4	; 0x04
    3ce4:	fd 81       	ldd	r31, Y+5	; 0x05
    3ce6:	86 81       	ldd	r24, Z+6	; 0x06
    3ce8:	97 81       	ldd	r25, Z+7	; 0x07
    3cea:	9b 83       	std	Y+3, r25	; 0x03
    3cec:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    3cee:	8c 81       	ldd	r24, Y+4	; 0x04
    3cf0:	9d 81       	ldd	r25, Y+5	; 0x05
    3cf2:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3cf6:	8a 81       	ldd	r24, Y+2	; 0x02
    3cf8:	9b 81       	ldd	r25, Y+3	; 0x03
    3cfa:	02 96       	adiw	r24, 0x02	; 2
    3cfc:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    3d00:	ea 81       	ldd	r30, Y+2	; 0x02
    3d02:	fb 81       	ldd	r31, Y+3	; 0x03
    3d04:	96 89       	ldd	r25, Z+22	; 0x16
    3d06:	80 91 a5 07 	lds	r24, 0x07A5
    3d0a:	89 17       	cp	r24, r25
    3d0c:	28 f4       	brcc	.+10     	; 0x3d18 <xTaskRemoveFromUnorderedEventList+0x60>
    3d0e:	ea 81       	ldd	r30, Y+2	; 0x02
    3d10:	fb 81       	ldd	r31, Y+3	; 0x03
    3d12:	86 89       	ldd	r24, Z+22	; 0x16
    3d14:	80 93 a5 07 	sts	0x07A5, r24
    3d18:	ea 81       	ldd	r30, Y+2	; 0x02
    3d1a:	fb 81       	ldd	r31, Y+3	; 0x03
    3d1c:	86 89       	ldd	r24, Z+22	; 0x16
    3d1e:	28 2f       	mov	r18, r24
    3d20:	30 e0       	ldi	r19, 0x00	; 0
    3d22:	c9 01       	movw	r24, r18
    3d24:	88 0f       	add	r24, r24
    3d26:	99 1f       	adc	r25, r25
    3d28:	88 0f       	add	r24, r24
    3d2a:	99 1f       	adc	r25, r25
    3d2c:	88 0f       	add	r24, r24
    3d2e:	99 1f       	adc	r25, r25
    3d30:	82 0f       	add	r24, r18
    3d32:	93 1f       	adc	r25, r19
    3d34:	ac 01       	movw	r20, r24
    3d36:	44 55       	subi	r20, 0x54	; 84
    3d38:	58 4f       	sbci	r21, 0xF8	; 248
    3d3a:	8a 81       	ldd	r24, Y+2	; 0x02
    3d3c:	9b 81       	ldd	r25, Y+3	; 0x03
    3d3e:	9c 01       	movw	r18, r24
    3d40:	2e 5f       	subi	r18, 0xFE	; 254
    3d42:	3f 4f       	sbci	r19, 0xFF	; 255
    3d44:	ca 01       	movw	r24, r20
    3d46:	b9 01       	movw	r22, r18
    3d48:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3d4c:	ea 81       	ldd	r30, Y+2	; 0x02
    3d4e:	fb 81       	ldd	r31, Y+3	; 0x03
    3d50:	96 89       	ldd	r25, Z+22	; 0x16
    3d52:	e0 91 9f 07 	lds	r30, 0x079F
    3d56:	f0 91 a0 07 	lds	r31, 0x07A0
    3d5a:	86 89       	ldd	r24, Z+22	; 0x16
    3d5c:	89 17       	cp	r24, r25
    3d5e:	30 f4       	brcc	.+12     	; 0x3d6c <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    3d60:	81 e0       	ldi	r24, 0x01	; 1
    3d62:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3d64:	81 e0       	ldi	r24, 0x01	; 1
    3d66:	80 93 a8 07 	sts	0x07A8, r24
    3d6a:	01 c0       	rjmp	.+2      	; 0x3d6e <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    3d6c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3d6e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3d70:	27 96       	adiw	r28, 0x07	; 7
    3d72:	0f b6       	in	r0, 0x3f	; 63
    3d74:	f8 94       	cli
    3d76:	de bf       	out	0x3e, r29	; 62
    3d78:	0f be       	out	0x3f, r0	; 63
    3d7a:	cd bf       	out	0x3d, r28	; 61
    3d7c:	cf 91       	pop	r28
    3d7e:	df 91       	pop	r29
    3d80:	08 95       	ret

00003d82 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3d82:	df 93       	push	r29
    3d84:	cf 93       	push	r28
    3d86:	00 d0       	rcall	.+0      	; 0x3d88 <vTaskSetTimeOutState+0x6>
    3d88:	cd b7       	in	r28, 0x3d	; 61
    3d8a:	de b7       	in	r29, 0x3e	; 62
    3d8c:	9a 83       	std	Y+2, r25	; 0x02
    3d8e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3d90:	80 91 a9 07 	lds	r24, 0x07A9
    3d94:	e9 81       	ldd	r30, Y+1	; 0x01
    3d96:	fa 81       	ldd	r31, Y+2	; 0x02
    3d98:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3d9a:	80 91 a3 07 	lds	r24, 0x07A3
    3d9e:	90 91 a4 07 	lds	r25, 0x07A4
    3da2:	e9 81       	ldd	r30, Y+1	; 0x01
    3da4:	fa 81       	ldd	r31, Y+2	; 0x02
    3da6:	92 83       	std	Z+2, r25	; 0x02
    3da8:	81 83       	std	Z+1, r24	; 0x01
}
    3daa:	0f 90       	pop	r0
    3dac:	0f 90       	pop	r0
    3dae:	cf 91       	pop	r28
    3db0:	df 91       	pop	r29
    3db2:	08 95       	ret

00003db4 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    3db4:	df 93       	push	r29
    3db6:	cf 93       	push	r28
    3db8:	cd b7       	in	r28, 0x3d	; 61
    3dba:	de b7       	in	r29, 0x3e	; 62
    3dbc:	27 97       	sbiw	r28, 0x07	; 7
    3dbe:	0f b6       	in	r0, 0x3f	; 63
    3dc0:	f8 94       	cli
    3dc2:	de bf       	out	0x3e, r29	; 62
    3dc4:	0f be       	out	0x3f, r0	; 63
    3dc6:	cd bf       	out	0x3d, r28	; 61
    3dc8:	9d 83       	std	Y+5, r25	; 0x05
    3dca:	8c 83       	std	Y+4, r24	; 0x04
    3dcc:	7f 83       	std	Y+7, r23	; 0x07
    3dce:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3dd0:	0f b6       	in	r0, 0x3f	; 63
    3dd2:	f8 94       	cli
    3dd4:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    3dd6:	80 91 a3 07 	lds	r24, 0x07A3
    3dda:	90 91 a4 07 	lds	r25, 0x07A4
    3dde:	9a 83       	std	Y+2, r25	; 0x02
    3de0:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3de2:	ec 81       	ldd	r30, Y+4	; 0x04
    3de4:	fd 81       	ldd	r31, Y+5	; 0x05
    3de6:	90 81       	ld	r25, Z
    3de8:	80 91 a9 07 	lds	r24, 0x07A9
    3dec:	98 17       	cp	r25, r24
    3dee:	61 f0       	breq	.+24     	; 0x3e08 <xTaskCheckForTimeOut+0x54>
    3df0:	ec 81       	ldd	r30, Y+4	; 0x04
    3df2:	fd 81       	ldd	r31, Y+5	; 0x05
    3df4:	21 81       	ldd	r18, Z+1	; 0x01
    3df6:	32 81       	ldd	r19, Z+2	; 0x02
    3df8:	89 81       	ldd	r24, Y+1	; 0x01
    3dfa:	9a 81       	ldd	r25, Y+2	; 0x02
    3dfc:	82 17       	cp	r24, r18
    3dfe:	93 07       	cpc	r25, r19
    3e00:	18 f0       	brcs	.+6      	; 0x3e08 <xTaskCheckForTimeOut+0x54>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    3e02:	81 e0       	ldi	r24, 0x01	; 1
    3e04:	8b 83       	std	Y+3, r24	; 0x03
    3e06:	2d c0       	rjmp	.+90     	; 0x3e62 <xTaskCheckForTimeOut+0xae>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    3e08:	ec 81       	ldd	r30, Y+4	; 0x04
    3e0a:	fd 81       	ldd	r31, Y+5	; 0x05
    3e0c:	21 81       	ldd	r18, Z+1	; 0x01
    3e0e:	32 81       	ldd	r19, Z+2	; 0x02
    3e10:	89 81       	ldd	r24, Y+1	; 0x01
    3e12:	9a 81       	ldd	r25, Y+2	; 0x02
    3e14:	ac 01       	movw	r20, r24
    3e16:	42 1b       	sub	r20, r18
    3e18:	53 0b       	sbc	r21, r19
    3e1a:	9a 01       	movw	r18, r20
    3e1c:	ee 81       	ldd	r30, Y+6	; 0x06
    3e1e:	ff 81       	ldd	r31, Y+7	; 0x07
    3e20:	80 81       	ld	r24, Z
    3e22:	91 81       	ldd	r25, Z+1	; 0x01
    3e24:	28 17       	cp	r18, r24
    3e26:	39 07       	cpc	r19, r25
    3e28:	d0 f4       	brcc	.+52     	; 0x3e5e <xTaskCheckForTimeOut+0xaa>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    3e2a:	ee 81       	ldd	r30, Y+6	; 0x06
    3e2c:	ff 81       	ldd	r31, Y+7	; 0x07
    3e2e:	40 81       	ld	r20, Z
    3e30:	51 81       	ldd	r21, Z+1	; 0x01
    3e32:	ec 81       	ldd	r30, Y+4	; 0x04
    3e34:	fd 81       	ldd	r31, Y+5	; 0x05
    3e36:	21 81       	ldd	r18, Z+1	; 0x01
    3e38:	32 81       	ldd	r19, Z+2	; 0x02
    3e3a:	89 81       	ldd	r24, Y+1	; 0x01
    3e3c:	9a 81       	ldd	r25, Y+2	; 0x02
    3e3e:	b9 01       	movw	r22, r18
    3e40:	68 1b       	sub	r22, r24
    3e42:	79 0b       	sbc	r23, r25
    3e44:	cb 01       	movw	r24, r22
    3e46:	84 0f       	add	r24, r20
    3e48:	95 1f       	adc	r25, r21
    3e4a:	ee 81       	ldd	r30, Y+6	; 0x06
    3e4c:	ff 81       	ldd	r31, Y+7	; 0x07
    3e4e:	91 83       	std	Z+1, r25	; 0x01
    3e50:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    3e52:	8c 81       	ldd	r24, Y+4	; 0x04
    3e54:	9d 81       	ldd	r25, Y+5	; 0x05
    3e56:	0e 94 c1 1e 	call	0x3d82	; 0x3d82 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    3e5a:	1b 82       	std	Y+3, r1	; 0x03
    3e5c:	02 c0       	rjmp	.+4      	; 0x3e62 <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			xReturn = pdTRUE;
    3e5e:	81 e0       	ldi	r24, 0x01	; 1
    3e60:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    3e62:	0f 90       	pop	r0
    3e64:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3e66:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3e68:	27 96       	adiw	r28, 0x07	; 7
    3e6a:	0f b6       	in	r0, 0x3f	; 63
    3e6c:	f8 94       	cli
    3e6e:	de bf       	out	0x3e, r29	; 62
    3e70:	0f be       	out	0x3f, r0	; 63
    3e72:	cd bf       	out	0x3d, r28	; 61
    3e74:	cf 91       	pop	r28
    3e76:	df 91       	pop	r29
    3e78:	08 95       	ret

00003e7a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3e7a:	df 93       	push	r29
    3e7c:	cf 93       	push	r28
    3e7e:	cd b7       	in	r28, 0x3d	; 61
    3e80:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    3e82:	81 e0       	ldi	r24, 0x01	; 1
    3e84:	80 93 a8 07 	sts	0x07A8, r24
}
    3e88:	cf 91       	pop	r28
    3e8a:	df 91       	pop	r29
    3e8c:	08 95       	ret

00003e8e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3e8e:	df 93       	push	r29
    3e90:	cf 93       	push	r28
    3e92:	00 d0       	rcall	.+0      	; 0x3e94 <prvIdleTask+0x6>
    3e94:	cd b7       	in	r28, 0x3d	; 61
    3e96:	de b7       	in	r29, 0x3e	; 62
    3e98:	9a 83       	std	Y+2, r25	; 0x02
    3e9a:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    3e9c:	0e 94 07 20 	call	0x400e	; 0x400e <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    3ea0:	80 91 ac 07 	lds	r24, 0x07AC
    3ea4:	82 30       	cpi	r24, 0x02	; 2
    3ea6:	d0 f3       	brcs	.-12     	; 0x3e9c <prvIdleTask+0xe>
			{
				taskYIELD();
    3ea8:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vPortYield>
    3eac:	f7 cf       	rjmp	.-18     	; 0x3e9c <prvIdleTask+0xe>

00003eae <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3eae:	0f 93       	push	r16
    3eb0:	1f 93       	push	r17
    3eb2:	df 93       	push	r29
    3eb4:	cf 93       	push	r28
    3eb6:	cd b7       	in	r28, 0x3d	; 61
    3eb8:	de b7       	in	r29, 0x3e	; 62
    3eba:	2a 97       	sbiw	r28, 0x0a	; 10
    3ebc:	0f b6       	in	r0, 0x3f	; 63
    3ebe:	f8 94       	cli
    3ec0:	de bf       	out	0x3e, r29	; 62
    3ec2:	0f be       	out	0x3f, r0	; 63
    3ec4:	cd bf       	out	0x3d, r28	; 61
    3ec6:	9b 83       	std	Y+3, r25	; 0x03
    3ec8:	8a 83       	std	Y+2, r24	; 0x02
    3eca:	7d 83       	std	Y+5, r23	; 0x05
    3ecc:	6c 83       	std	Y+4, r22	; 0x04
    3ece:	4e 83       	std	Y+6, r20	; 0x06
    3ed0:	38 87       	std	Y+8, r19	; 0x08
    3ed2:	2f 83       	std	Y+7, r18	; 0x07
    3ed4:	1a 87       	std	Y+10, r17	; 0x0a
    3ed6:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3ed8:	19 82       	std	Y+1, r1	; 0x01
    3eda:	21 c0       	rjmp	.+66     	; 0x3f1e <prvInitialiseTCBVariables+0x70>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    3edc:	89 81       	ldd	r24, Y+1	; 0x01
    3ede:	48 2f       	mov	r20, r24
    3ee0:	50 e0       	ldi	r21, 0x00	; 0
    3ee2:	89 81       	ldd	r24, Y+1	; 0x01
    3ee4:	28 2f       	mov	r18, r24
    3ee6:	30 e0       	ldi	r19, 0x00	; 0
    3ee8:	8c 81       	ldd	r24, Y+4	; 0x04
    3eea:	9d 81       	ldd	r25, Y+5	; 0x05
    3eec:	fc 01       	movw	r30, r24
    3eee:	e2 0f       	add	r30, r18
    3ef0:	f3 1f       	adc	r31, r19
    3ef2:	20 81       	ld	r18, Z
    3ef4:	8a 81       	ldd	r24, Y+2	; 0x02
    3ef6:	9b 81       	ldd	r25, Y+3	; 0x03
    3ef8:	84 0f       	add	r24, r20
    3efa:	95 1f       	adc	r25, r21
    3efc:	fc 01       	movw	r30, r24
    3efe:	79 96       	adiw	r30, 0x19	; 25
    3f00:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    3f02:	89 81       	ldd	r24, Y+1	; 0x01
    3f04:	28 2f       	mov	r18, r24
    3f06:	30 e0       	ldi	r19, 0x00	; 0
    3f08:	8c 81       	ldd	r24, Y+4	; 0x04
    3f0a:	9d 81       	ldd	r25, Y+5	; 0x05
    3f0c:	fc 01       	movw	r30, r24
    3f0e:	e2 0f       	add	r30, r18
    3f10:	f3 1f       	adc	r31, r19
    3f12:	80 81       	ld	r24, Z
    3f14:	88 23       	and	r24, r24
    3f16:	31 f0       	breq	.+12     	; 0x3f24 <prvInitialiseTCBVariables+0x76>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3f18:	89 81       	ldd	r24, Y+1	; 0x01
    3f1a:	8f 5f       	subi	r24, 0xFF	; 255
    3f1c:	89 83       	std	Y+1, r24	; 0x01
    3f1e:	89 81       	ldd	r24, Y+1	; 0x01
    3f20:	84 31       	cpi	r24, 0x14	; 20
    3f22:	e0 f2       	brcs	.-72     	; 0x3edc <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3f24:	ea 81       	ldd	r30, Y+2	; 0x02
    3f26:	fb 81       	ldd	r31, Y+3	; 0x03
    3f28:	14 a6       	std	Z+44, r1	; 0x2c

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3f2a:	8e 81       	ldd	r24, Y+6	; 0x06
    3f2c:	84 30       	cpi	r24, 0x04	; 4
    3f2e:	10 f0       	brcs	.+4      	; 0x3f34 <prvInitialiseTCBVariables+0x86>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3f30:	83 e0       	ldi	r24, 0x03	; 3
    3f32:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    3f34:	ea 81       	ldd	r30, Y+2	; 0x02
    3f36:	fb 81       	ldd	r31, Y+3	; 0x03
    3f38:	8e 81       	ldd	r24, Y+6	; 0x06
    3f3a:	86 8b       	std	Z+22, r24	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    3f3c:	8a 81       	ldd	r24, Y+2	; 0x02
    3f3e:	9b 81       	ldd	r25, Y+3	; 0x03
    3f40:	02 96       	adiw	r24, 0x02	; 2
    3f42:	0e 94 1d 0e 	call	0x1c3a	; 0x1c3a <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    3f46:	8a 81       	ldd	r24, Y+2	; 0x02
    3f48:	9b 81       	ldd	r25, Y+3	; 0x03
    3f4a:	0c 96       	adiw	r24, 0x0c	; 12
    3f4c:	0e 94 1d 0e 	call	0x1c3a	; 0x1c3a <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    3f50:	ea 81       	ldd	r30, Y+2	; 0x02
    3f52:	fb 81       	ldd	r31, Y+3	; 0x03
    3f54:	8a 81       	ldd	r24, Y+2	; 0x02
    3f56:	9b 81       	ldd	r25, Y+3	; 0x03
    3f58:	91 87       	std	Z+9, r25	; 0x09
    3f5a:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3f5c:	8e 81       	ldd	r24, Y+6	; 0x06
    3f5e:	28 2f       	mov	r18, r24
    3f60:	30 e0       	ldi	r19, 0x00	; 0
    3f62:	84 e0       	ldi	r24, 0x04	; 4
    3f64:	90 e0       	ldi	r25, 0x00	; 0
    3f66:	82 1b       	sub	r24, r18
    3f68:	93 0b       	sbc	r25, r19
    3f6a:	ea 81       	ldd	r30, Y+2	; 0x02
    3f6c:	fb 81       	ldd	r31, Y+3	; 0x03
    3f6e:	95 87       	std	Z+13, r25	; 0x0d
    3f70:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    3f72:	ea 81       	ldd	r30, Y+2	; 0x02
    3f74:	fb 81       	ldd	r31, Y+3	; 0x03
    3f76:	8a 81       	ldd	r24, Y+2	; 0x02
    3f78:	9b 81       	ldd	r25, Y+3	; 0x03
    3f7a:	93 8b       	std	Z+19, r25	; 0x13
    3f7c:	82 8b       	std	Z+18, r24	; 0x12
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    3f7e:	2a 96       	adiw	r28, 0x0a	; 10
    3f80:	0f b6       	in	r0, 0x3f	; 63
    3f82:	f8 94       	cli
    3f84:	de bf       	out	0x3e, r29	; 62
    3f86:	0f be       	out	0x3f, r0	; 63
    3f88:	cd bf       	out	0x3d, r28	; 61
    3f8a:	cf 91       	pop	r28
    3f8c:	df 91       	pop	r29
    3f8e:	1f 91       	pop	r17
    3f90:	0f 91       	pop	r16
    3f92:	08 95       	ret

00003f94 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    3f94:	df 93       	push	r29
    3f96:	cf 93       	push	r28
    3f98:	0f 92       	push	r0
    3f9a:	cd b7       	in	r28, 0x3d	; 61
    3f9c:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3f9e:	19 82       	std	Y+1, r1	; 0x01
    3fa0:	13 c0       	rjmp	.+38     	; 0x3fc8 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    3fa2:	89 81       	ldd	r24, Y+1	; 0x01
    3fa4:	28 2f       	mov	r18, r24
    3fa6:	30 e0       	ldi	r19, 0x00	; 0
    3fa8:	c9 01       	movw	r24, r18
    3faa:	88 0f       	add	r24, r24
    3fac:	99 1f       	adc	r25, r25
    3fae:	88 0f       	add	r24, r24
    3fb0:	99 1f       	adc	r25, r25
    3fb2:	88 0f       	add	r24, r24
    3fb4:	99 1f       	adc	r25, r25
    3fb6:	82 0f       	add	r24, r18
    3fb8:	93 1f       	adc	r25, r19
    3fba:	84 55       	subi	r24, 0x54	; 84
    3fbc:	98 4f       	sbci	r25, 0xF8	; 248
    3fbe:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3fc2:	89 81       	ldd	r24, Y+1	; 0x01
    3fc4:	8f 5f       	subi	r24, 0xFF	; 255
    3fc6:	89 83       	std	Y+1, r24	; 0x01
    3fc8:	89 81       	ldd	r24, Y+1	; 0x01
    3fca:	84 30       	cpi	r24, 0x04	; 4
    3fcc:	50 f3       	brcs	.-44     	; 0x3fa2 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    3fce:	80 ed       	ldi	r24, 0xD0	; 208
    3fd0:	97 e0       	ldi	r25, 0x07	; 7
    3fd2:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    3fd6:	89 ed       	ldi	r24, 0xD9	; 217
    3fd8:	97 e0       	ldi	r25, 0x07	; 7
    3fda:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    3fde:	86 ee       	ldi	r24, 0xE6	; 230
    3fe0:	97 e0       	ldi	r25, 0x07	; 7
    3fe2:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    3fe6:	8f ee       	ldi	r24, 0xEF	; 239
    3fe8:	97 e0       	ldi	r25, 0x07	; 7
    3fea:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3fee:	80 ed       	ldi	r24, 0xD0	; 208
    3ff0:	97 e0       	ldi	r25, 0x07	; 7
    3ff2:	90 93 e3 07 	sts	0x07E3, r25
    3ff6:	80 93 e2 07 	sts	0x07E2, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3ffa:	89 ed       	ldi	r24, 0xD9	; 217
    3ffc:	97 e0       	ldi	r25, 0x07	; 7
    3ffe:	90 93 e5 07 	sts	0x07E5, r25
    4002:	80 93 e4 07 	sts	0x07E4, r24
}
    4006:	0f 90       	pop	r0
    4008:	cf 91       	pop	r28
    400a:	df 91       	pop	r29
    400c:	08 95       	ret

0000400e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    400e:	df 93       	push	r29
    4010:	cf 93       	push	r28
    4012:	00 d0       	rcall	.+0      	; 0x4014 <prvCheckTasksWaitingTermination+0x6>
    4014:	0f 92       	push	r0
    4016:	cd b7       	in	r28, 0x3d	; 61
    4018:	de b7       	in	r29, 0x3e	; 62
    401a:	2e c0       	rjmp	.+92     	; 0x4078 <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    401c:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    4020:	80 91 ef 07 	lds	r24, 0x07EF
    4024:	1b 82       	std	Y+3, r1	; 0x03
    4026:	88 23       	and	r24, r24
    4028:	11 f4       	brne	.+4      	; 0x402e <prvCheckTasksWaitingTermination+0x20>
    402a:	81 e0       	ldi	r24, 0x01	; 1
    402c:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    402e:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    4032:	8b 81       	ldd	r24, Y+3	; 0x03
    4034:	88 23       	and	r24, r24
    4036:	01 f5       	brne	.+64     	; 0x4078 <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    4038:	0f b6       	in	r0, 0x3f	; 63
    403a:	f8 94       	cli
    403c:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    403e:	e0 91 f4 07 	lds	r30, 0x07F4
    4042:	f0 91 f5 07 	lds	r31, 0x07F5
    4046:	86 81       	ldd	r24, Z+6	; 0x06
    4048:	97 81       	ldd	r25, Z+7	; 0x07
    404a:	9a 83       	std	Y+2, r25	; 0x02
    404c:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    404e:	89 81       	ldd	r24, Y+1	; 0x01
    4050:	9a 81       	ldd	r25, Y+2	; 0x02
    4052:	02 96       	adiw	r24, 0x02	; 2
    4054:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <uxListRemove>
					--uxCurrentNumberOfTasks;
    4058:	80 91 a2 07 	lds	r24, 0x07A2
    405c:	81 50       	subi	r24, 0x01	; 1
    405e:	80 93 a2 07 	sts	0x07A2, r24
					--uxTasksDeleted;
    4062:	80 91 a1 07 	lds	r24, 0x07A1
    4066:	81 50       	subi	r24, 0x01	; 1
    4068:	80 93 a1 07 	sts	0x07A1, r24
				}
				taskEXIT_CRITICAL();
    406c:	0f 90       	pop	r0
    406e:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    4070:	89 81       	ldd	r24, Y+1	; 0x01
    4072:	9a 81       	ldd	r25, Y+2	; 0x02
    4074:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    4078:	80 91 a1 07 	lds	r24, 0x07A1
    407c:	88 23       	and	r24, r24
    407e:	71 f6       	brne	.-100    	; 0x401c <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    4080:	0f 90       	pop	r0
    4082:	0f 90       	pop	r0
    4084:	0f 90       	pop	r0
    4086:	cf 91       	pop	r28
    4088:	df 91       	pop	r29
    408a:	08 95       	ret

0000408c <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    408c:	df 93       	push	r29
    408e:	cf 93       	push	r28
    4090:	00 d0       	rcall	.+0      	; 0x4092 <prvAddCurrentTaskToDelayedList+0x6>
    4092:	cd b7       	in	r28, 0x3d	; 61
    4094:	de b7       	in	r29, 0x3e	; 62
    4096:	9a 83       	std	Y+2, r25	; 0x02
    4098:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    409a:	e0 91 9f 07 	lds	r30, 0x079F
    409e:	f0 91 a0 07 	lds	r31, 0x07A0
    40a2:	89 81       	ldd	r24, Y+1	; 0x01
    40a4:	9a 81       	ldd	r25, Y+2	; 0x02
    40a6:	93 83       	std	Z+3, r25	; 0x03
    40a8:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    40aa:	20 91 a3 07 	lds	r18, 0x07A3
    40ae:	30 91 a4 07 	lds	r19, 0x07A4
    40b2:	89 81       	ldd	r24, Y+1	; 0x01
    40b4:	9a 81       	ldd	r25, Y+2	; 0x02
    40b6:	82 17       	cp	r24, r18
    40b8:	93 07       	cpc	r25, r19
    40ba:	70 f4       	brcc	.+28     	; 0x40d8 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    40bc:	80 91 e4 07 	lds	r24, 0x07E4
    40c0:	90 91 e5 07 	lds	r25, 0x07E5
    40c4:	20 91 9f 07 	lds	r18, 0x079F
    40c8:	30 91 a0 07 	lds	r19, 0x07A0
    40cc:	2e 5f       	subi	r18, 0xFE	; 254
    40ce:	3f 4f       	sbci	r19, 0xFF	; 255
    40d0:	b9 01       	movw	r22, r18
    40d2:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <vListInsert>
    40d6:	1e c0       	rjmp	.+60     	; 0x4114 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    40d8:	40 91 e2 07 	lds	r20, 0x07E2
    40dc:	50 91 e3 07 	lds	r21, 0x07E3
    40e0:	80 91 9f 07 	lds	r24, 0x079F
    40e4:	90 91 a0 07 	lds	r25, 0x07A0
    40e8:	9c 01       	movw	r18, r24
    40ea:	2e 5f       	subi	r18, 0xFE	; 254
    40ec:	3f 4f       	sbci	r19, 0xFF	; 255
    40ee:	ca 01       	movw	r24, r20
    40f0:	b9 01       	movw	r22, r18
    40f2:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    40f6:	20 91 7d 01 	lds	r18, 0x017D
    40fa:	30 91 7e 01 	lds	r19, 0x017E
    40fe:	89 81       	ldd	r24, Y+1	; 0x01
    4100:	9a 81       	ldd	r25, Y+2	; 0x02
    4102:	82 17       	cp	r24, r18
    4104:	93 07       	cpc	r25, r19
    4106:	30 f4       	brcc	.+12     	; 0x4114 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    4108:	89 81       	ldd	r24, Y+1	; 0x01
    410a:	9a 81       	ldd	r25, Y+2	; 0x02
    410c:	90 93 7e 01 	sts	0x017E, r25
    4110:	80 93 7d 01 	sts	0x017D, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    4114:	0f 90       	pop	r0
    4116:	0f 90       	pop	r0
    4118:	cf 91       	pop	r28
    411a:	df 91       	pop	r29
    411c:	08 95       	ret

0000411e <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    411e:	df 93       	push	r29
    4120:	cf 93       	push	r28
    4122:	cd b7       	in	r28, 0x3d	; 61
    4124:	de b7       	in	r29, 0x3e	; 62
    4126:	28 97       	sbiw	r28, 0x08	; 8
    4128:	0f b6       	in	r0, 0x3f	; 63
    412a:	f8 94       	cli
    412c:	de bf       	out	0x3e, r29	; 62
    412e:	0f be       	out	0x3f, r0	; 63
    4130:	cd bf       	out	0x3d, r28	; 61
    4132:	9c 83       	std	Y+4, r25	; 0x04
    4134:	8b 83       	std	Y+3, r24	; 0x03
    4136:	7e 83       	std	Y+6, r23	; 0x06
    4138:	6d 83       	std	Y+5, r22	; 0x05
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    413a:	8d e2       	ldi	r24, 0x2D	; 45
    413c:	90 e0       	ldi	r25, 0x00	; 0
    413e:	0e 94 a5 0c 	call	0x194a	; 0x194a <pvPortMalloc>
    4142:	9a 83       	std	Y+2, r25	; 0x02
    4144:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    4146:	89 81       	ldd	r24, Y+1	; 0x01
    4148:	9a 81       	ldd	r25, Y+2	; 0x02
    414a:	00 97       	sbiw	r24, 0x00	; 0
    414c:	09 f1       	breq	.+66     	; 0x4190 <prvAllocateTCBAndStack+0x72>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    414e:	8d 81       	ldd	r24, Y+5	; 0x05
    4150:	9e 81       	ldd	r25, Y+6	; 0x06
    4152:	00 97       	sbiw	r24, 0x00	; 0
    4154:	39 f4       	brne	.+14     	; 0x4164 <prvAllocateTCBAndStack+0x46>
    4156:	8b 81       	ldd	r24, Y+3	; 0x03
    4158:	9c 81       	ldd	r25, Y+4	; 0x04
    415a:	0e 94 a5 0c 	call	0x194a	; 0x194a <pvPortMalloc>
    415e:	98 87       	std	Y+8, r25	; 0x08
    4160:	8f 83       	std	Y+7, r24	; 0x07
    4162:	04 c0       	rjmp	.+8      	; 0x416c <prvAllocateTCBAndStack+0x4e>
    4164:	8d 81       	ldd	r24, Y+5	; 0x05
    4166:	9e 81       	ldd	r25, Y+6	; 0x06
    4168:	98 87       	std	Y+8, r25	; 0x08
    416a:	8f 83       	std	Y+7, r24	; 0x07
    416c:	e9 81       	ldd	r30, Y+1	; 0x01
    416e:	fa 81       	ldd	r31, Y+2	; 0x02
    4170:	8f 81       	ldd	r24, Y+7	; 0x07
    4172:	98 85       	ldd	r25, Y+8	; 0x08
    4174:	90 8f       	std	Z+24, r25	; 0x18
    4176:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    4178:	e9 81       	ldd	r30, Y+1	; 0x01
    417a:	fa 81       	ldd	r31, Y+2	; 0x02
    417c:	87 89       	ldd	r24, Z+23	; 0x17
    417e:	90 8d       	ldd	r25, Z+24	; 0x18
    4180:	00 97       	sbiw	r24, 0x00	; 0
    4182:	31 f4       	brne	.+12     	; 0x4190 <prvAllocateTCBAndStack+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    4184:	89 81       	ldd	r24, Y+1	; 0x01
    4186:	9a 81       	ldd	r25, Y+2	; 0x02
    4188:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <vPortFree>
			pxNewTCB = NULL;
    418c:	1a 82       	std	Y+2, r1	; 0x02
    418e:	19 82       	std	Y+1, r1	; 0x01
			}
			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
		}
	}

	return pxNewTCB;
    4190:	89 81       	ldd	r24, Y+1	; 0x01
    4192:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4194:	28 96       	adiw	r28, 0x08	; 8
    4196:	0f b6       	in	r0, 0x3f	; 63
    4198:	f8 94       	cli
    419a:	de bf       	out	0x3e, r29	; 62
    419c:	0f be       	out	0x3f, r0	; 63
    419e:	cd bf       	out	0x3d, r28	; 61
    41a0:	cf 91       	pop	r28
    41a2:	df 91       	pop	r29
    41a4:	08 95       	ret

000041a6 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    41a6:	df 93       	push	r29
    41a8:	cf 93       	push	r28
    41aa:	00 d0       	rcall	.+0      	; 0x41ac <prvDeleteTCB+0x6>
    41ac:	cd b7       	in	r28, 0x3d	; 61
    41ae:	de b7       	in	r29, 0x3e	; 62
    41b0:	9a 83       	std	Y+2, r25	; 0x02
    41b2:	89 83       	std	Y+1, r24	; 0x01
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    41b4:	e9 81       	ldd	r30, Y+1	; 0x01
    41b6:	fa 81       	ldd	r31, Y+2	; 0x02
    41b8:	87 89       	ldd	r24, Z+23	; 0x17
    41ba:	90 8d       	ldd	r25, Z+24	; 0x18
    41bc:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <vPortFree>
		vPortFree( pxTCB );
    41c0:	89 81       	ldd	r24, Y+1	; 0x01
    41c2:	9a 81       	ldd	r25, Y+2	; 0x02
    41c4:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <vPortFree>
	}
    41c8:	0f 90       	pop	r0
    41ca:	0f 90       	pop	r0
    41cc:	cf 91       	pop	r28
    41ce:	df 91       	pop	r29
    41d0:	08 95       	ret

000041d2 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    41d2:	df 93       	push	r29
    41d4:	cf 93       	push	r28
    41d6:	00 d0       	rcall	.+0      	; 0x41d8 <prvResetNextTaskUnblockTime+0x6>
    41d8:	cd b7       	in	r28, 0x3d	; 61
    41da:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    41dc:	e0 91 e2 07 	lds	r30, 0x07E2
    41e0:	f0 91 e3 07 	lds	r31, 0x07E3
    41e4:	80 81       	ld	r24, Z
    41e6:	88 23       	and	r24, r24
    41e8:	39 f4       	brne	.+14     	; 0x41f8 <prvResetNextTaskUnblockTime+0x26>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    41ea:	8f ef       	ldi	r24, 0xFF	; 255
    41ec:	9f ef       	ldi	r25, 0xFF	; 255
    41ee:	90 93 7e 01 	sts	0x017E, r25
    41f2:	80 93 7d 01 	sts	0x017D, r24
    41f6:	13 c0       	rjmp	.+38     	; 0x421e <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    41f8:	e0 91 e2 07 	lds	r30, 0x07E2
    41fc:	f0 91 e3 07 	lds	r31, 0x07E3
    4200:	05 80       	ldd	r0, Z+5	; 0x05
    4202:	f6 81       	ldd	r31, Z+6	; 0x06
    4204:	e0 2d       	mov	r30, r0
    4206:	86 81       	ldd	r24, Z+6	; 0x06
    4208:	97 81       	ldd	r25, Z+7	; 0x07
    420a:	9a 83       	std	Y+2, r25	; 0x02
    420c:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    420e:	e9 81       	ldd	r30, Y+1	; 0x01
    4210:	fa 81       	ldd	r31, Y+2	; 0x02
    4212:	82 81       	ldd	r24, Z+2	; 0x02
    4214:	93 81       	ldd	r25, Z+3	; 0x03
    4216:	90 93 7e 01 	sts	0x017E, r25
    421a:	80 93 7d 01 	sts	0x017D, r24
	}
}
    421e:	0f 90       	pop	r0
    4220:	0f 90       	pop	r0
    4222:	cf 91       	pop	r28
    4224:	df 91       	pop	r29
    4226:	08 95       	ret

00004228 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4228:	df 93       	push	r29
    422a:	cf 93       	push	r28
    422c:	00 d0       	rcall	.+0      	; 0x422e <uxTaskResetEventItemValue+0x6>
    422e:	cd b7       	in	r28, 0x3d	; 61
    4230:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4232:	e0 91 9f 07 	lds	r30, 0x079F
    4236:	f0 91 a0 07 	lds	r31, 0x07A0
    423a:	84 85       	ldd	r24, Z+12	; 0x0c
    423c:	95 85       	ldd	r25, Z+13	; 0x0d
    423e:	9a 83       	std	Y+2, r25	; 0x02
    4240:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4242:	a0 91 9f 07 	lds	r26, 0x079F
    4246:	b0 91 a0 07 	lds	r27, 0x07A0
    424a:	e0 91 9f 07 	lds	r30, 0x079F
    424e:	f0 91 a0 07 	lds	r31, 0x07A0
    4252:	86 89       	ldd	r24, Z+22	; 0x16
    4254:	28 2f       	mov	r18, r24
    4256:	30 e0       	ldi	r19, 0x00	; 0
    4258:	84 e0       	ldi	r24, 0x04	; 4
    425a:	90 e0       	ldi	r25, 0x00	; 0
    425c:	82 1b       	sub	r24, r18
    425e:	93 0b       	sbc	r25, r19
    4260:	1d 96       	adiw	r26, 0x0d	; 13
    4262:	9c 93       	st	X, r25
    4264:	8e 93       	st	-X, r24
    4266:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    4268:	89 81       	ldd	r24, Y+1	; 0x01
    426a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    426c:	0f 90       	pop	r0
    426e:	0f 90       	pop	r0
    4270:	cf 91       	pop	r28
    4272:	df 91       	pop	r29
    4274:	08 95       	ret

00004276 <SmartLock_Init>:

#include "SmartHome.h"



void SmartLock_Init(void) {
    4276:	df 93       	push	r29
    4278:	cf 93       	push	r28
    427a:	cd b7       	in	r28, 0x3d	; 61
    427c:	de b7       	in	r29, 0x3e	; 62
    427e:	6c 97       	sbiw	r28, 0x1c	; 28
    4280:	0f b6       	in	r0, 0x3f	; 63
    4282:	f8 94       	cli
    4284:	de bf       	out	0x3e, r29	; 62
    4286:	0f be       	out	0x3f, r0	; 63
    4288:	cd bf       	out	0x3d, r28	; 61
	USART_Init(9600); /* initialize USART with 9600 baud rate */
    428a:	60 e8       	ldi	r22, 0x80	; 128
    428c:	75 e2       	ldi	r23, 0x25	; 37
    428e:	80 e0       	ldi	r24, 0x00	; 0
    4290:	90 e0       	ldi	r25, 0x00	; 0
    4292:	0e 94 a8 2b 	call	0x5750	; 0x5750 <USART_Init>
	DDRB = 0xff; /* make PORT as output port */
    4296:	e7 e3       	ldi	r30, 0x37	; 55
    4298:	f0 e0       	ldi	r31, 0x00	; 0
    429a:	8f ef       	ldi	r24, 0xFF	; 255
    429c:	80 83       	st	Z, r24
	DDRC = 0X00;
    429e:	e4 e3       	ldi	r30, 0x34	; 52
    42a0:	f0 e0       	ldi	r31, 0x00	; 0
    42a2:	10 82       	st	Z, r1
	LED1_BUZZER_LED2 = 0;
    42a4:	e8 e3       	ldi	r30, 0x38	; 56
    42a6:	f0 e0       	ldi	r31, 0x00	; 0
    42a8:	10 82       	st	Z, r1
	USART_SendString("SmartLock\r");
    42aa:	8d e7       	ldi	r24, 0x7D	; 125
    42ac:	90 e0       	ldi	r25, 0x00	; 0
    42ae:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <USART_SendString>
    42b2:	80 e0       	ldi	r24, 0x00	; 0
    42b4:	90 e0       	ldi	r25, 0x00	; 0
    42b6:	aa ef       	ldi	r26, 0xFA	; 250
    42b8:	b3 e4       	ldi	r27, 0x43	; 67
    42ba:	89 8f       	std	Y+25, r24	; 0x19
    42bc:	9a 8f       	std	Y+26, r25	; 0x1a
    42be:	ab 8f       	std	Y+27, r26	; 0x1b
    42c0:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    42c2:	69 8d       	ldd	r22, Y+25	; 0x19
    42c4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    42c6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    42c8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    42ca:	20 e0       	ldi	r18, 0x00	; 0
    42cc:	30 e0       	ldi	r19, 0x00	; 0
    42ce:	4a ef       	ldi	r20, 0xFA	; 250
    42d0:	54 e4       	ldi	r21, 0x44	; 68
    42d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    42d6:	dc 01       	movw	r26, r24
    42d8:	cb 01       	movw	r24, r22
    42da:	8d 8b       	std	Y+21, r24	; 0x15
    42dc:	9e 8b       	std	Y+22, r25	; 0x16
    42de:	af 8b       	std	Y+23, r26	; 0x17
    42e0:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    42e2:	6d 89       	ldd	r22, Y+21	; 0x15
    42e4:	7e 89       	ldd	r23, Y+22	; 0x16
    42e6:	8f 89       	ldd	r24, Y+23	; 0x17
    42e8:	98 8d       	ldd	r25, Y+24	; 0x18
    42ea:	20 e0       	ldi	r18, 0x00	; 0
    42ec:	30 e0       	ldi	r19, 0x00	; 0
    42ee:	40 e8       	ldi	r20, 0x80	; 128
    42f0:	5f e3       	ldi	r21, 0x3F	; 63
    42f2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    42f6:	88 23       	and	r24, r24
    42f8:	2c f4       	brge	.+10     	; 0x4304 <SmartLock_Init+0x8e>
		__ticks = 1;
    42fa:	81 e0       	ldi	r24, 0x01	; 1
    42fc:	90 e0       	ldi	r25, 0x00	; 0
    42fe:	9c 8b       	std	Y+20, r25	; 0x14
    4300:	8b 8b       	std	Y+19, r24	; 0x13
    4302:	3f c0       	rjmp	.+126    	; 0x4382 <SmartLock_Init+0x10c>
	else if (__tmp > 65535)
    4304:	6d 89       	ldd	r22, Y+21	; 0x15
    4306:	7e 89       	ldd	r23, Y+22	; 0x16
    4308:	8f 89       	ldd	r24, Y+23	; 0x17
    430a:	98 8d       	ldd	r25, Y+24	; 0x18
    430c:	20 e0       	ldi	r18, 0x00	; 0
    430e:	3f ef       	ldi	r19, 0xFF	; 255
    4310:	4f e7       	ldi	r20, 0x7F	; 127
    4312:	57 e4       	ldi	r21, 0x47	; 71
    4314:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4318:	18 16       	cp	r1, r24
    431a:	4c f5       	brge	.+82     	; 0x436e <SmartLock_Init+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    431c:	69 8d       	ldd	r22, Y+25	; 0x19
    431e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4320:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4322:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4324:	20 e0       	ldi	r18, 0x00	; 0
    4326:	30 e0       	ldi	r19, 0x00	; 0
    4328:	40 e2       	ldi	r20, 0x20	; 32
    432a:	51 e4       	ldi	r21, 0x41	; 65
    432c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4330:	dc 01       	movw	r26, r24
    4332:	cb 01       	movw	r24, r22
    4334:	bc 01       	movw	r22, r24
    4336:	cd 01       	movw	r24, r26
    4338:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    433c:	dc 01       	movw	r26, r24
    433e:	cb 01       	movw	r24, r22
    4340:	9c 8b       	std	Y+20, r25	; 0x14
    4342:	8b 8b       	std	Y+19, r24	; 0x13
    4344:	0f c0       	rjmp	.+30     	; 0x4364 <SmartLock_Init+0xee>
    4346:	88 ec       	ldi	r24, 0xC8	; 200
    4348:	90 e0       	ldi	r25, 0x00	; 0
    434a:	9a 8b       	std	Y+18, r25	; 0x12
    434c:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    434e:	89 89       	ldd	r24, Y+17	; 0x11
    4350:	9a 89       	ldd	r25, Y+18	; 0x12
    4352:	01 97       	sbiw	r24, 0x01	; 1
    4354:	f1 f7       	brne	.-4      	; 0x4352 <SmartLock_Init+0xdc>
    4356:	9a 8b       	std	Y+18, r25	; 0x12
    4358:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    435a:	8b 89       	ldd	r24, Y+19	; 0x13
    435c:	9c 89       	ldd	r25, Y+20	; 0x14
    435e:	01 97       	sbiw	r24, 0x01	; 1
    4360:	9c 8b       	std	Y+20, r25	; 0x14
    4362:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4364:	8b 89       	ldd	r24, Y+19	; 0x13
    4366:	9c 89       	ldd	r25, Y+20	; 0x14
    4368:	00 97       	sbiw	r24, 0x00	; 0
    436a:	69 f7       	brne	.-38     	; 0x4346 <SmartLock_Init+0xd0>
    436c:	14 c0       	rjmp	.+40     	; 0x4396 <SmartLock_Init+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    436e:	6d 89       	ldd	r22, Y+21	; 0x15
    4370:	7e 89       	ldd	r23, Y+22	; 0x16
    4372:	8f 89       	ldd	r24, Y+23	; 0x17
    4374:	98 8d       	ldd	r25, Y+24	; 0x18
    4376:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    437a:	dc 01       	movw	r26, r24
    437c:	cb 01       	movw	r24, r22
    437e:	9c 8b       	std	Y+20, r25	; 0x14
    4380:	8b 8b       	std	Y+19, r24	; 0x13
    4382:	8b 89       	ldd	r24, Y+19	; 0x13
    4384:	9c 89       	ldd	r25, Y+20	; 0x14
    4386:	98 8b       	std	Y+16, r25	; 0x10
    4388:	8f 87       	std	Y+15, r24	; 0x0f
    438a:	8f 85       	ldd	r24, Y+15	; 0x0f
    438c:	98 89       	ldd	r25, Y+16	; 0x10
    438e:	01 97       	sbiw	r24, 0x01	; 1
    4390:	f1 f7       	brne	.-4      	; 0x438e <SmartLock_Init+0x118>
    4392:	98 8b       	std	Y+16, r25	; 0x10
    4394:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(500);
	USART_SendString("Please Login\r");
    4396:	88 e8       	ldi	r24, 0x88	; 136
    4398:	90 e0       	ldi	r25, 0x00	; 0
    439a:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <USART_SendString>
    439e:	80 e0       	ldi	r24, 0x00	; 0
    43a0:	90 e0       	ldi	r25, 0x00	; 0
    43a2:	aa ef       	ldi	r26, 0xFA	; 250
    43a4:	b3 e4       	ldi	r27, 0x43	; 67
    43a6:	8b 87       	std	Y+11, r24	; 0x0b
    43a8:	9c 87       	std	Y+12, r25	; 0x0c
    43aa:	ad 87       	std	Y+13, r26	; 0x0d
    43ac:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    43ae:	6b 85       	ldd	r22, Y+11	; 0x0b
    43b0:	7c 85       	ldd	r23, Y+12	; 0x0c
    43b2:	8d 85       	ldd	r24, Y+13	; 0x0d
    43b4:	9e 85       	ldd	r25, Y+14	; 0x0e
    43b6:	20 e0       	ldi	r18, 0x00	; 0
    43b8:	30 e0       	ldi	r19, 0x00	; 0
    43ba:	4a ef       	ldi	r20, 0xFA	; 250
    43bc:	54 e4       	ldi	r21, 0x44	; 68
    43be:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    43c2:	dc 01       	movw	r26, r24
    43c4:	cb 01       	movw	r24, r22
    43c6:	8f 83       	std	Y+7, r24	; 0x07
    43c8:	98 87       	std	Y+8, r25	; 0x08
    43ca:	a9 87       	std	Y+9, r26	; 0x09
    43cc:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    43ce:	6f 81       	ldd	r22, Y+7	; 0x07
    43d0:	78 85       	ldd	r23, Y+8	; 0x08
    43d2:	89 85       	ldd	r24, Y+9	; 0x09
    43d4:	9a 85       	ldd	r25, Y+10	; 0x0a
    43d6:	20 e0       	ldi	r18, 0x00	; 0
    43d8:	30 e0       	ldi	r19, 0x00	; 0
    43da:	40 e8       	ldi	r20, 0x80	; 128
    43dc:	5f e3       	ldi	r21, 0x3F	; 63
    43de:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    43e2:	88 23       	and	r24, r24
    43e4:	2c f4       	brge	.+10     	; 0x43f0 <SmartLock_Init+0x17a>
		__ticks = 1;
    43e6:	81 e0       	ldi	r24, 0x01	; 1
    43e8:	90 e0       	ldi	r25, 0x00	; 0
    43ea:	9e 83       	std	Y+6, r25	; 0x06
    43ec:	8d 83       	std	Y+5, r24	; 0x05
    43ee:	3f c0       	rjmp	.+126    	; 0x446e <SmartLock_Init+0x1f8>
	else if (__tmp > 65535)
    43f0:	6f 81       	ldd	r22, Y+7	; 0x07
    43f2:	78 85       	ldd	r23, Y+8	; 0x08
    43f4:	89 85       	ldd	r24, Y+9	; 0x09
    43f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    43f8:	20 e0       	ldi	r18, 0x00	; 0
    43fa:	3f ef       	ldi	r19, 0xFF	; 255
    43fc:	4f e7       	ldi	r20, 0x7F	; 127
    43fe:	57 e4       	ldi	r21, 0x47	; 71
    4400:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4404:	18 16       	cp	r1, r24
    4406:	4c f5       	brge	.+82     	; 0x445a <SmartLock_Init+0x1e4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4408:	6b 85       	ldd	r22, Y+11	; 0x0b
    440a:	7c 85       	ldd	r23, Y+12	; 0x0c
    440c:	8d 85       	ldd	r24, Y+13	; 0x0d
    440e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4410:	20 e0       	ldi	r18, 0x00	; 0
    4412:	30 e0       	ldi	r19, 0x00	; 0
    4414:	40 e2       	ldi	r20, 0x20	; 32
    4416:	51 e4       	ldi	r21, 0x41	; 65
    4418:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    441c:	dc 01       	movw	r26, r24
    441e:	cb 01       	movw	r24, r22
    4420:	bc 01       	movw	r22, r24
    4422:	cd 01       	movw	r24, r26
    4424:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4428:	dc 01       	movw	r26, r24
    442a:	cb 01       	movw	r24, r22
    442c:	9e 83       	std	Y+6, r25	; 0x06
    442e:	8d 83       	std	Y+5, r24	; 0x05
    4430:	0f c0       	rjmp	.+30     	; 0x4450 <SmartLock_Init+0x1da>
    4432:	88 ec       	ldi	r24, 0xC8	; 200
    4434:	90 e0       	ldi	r25, 0x00	; 0
    4436:	9c 83       	std	Y+4, r25	; 0x04
    4438:	8b 83       	std	Y+3, r24	; 0x03
    443a:	8b 81       	ldd	r24, Y+3	; 0x03
    443c:	9c 81       	ldd	r25, Y+4	; 0x04
    443e:	01 97       	sbiw	r24, 0x01	; 1
    4440:	f1 f7       	brne	.-4      	; 0x443e <SmartLock_Init+0x1c8>
    4442:	9c 83       	std	Y+4, r25	; 0x04
    4444:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4446:	8d 81       	ldd	r24, Y+5	; 0x05
    4448:	9e 81       	ldd	r25, Y+6	; 0x06
    444a:	01 97       	sbiw	r24, 0x01	; 1
    444c:	9e 83       	std	Y+6, r25	; 0x06
    444e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4450:	8d 81       	ldd	r24, Y+5	; 0x05
    4452:	9e 81       	ldd	r25, Y+6	; 0x06
    4454:	00 97       	sbiw	r24, 0x00	; 0
    4456:	69 f7       	brne	.-38     	; 0x4432 <SmartLock_Init+0x1bc>
    4458:	14 c0       	rjmp	.+40     	; 0x4482 <SmartLock_Init+0x20c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    445a:	6f 81       	ldd	r22, Y+7	; 0x07
    445c:	78 85       	ldd	r23, Y+8	; 0x08
    445e:	89 85       	ldd	r24, Y+9	; 0x09
    4460:	9a 85       	ldd	r25, Y+10	; 0x0a
    4462:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4466:	dc 01       	movw	r26, r24
    4468:	cb 01       	movw	r24, r22
    446a:	9e 83       	std	Y+6, r25	; 0x06
    446c:	8d 83       	std	Y+5, r24	; 0x05
    446e:	8d 81       	ldd	r24, Y+5	; 0x05
    4470:	9e 81       	ldd	r25, Y+6	; 0x06
    4472:	9a 83       	std	Y+2, r25	; 0x02
    4474:	89 83       	std	Y+1, r24	; 0x01
    4476:	89 81       	ldd	r24, Y+1	; 0x01
    4478:	9a 81       	ldd	r25, Y+2	; 0x02
    447a:	01 97       	sbiw	r24, 0x01	; 1
    447c:	f1 f7       	brne	.-4      	; 0x447a <SmartLock_Init+0x204>
    447e:	9a 83       	std	Y+2, r25	; 0x02
    4480:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(500);
}
    4482:	6c 96       	adiw	r28, 0x1c	; 28
    4484:	0f b6       	in	r0, 0x3f	; 63
    4486:	f8 94       	cli
    4488:	de bf       	out	0x3e, r29	; 62
    448a:	0f be       	out	0x3f, r0	; 63
    448c:	cd bf       	out	0x3d, r28	; 61
    448e:	cf 91       	pop	r28
    4490:	df 91       	pop	r29
    4492:	08 95       	ret

00004494 <CheckLogin>:
char CheckLogin(void) {
    4494:	df 93       	push	r29
    4496:	cf 93       	push	r28
    4498:	cd b7       	in	r28, 0x3d	; 61
    449a:	de b7       	in	r29, 0x3e	; 62
    449c:	c3 5e       	subi	r28, 0xE3	; 227
    449e:	d1 40       	sbci	r29, 0x01	; 1
    44a0:	0f b6       	in	r0, 0x3f	; 63
    44a2:	f8 94       	cli
    44a4:	de bf       	out	0x3e, r29	; 62
    44a6:	0f be       	out	0x3f, r0	; 63
    44a8:	cd bf       	out	0x3d, r28	; 61
	char i = 0;
    44aa:	1b 82       	std	Y+3, r1	; 0x03
	char state = 0;
    44ac:	1a 82       	std	Y+2, r1	; 0x02
	char username[10][8] = { "wael1\r", "wael2\r", "wael3\r", "wael4\r",
			"wael5\r", "wael6\r", "wael7\r", "wael8\r", "wael9\r", "wael10\r" };
    44ae:	80 e5       	ldi	r24, 0x50	; 80
    44b0:	fe 01       	movw	r30, r28
    44b2:	34 96       	adiw	r30, 0x04	; 4
    44b4:	df 01       	movw	r26, r30
    44b6:	98 2f       	mov	r25, r24
    44b8:	1d 92       	st	X+, r1
    44ba:	9a 95       	dec	r25
    44bc:	e9 f7       	brne	.-6      	; 0x44b8 <CheckLogin+0x24>
    44be:	de 01       	movw	r26, r28
    44c0:	14 96       	adiw	r26, 0x04	; 4
    44c2:	c4 59       	subi	r28, 0x94	; 148
    44c4:	de 4f       	sbci	r29, 0xFE	; 254
    44c6:	b9 83       	std	Y+1, r27	; 0x01
    44c8:	a8 83       	st	Y, r26
    44ca:	cc 56       	subi	r28, 0x6C	; 108
    44cc:	d1 40       	sbci	r29, 0x01	; 1
    44ce:	e6 eb       	ldi	r30, 0xB6	; 182
    44d0:	f0 e0       	ldi	r31, 0x00	; 0
    44d2:	c2 59       	subi	r28, 0x92	; 146
    44d4:	de 4f       	sbci	r29, 0xFE	; 254
    44d6:	f9 83       	std	Y+1, r31	; 0x01
    44d8:	e8 83       	st	Y, r30
    44da:	ce 56       	subi	r28, 0x6E	; 110
    44dc:	d1 40       	sbci	r29, 0x01	; 1
    44de:	f7 e0       	ldi	r31, 0x07	; 7
    44e0:	c0 59       	subi	r28, 0x90	; 144
    44e2:	de 4f       	sbci	r29, 0xFE	; 254
    44e4:	f8 83       	st	Y, r31
    44e6:	c0 57       	subi	r28, 0x70	; 112
    44e8:	d1 40       	sbci	r29, 0x01	; 1
    44ea:	c2 59       	subi	r28, 0x92	; 146
    44ec:	de 4f       	sbci	r29, 0xFE	; 254
    44ee:	a8 81       	ld	r26, Y
    44f0:	b9 81       	ldd	r27, Y+1	; 0x01
    44f2:	ce 56       	subi	r28, 0x6E	; 110
    44f4:	d1 40       	sbci	r29, 0x01	; 1
    44f6:	0c 90       	ld	r0, X
    44f8:	c2 59       	subi	r28, 0x92	; 146
    44fa:	de 4f       	sbci	r29, 0xFE	; 254
    44fc:	e8 81       	ld	r30, Y
    44fe:	f9 81       	ldd	r31, Y+1	; 0x01
    4500:	ce 56       	subi	r28, 0x6E	; 110
    4502:	d1 40       	sbci	r29, 0x01	; 1
    4504:	31 96       	adiw	r30, 0x01	; 1
    4506:	c2 59       	subi	r28, 0x92	; 146
    4508:	de 4f       	sbci	r29, 0xFE	; 254
    450a:	f9 83       	std	Y+1, r31	; 0x01
    450c:	e8 83       	st	Y, r30
    450e:	ce 56       	subi	r28, 0x6E	; 110
    4510:	d1 40       	sbci	r29, 0x01	; 1
    4512:	c4 59       	subi	r28, 0x94	; 148
    4514:	de 4f       	sbci	r29, 0xFE	; 254
    4516:	a8 81       	ld	r26, Y
    4518:	b9 81       	ldd	r27, Y+1	; 0x01
    451a:	cc 56       	subi	r28, 0x6C	; 108
    451c:	d1 40       	sbci	r29, 0x01	; 1
    451e:	0c 92       	st	X, r0
    4520:	c4 59       	subi	r28, 0x94	; 148
    4522:	de 4f       	sbci	r29, 0xFE	; 254
    4524:	e8 81       	ld	r30, Y
    4526:	f9 81       	ldd	r31, Y+1	; 0x01
    4528:	cc 56       	subi	r28, 0x6C	; 108
    452a:	d1 40       	sbci	r29, 0x01	; 1
    452c:	31 96       	adiw	r30, 0x01	; 1
    452e:	c4 59       	subi	r28, 0x94	; 148
    4530:	de 4f       	sbci	r29, 0xFE	; 254
    4532:	f9 83       	std	Y+1, r31	; 0x01
    4534:	e8 83       	st	Y, r30
    4536:	cc 56       	subi	r28, 0x6C	; 108
    4538:	d1 40       	sbci	r29, 0x01	; 1
    453a:	c0 59       	subi	r28, 0x90	; 144
    453c:	de 4f       	sbci	r29, 0xFE	; 254
    453e:	f8 81       	ld	r31, Y
    4540:	c0 57       	subi	r28, 0x70	; 112
    4542:	d1 40       	sbci	r29, 0x01	; 1
    4544:	f1 50       	subi	r31, 0x01	; 1
    4546:	c0 59       	subi	r28, 0x90	; 144
    4548:	de 4f       	sbci	r29, 0xFE	; 254
    454a:	f8 83       	st	Y, r31
    454c:	c0 57       	subi	r28, 0x70	; 112
    454e:	d1 40       	sbci	r29, 0x01	; 1
    4550:	c0 59       	subi	r28, 0x90	; 144
    4552:	de 4f       	sbci	r29, 0xFE	; 254
    4554:	88 81       	ld	r24, Y
    4556:	c0 57       	subi	r28, 0x70	; 112
    4558:	d1 40       	sbci	r29, 0x01	; 1
    455a:	88 23       	and	r24, r24
    455c:	31 f6       	brne	.-116    	; 0x44ea <CheckLogin+0x56>
    455e:	1b 86       	std	Y+11, r1	; 0x0b
    4560:	de 01       	movw	r26, r28
    4562:	1c 96       	adiw	r26, 0x0c	; 12
    4564:	cf 58       	subi	r28, 0x8F	; 143
    4566:	de 4f       	sbci	r29, 0xFE	; 254
    4568:	b9 83       	std	Y+1, r27	; 0x01
    456a:	a8 83       	st	Y, r26
    456c:	c1 57       	subi	r28, 0x71	; 113
    456e:	d1 40       	sbci	r29, 0x01	; 1
    4570:	ee eb       	ldi	r30, 0xBE	; 190
    4572:	f0 e0       	ldi	r31, 0x00	; 0
    4574:	cd 58       	subi	r28, 0x8D	; 141
    4576:	de 4f       	sbci	r29, 0xFE	; 254
    4578:	f9 83       	std	Y+1, r31	; 0x01
    457a:	e8 83       	st	Y, r30
    457c:	c3 57       	subi	r28, 0x73	; 115
    457e:	d1 40       	sbci	r29, 0x01	; 1
    4580:	f7 e0       	ldi	r31, 0x07	; 7
    4582:	cb 58       	subi	r28, 0x8B	; 139
    4584:	de 4f       	sbci	r29, 0xFE	; 254
    4586:	f8 83       	st	Y, r31
    4588:	c5 57       	subi	r28, 0x75	; 117
    458a:	d1 40       	sbci	r29, 0x01	; 1
    458c:	cd 58       	subi	r28, 0x8D	; 141
    458e:	de 4f       	sbci	r29, 0xFE	; 254
    4590:	a8 81       	ld	r26, Y
    4592:	b9 81       	ldd	r27, Y+1	; 0x01
    4594:	c3 57       	subi	r28, 0x73	; 115
    4596:	d1 40       	sbci	r29, 0x01	; 1
    4598:	0c 90       	ld	r0, X
    459a:	cd 58       	subi	r28, 0x8D	; 141
    459c:	de 4f       	sbci	r29, 0xFE	; 254
    459e:	e8 81       	ld	r30, Y
    45a0:	f9 81       	ldd	r31, Y+1	; 0x01
    45a2:	c3 57       	subi	r28, 0x73	; 115
    45a4:	d1 40       	sbci	r29, 0x01	; 1
    45a6:	31 96       	adiw	r30, 0x01	; 1
    45a8:	cd 58       	subi	r28, 0x8D	; 141
    45aa:	de 4f       	sbci	r29, 0xFE	; 254
    45ac:	f9 83       	std	Y+1, r31	; 0x01
    45ae:	e8 83       	st	Y, r30
    45b0:	c3 57       	subi	r28, 0x73	; 115
    45b2:	d1 40       	sbci	r29, 0x01	; 1
    45b4:	cf 58       	subi	r28, 0x8F	; 143
    45b6:	de 4f       	sbci	r29, 0xFE	; 254
    45b8:	a8 81       	ld	r26, Y
    45ba:	b9 81       	ldd	r27, Y+1	; 0x01
    45bc:	c1 57       	subi	r28, 0x71	; 113
    45be:	d1 40       	sbci	r29, 0x01	; 1
    45c0:	0c 92       	st	X, r0
    45c2:	cf 58       	subi	r28, 0x8F	; 143
    45c4:	de 4f       	sbci	r29, 0xFE	; 254
    45c6:	e8 81       	ld	r30, Y
    45c8:	f9 81       	ldd	r31, Y+1	; 0x01
    45ca:	c1 57       	subi	r28, 0x71	; 113
    45cc:	d1 40       	sbci	r29, 0x01	; 1
    45ce:	31 96       	adiw	r30, 0x01	; 1
    45d0:	cf 58       	subi	r28, 0x8F	; 143
    45d2:	de 4f       	sbci	r29, 0xFE	; 254
    45d4:	f9 83       	std	Y+1, r31	; 0x01
    45d6:	e8 83       	st	Y, r30
    45d8:	c1 57       	subi	r28, 0x71	; 113
    45da:	d1 40       	sbci	r29, 0x01	; 1
    45dc:	cb 58       	subi	r28, 0x8B	; 139
    45de:	de 4f       	sbci	r29, 0xFE	; 254
    45e0:	f8 81       	ld	r31, Y
    45e2:	c5 57       	subi	r28, 0x75	; 117
    45e4:	d1 40       	sbci	r29, 0x01	; 1
    45e6:	f1 50       	subi	r31, 0x01	; 1
    45e8:	cb 58       	subi	r28, 0x8B	; 139
    45ea:	de 4f       	sbci	r29, 0xFE	; 254
    45ec:	f8 83       	st	Y, r31
    45ee:	c5 57       	subi	r28, 0x75	; 117
    45f0:	d1 40       	sbci	r29, 0x01	; 1
    45f2:	cb 58       	subi	r28, 0x8B	; 139
    45f4:	de 4f       	sbci	r29, 0xFE	; 254
    45f6:	88 81       	ld	r24, Y
    45f8:	c5 57       	subi	r28, 0x75	; 117
    45fa:	d1 40       	sbci	r29, 0x01	; 1
    45fc:	88 23       	and	r24, r24
    45fe:	31 f6       	brne	.-116    	; 0x458c <CheckLogin+0xf8>
    4600:	1b 8a       	std	Y+19, r1	; 0x13
    4602:	de 01       	movw	r26, r28
    4604:	54 96       	adiw	r26, 0x14	; 20
    4606:	ca 58       	subi	r28, 0x8A	; 138
    4608:	de 4f       	sbci	r29, 0xFE	; 254
    460a:	b9 83       	std	Y+1, r27	; 0x01
    460c:	a8 83       	st	Y, r26
    460e:	c6 57       	subi	r28, 0x76	; 118
    4610:	d1 40       	sbci	r29, 0x01	; 1
    4612:	e6 ec       	ldi	r30, 0xC6	; 198
    4614:	f0 e0       	ldi	r31, 0x00	; 0
    4616:	c8 58       	subi	r28, 0x88	; 136
    4618:	de 4f       	sbci	r29, 0xFE	; 254
    461a:	f9 83       	std	Y+1, r31	; 0x01
    461c:	e8 83       	st	Y, r30
    461e:	c8 57       	subi	r28, 0x78	; 120
    4620:	d1 40       	sbci	r29, 0x01	; 1
    4622:	f7 e0       	ldi	r31, 0x07	; 7
    4624:	c6 58       	subi	r28, 0x86	; 134
    4626:	de 4f       	sbci	r29, 0xFE	; 254
    4628:	f8 83       	st	Y, r31
    462a:	ca 57       	subi	r28, 0x7A	; 122
    462c:	d1 40       	sbci	r29, 0x01	; 1
    462e:	c8 58       	subi	r28, 0x88	; 136
    4630:	de 4f       	sbci	r29, 0xFE	; 254
    4632:	a8 81       	ld	r26, Y
    4634:	b9 81       	ldd	r27, Y+1	; 0x01
    4636:	c8 57       	subi	r28, 0x78	; 120
    4638:	d1 40       	sbci	r29, 0x01	; 1
    463a:	0c 90       	ld	r0, X
    463c:	c8 58       	subi	r28, 0x88	; 136
    463e:	de 4f       	sbci	r29, 0xFE	; 254
    4640:	e8 81       	ld	r30, Y
    4642:	f9 81       	ldd	r31, Y+1	; 0x01
    4644:	c8 57       	subi	r28, 0x78	; 120
    4646:	d1 40       	sbci	r29, 0x01	; 1
    4648:	31 96       	adiw	r30, 0x01	; 1
    464a:	c8 58       	subi	r28, 0x88	; 136
    464c:	de 4f       	sbci	r29, 0xFE	; 254
    464e:	f9 83       	std	Y+1, r31	; 0x01
    4650:	e8 83       	st	Y, r30
    4652:	c8 57       	subi	r28, 0x78	; 120
    4654:	d1 40       	sbci	r29, 0x01	; 1
    4656:	ca 58       	subi	r28, 0x8A	; 138
    4658:	de 4f       	sbci	r29, 0xFE	; 254
    465a:	a8 81       	ld	r26, Y
    465c:	b9 81       	ldd	r27, Y+1	; 0x01
    465e:	c6 57       	subi	r28, 0x76	; 118
    4660:	d1 40       	sbci	r29, 0x01	; 1
    4662:	0c 92       	st	X, r0
    4664:	ca 58       	subi	r28, 0x8A	; 138
    4666:	de 4f       	sbci	r29, 0xFE	; 254
    4668:	e8 81       	ld	r30, Y
    466a:	f9 81       	ldd	r31, Y+1	; 0x01
    466c:	c6 57       	subi	r28, 0x76	; 118
    466e:	d1 40       	sbci	r29, 0x01	; 1
    4670:	31 96       	adiw	r30, 0x01	; 1
    4672:	ca 58       	subi	r28, 0x8A	; 138
    4674:	de 4f       	sbci	r29, 0xFE	; 254
    4676:	f9 83       	std	Y+1, r31	; 0x01
    4678:	e8 83       	st	Y, r30
    467a:	c6 57       	subi	r28, 0x76	; 118
    467c:	d1 40       	sbci	r29, 0x01	; 1
    467e:	c6 58       	subi	r28, 0x86	; 134
    4680:	de 4f       	sbci	r29, 0xFE	; 254
    4682:	f8 81       	ld	r31, Y
    4684:	ca 57       	subi	r28, 0x7A	; 122
    4686:	d1 40       	sbci	r29, 0x01	; 1
    4688:	f1 50       	subi	r31, 0x01	; 1
    468a:	c6 58       	subi	r28, 0x86	; 134
    468c:	de 4f       	sbci	r29, 0xFE	; 254
    468e:	f8 83       	st	Y, r31
    4690:	ca 57       	subi	r28, 0x7A	; 122
    4692:	d1 40       	sbci	r29, 0x01	; 1
    4694:	c6 58       	subi	r28, 0x86	; 134
    4696:	de 4f       	sbci	r29, 0xFE	; 254
    4698:	88 81       	ld	r24, Y
    469a:	ca 57       	subi	r28, 0x7A	; 122
    469c:	d1 40       	sbci	r29, 0x01	; 1
    469e:	88 23       	and	r24, r24
    46a0:	31 f6       	brne	.-116    	; 0x462e <CheckLogin+0x19a>
    46a2:	1b 8e       	std	Y+27, r1	; 0x1b
    46a4:	de 01       	movw	r26, r28
    46a6:	5c 96       	adiw	r26, 0x1c	; 28
    46a8:	c5 58       	subi	r28, 0x85	; 133
    46aa:	de 4f       	sbci	r29, 0xFE	; 254
    46ac:	b9 83       	std	Y+1, r27	; 0x01
    46ae:	a8 83       	st	Y, r26
    46b0:	cb 57       	subi	r28, 0x7B	; 123
    46b2:	d1 40       	sbci	r29, 0x01	; 1
    46b4:	ee ec       	ldi	r30, 0xCE	; 206
    46b6:	f0 e0       	ldi	r31, 0x00	; 0
    46b8:	c3 58       	subi	r28, 0x83	; 131
    46ba:	de 4f       	sbci	r29, 0xFE	; 254
    46bc:	f9 83       	std	Y+1, r31	; 0x01
    46be:	e8 83       	st	Y, r30
    46c0:	cd 57       	subi	r28, 0x7D	; 125
    46c2:	d1 40       	sbci	r29, 0x01	; 1
    46c4:	f7 e0       	ldi	r31, 0x07	; 7
    46c6:	c1 58       	subi	r28, 0x81	; 129
    46c8:	de 4f       	sbci	r29, 0xFE	; 254
    46ca:	f8 83       	st	Y, r31
    46cc:	cf 57       	subi	r28, 0x7F	; 127
    46ce:	d1 40       	sbci	r29, 0x01	; 1
    46d0:	c3 58       	subi	r28, 0x83	; 131
    46d2:	de 4f       	sbci	r29, 0xFE	; 254
    46d4:	a8 81       	ld	r26, Y
    46d6:	b9 81       	ldd	r27, Y+1	; 0x01
    46d8:	cd 57       	subi	r28, 0x7D	; 125
    46da:	d1 40       	sbci	r29, 0x01	; 1
    46dc:	0c 90       	ld	r0, X
    46de:	c3 58       	subi	r28, 0x83	; 131
    46e0:	de 4f       	sbci	r29, 0xFE	; 254
    46e2:	e8 81       	ld	r30, Y
    46e4:	f9 81       	ldd	r31, Y+1	; 0x01
    46e6:	cd 57       	subi	r28, 0x7D	; 125
    46e8:	d1 40       	sbci	r29, 0x01	; 1
    46ea:	31 96       	adiw	r30, 0x01	; 1
    46ec:	c3 58       	subi	r28, 0x83	; 131
    46ee:	de 4f       	sbci	r29, 0xFE	; 254
    46f0:	f9 83       	std	Y+1, r31	; 0x01
    46f2:	e8 83       	st	Y, r30
    46f4:	cd 57       	subi	r28, 0x7D	; 125
    46f6:	d1 40       	sbci	r29, 0x01	; 1
    46f8:	c5 58       	subi	r28, 0x85	; 133
    46fa:	de 4f       	sbci	r29, 0xFE	; 254
    46fc:	a8 81       	ld	r26, Y
    46fe:	b9 81       	ldd	r27, Y+1	; 0x01
    4700:	cb 57       	subi	r28, 0x7B	; 123
    4702:	d1 40       	sbci	r29, 0x01	; 1
    4704:	0c 92       	st	X, r0
    4706:	c5 58       	subi	r28, 0x85	; 133
    4708:	de 4f       	sbci	r29, 0xFE	; 254
    470a:	e8 81       	ld	r30, Y
    470c:	f9 81       	ldd	r31, Y+1	; 0x01
    470e:	cb 57       	subi	r28, 0x7B	; 123
    4710:	d1 40       	sbci	r29, 0x01	; 1
    4712:	31 96       	adiw	r30, 0x01	; 1
    4714:	c5 58       	subi	r28, 0x85	; 133
    4716:	de 4f       	sbci	r29, 0xFE	; 254
    4718:	f9 83       	std	Y+1, r31	; 0x01
    471a:	e8 83       	st	Y, r30
    471c:	cb 57       	subi	r28, 0x7B	; 123
    471e:	d1 40       	sbci	r29, 0x01	; 1
    4720:	c1 58       	subi	r28, 0x81	; 129
    4722:	de 4f       	sbci	r29, 0xFE	; 254
    4724:	f8 81       	ld	r31, Y
    4726:	cf 57       	subi	r28, 0x7F	; 127
    4728:	d1 40       	sbci	r29, 0x01	; 1
    472a:	f1 50       	subi	r31, 0x01	; 1
    472c:	c1 58       	subi	r28, 0x81	; 129
    472e:	de 4f       	sbci	r29, 0xFE	; 254
    4730:	f8 83       	st	Y, r31
    4732:	cf 57       	subi	r28, 0x7F	; 127
    4734:	d1 40       	sbci	r29, 0x01	; 1
    4736:	c1 58       	subi	r28, 0x81	; 129
    4738:	de 4f       	sbci	r29, 0xFE	; 254
    473a:	88 81       	ld	r24, Y
    473c:	cf 57       	subi	r28, 0x7F	; 127
    473e:	d1 40       	sbci	r29, 0x01	; 1
    4740:	88 23       	and	r24, r24
    4742:	31 f6       	brne	.-116    	; 0x46d0 <CheckLogin+0x23c>
    4744:	1b a2       	std	Y+35, r1	; 0x23
    4746:	de 01       	movw	r26, r28
    4748:	94 96       	adiw	r26, 0x24	; 36
    474a:	c0 58       	subi	r28, 0x80	; 128
    474c:	de 4f       	sbci	r29, 0xFE	; 254
    474e:	b9 83       	std	Y+1, r27	; 0x01
    4750:	a8 83       	st	Y, r26
    4752:	c0 58       	subi	r28, 0x80	; 128
    4754:	d1 40       	sbci	r29, 0x01	; 1
    4756:	e6 ed       	ldi	r30, 0xD6	; 214
    4758:	f0 e0       	ldi	r31, 0x00	; 0
    475a:	ce 57       	subi	r28, 0x7E	; 126
    475c:	de 4f       	sbci	r29, 0xFE	; 254
    475e:	f9 83       	std	Y+1, r31	; 0x01
    4760:	e8 83       	st	Y, r30
    4762:	c2 58       	subi	r28, 0x82	; 130
    4764:	d1 40       	sbci	r29, 0x01	; 1
    4766:	f7 e0       	ldi	r31, 0x07	; 7
    4768:	cc 57       	subi	r28, 0x7C	; 124
    476a:	de 4f       	sbci	r29, 0xFE	; 254
    476c:	f8 83       	st	Y, r31
    476e:	c4 58       	subi	r28, 0x84	; 132
    4770:	d1 40       	sbci	r29, 0x01	; 1
    4772:	ce 57       	subi	r28, 0x7E	; 126
    4774:	de 4f       	sbci	r29, 0xFE	; 254
    4776:	a8 81       	ld	r26, Y
    4778:	b9 81       	ldd	r27, Y+1	; 0x01
    477a:	c2 58       	subi	r28, 0x82	; 130
    477c:	d1 40       	sbci	r29, 0x01	; 1
    477e:	0c 90       	ld	r0, X
    4780:	ce 57       	subi	r28, 0x7E	; 126
    4782:	de 4f       	sbci	r29, 0xFE	; 254
    4784:	e8 81       	ld	r30, Y
    4786:	f9 81       	ldd	r31, Y+1	; 0x01
    4788:	c2 58       	subi	r28, 0x82	; 130
    478a:	d1 40       	sbci	r29, 0x01	; 1
    478c:	31 96       	adiw	r30, 0x01	; 1
    478e:	ce 57       	subi	r28, 0x7E	; 126
    4790:	de 4f       	sbci	r29, 0xFE	; 254
    4792:	f9 83       	std	Y+1, r31	; 0x01
    4794:	e8 83       	st	Y, r30
    4796:	c2 58       	subi	r28, 0x82	; 130
    4798:	d1 40       	sbci	r29, 0x01	; 1
    479a:	c0 58       	subi	r28, 0x80	; 128
    479c:	de 4f       	sbci	r29, 0xFE	; 254
    479e:	a8 81       	ld	r26, Y
    47a0:	b9 81       	ldd	r27, Y+1	; 0x01
    47a2:	c0 58       	subi	r28, 0x80	; 128
    47a4:	d1 40       	sbci	r29, 0x01	; 1
    47a6:	0c 92       	st	X, r0
    47a8:	c0 58       	subi	r28, 0x80	; 128
    47aa:	de 4f       	sbci	r29, 0xFE	; 254
    47ac:	e8 81       	ld	r30, Y
    47ae:	f9 81       	ldd	r31, Y+1	; 0x01
    47b0:	c0 58       	subi	r28, 0x80	; 128
    47b2:	d1 40       	sbci	r29, 0x01	; 1
    47b4:	31 96       	adiw	r30, 0x01	; 1
    47b6:	c0 58       	subi	r28, 0x80	; 128
    47b8:	de 4f       	sbci	r29, 0xFE	; 254
    47ba:	f9 83       	std	Y+1, r31	; 0x01
    47bc:	e8 83       	st	Y, r30
    47be:	c0 58       	subi	r28, 0x80	; 128
    47c0:	d1 40       	sbci	r29, 0x01	; 1
    47c2:	cc 57       	subi	r28, 0x7C	; 124
    47c4:	de 4f       	sbci	r29, 0xFE	; 254
    47c6:	f8 81       	ld	r31, Y
    47c8:	c4 58       	subi	r28, 0x84	; 132
    47ca:	d1 40       	sbci	r29, 0x01	; 1
    47cc:	f1 50       	subi	r31, 0x01	; 1
    47ce:	cc 57       	subi	r28, 0x7C	; 124
    47d0:	de 4f       	sbci	r29, 0xFE	; 254
    47d2:	f8 83       	st	Y, r31
    47d4:	c4 58       	subi	r28, 0x84	; 132
    47d6:	d1 40       	sbci	r29, 0x01	; 1
    47d8:	cc 57       	subi	r28, 0x7C	; 124
    47da:	de 4f       	sbci	r29, 0xFE	; 254
    47dc:	88 81       	ld	r24, Y
    47de:	c4 58       	subi	r28, 0x84	; 132
    47e0:	d1 40       	sbci	r29, 0x01	; 1
    47e2:	88 23       	and	r24, r24
    47e4:	31 f6       	brne	.-116    	; 0x4772 <CheckLogin+0x2de>
    47e6:	1b a6       	std	Y+43, r1	; 0x2b
    47e8:	de 01       	movw	r26, r28
    47ea:	9c 96       	adiw	r26, 0x2c	; 44
    47ec:	cb 57       	subi	r28, 0x7B	; 123
    47ee:	de 4f       	sbci	r29, 0xFE	; 254
    47f0:	b9 83       	std	Y+1, r27	; 0x01
    47f2:	a8 83       	st	Y, r26
    47f4:	c5 58       	subi	r28, 0x85	; 133
    47f6:	d1 40       	sbci	r29, 0x01	; 1
    47f8:	ee ed       	ldi	r30, 0xDE	; 222
    47fa:	f0 e0       	ldi	r31, 0x00	; 0
    47fc:	c9 57       	subi	r28, 0x79	; 121
    47fe:	de 4f       	sbci	r29, 0xFE	; 254
    4800:	f9 83       	std	Y+1, r31	; 0x01
    4802:	e8 83       	st	Y, r30
    4804:	c7 58       	subi	r28, 0x87	; 135
    4806:	d1 40       	sbci	r29, 0x01	; 1
    4808:	f7 e0       	ldi	r31, 0x07	; 7
    480a:	c7 57       	subi	r28, 0x77	; 119
    480c:	de 4f       	sbci	r29, 0xFE	; 254
    480e:	f8 83       	st	Y, r31
    4810:	c9 58       	subi	r28, 0x89	; 137
    4812:	d1 40       	sbci	r29, 0x01	; 1
    4814:	c9 57       	subi	r28, 0x79	; 121
    4816:	de 4f       	sbci	r29, 0xFE	; 254
    4818:	a8 81       	ld	r26, Y
    481a:	b9 81       	ldd	r27, Y+1	; 0x01
    481c:	c7 58       	subi	r28, 0x87	; 135
    481e:	d1 40       	sbci	r29, 0x01	; 1
    4820:	0c 90       	ld	r0, X
    4822:	c9 57       	subi	r28, 0x79	; 121
    4824:	de 4f       	sbci	r29, 0xFE	; 254
    4826:	e8 81       	ld	r30, Y
    4828:	f9 81       	ldd	r31, Y+1	; 0x01
    482a:	c7 58       	subi	r28, 0x87	; 135
    482c:	d1 40       	sbci	r29, 0x01	; 1
    482e:	31 96       	adiw	r30, 0x01	; 1
    4830:	c9 57       	subi	r28, 0x79	; 121
    4832:	de 4f       	sbci	r29, 0xFE	; 254
    4834:	f9 83       	std	Y+1, r31	; 0x01
    4836:	e8 83       	st	Y, r30
    4838:	c7 58       	subi	r28, 0x87	; 135
    483a:	d1 40       	sbci	r29, 0x01	; 1
    483c:	cb 57       	subi	r28, 0x7B	; 123
    483e:	de 4f       	sbci	r29, 0xFE	; 254
    4840:	a8 81       	ld	r26, Y
    4842:	b9 81       	ldd	r27, Y+1	; 0x01
    4844:	c5 58       	subi	r28, 0x85	; 133
    4846:	d1 40       	sbci	r29, 0x01	; 1
    4848:	0c 92       	st	X, r0
    484a:	cb 57       	subi	r28, 0x7B	; 123
    484c:	de 4f       	sbci	r29, 0xFE	; 254
    484e:	e8 81       	ld	r30, Y
    4850:	f9 81       	ldd	r31, Y+1	; 0x01
    4852:	c5 58       	subi	r28, 0x85	; 133
    4854:	d1 40       	sbci	r29, 0x01	; 1
    4856:	31 96       	adiw	r30, 0x01	; 1
    4858:	cb 57       	subi	r28, 0x7B	; 123
    485a:	de 4f       	sbci	r29, 0xFE	; 254
    485c:	f9 83       	std	Y+1, r31	; 0x01
    485e:	e8 83       	st	Y, r30
    4860:	c5 58       	subi	r28, 0x85	; 133
    4862:	d1 40       	sbci	r29, 0x01	; 1
    4864:	c7 57       	subi	r28, 0x77	; 119
    4866:	de 4f       	sbci	r29, 0xFE	; 254
    4868:	f8 81       	ld	r31, Y
    486a:	c9 58       	subi	r28, 0x89	; 137
    486c:	d1 40       	sbci	r29, 0x01	; 1
    486e:	f1 50       	subi	r31, 0x01	; 1
    4870:	c7 57       	subi	r28, 0x77	; 119
    4872:	de 4f       	sbci	r29, 0xFE	; 254
    4874:	f8 83       	st	Y, r31
    4876:	c9 58       	subi	r28, 0x89	; 137
    4878:	d1 40       	sbci	r29, 0x01	; 1
    487a:	c7 57       	subi	r28, 0x77	; 119
    487c:	de 4f       	sbci	r29, 0xFE	; 254
    487e:	88 81       	ld	r24, Y
    4880:	c9 58       	subi	r28, 0x89	; 137
    4882:	d1 40       	sbci	r29, 0x01	; 1
    4884:	88 23       	and	r24, r24
    4886:	31 f6       	brne	.-116    	; 0x4814 <CheckLogin+0x380>
    4888:	1b aa       	std	Y+51, r1	; 0x33
    488a:	de 01       	movw	r26, r28
    488c:	d4 96       	adiw	r26, 0x34	; 52
    488e:	c6 57       	subi	r28, 0x76	; 118
    4890:	de 4f       	sbci	r29, 0xFE	; 254
    4892:	b9 83       	std	Y+1, r27	; 0x01
    4894:	a8 83       	st	Y, r26
    4896:	ca 58       	subi	r28, 0x8A	; 138
    4898:	d1 40       	sbci	r29, 0x01	; 1
    489a:	e6 ee       	ldi	r30, 0xE6	; 230
    489c:	f0 e0       	ldi	r31, 0x00	; 0
    489e:	c4 57       	subi	r28, 0x74	; 116
    48a0:	de 4f       	sbci	r29, 0xFE	; 254
    48a2:	f9 83       	std	Y+1, r31	; 0x01
    48a4:	e8 83       	st	Y, r30
    48a6:	cc 58       	subi	r28, 0x8C	; 140
    48a8:	d1 40       	sbci	r29, 0x01	; 1
    48aa:	f7 e0       	ldi	r31, 0x07	; 7
    48ac:	c2 57       	subi	r28, 0x72	; 114
    48ae:	de 4f       	sbci	r29, 0xFE	; 254
    48b0:	f8 83       	st	Y, r31
    48b2:	ce 58       	subi	r28, 0x8E	; 142
    48b4:	d1 40       	sbci	r29, 0x01	; 1
    48b6:	c4 57       	subi	r28, 0x74	; 116
    48b8:	de 4f       	sbci	r29, 0xFE	; 254
    48ba:	a8 81       	ld	r26, Y
    48bc:	b9 81       	ldd	r27, Y+1	; 0x01
    48be:	cc 58       	subi	r28, 0x8C	; 140
    48c0:	d1 40       	sbci	r29, 0x01	; 1
    48c2:	0c 90       	ld	r0, X
    48c4:	c4 57       	subi	r28, 0x74	; 116
    48c6:	de 4f       	sbci	r29, 0xFE	; 254
    48c8:	e8 81       	ld	r30, Y
    48ca:	f9 81       	ldd	r31, Y+1	; 0x01
    48cc:	cc 58       	subi	r28, 0x8C	; 140
    48ce:	d1 40       	sbci	r29, 0x01	; 1
    48d0:	31 96       	adiw	r30, 0x01	; 1
    48d2:	c4 57       	subi	r28, 0x74	; 116
    48d4:	de 4f       	sbci	r29, 0xFE	; 254
    48d6:	f9 83       	std	Y+1, r31	; 0x01
    48d8:	e8 83       	st	Y, r30
    48da:	cc 58       	subi	r28, 0x8C	; 140
    48dc:	d1 40       	sbci	r29, 0x01	; 1
    48de:	c6 57       	subi	r28, 0x76	; 118
    48e0:	de 4f       	sbci	r29, 0xFE	; 254
    48e2:	a8 81       	ld	r26, Y
    48e4:	b9 81       	ldd	r27, Y+1	; 0x01
    48e6:	ca 58       	subi	r28, 0x8A	; 138
    48e8:	d1 40       	sbci	r29, 0x01	; 1
    48ea:	0c 92       	st	X, r0
    48ec:	c6 57       	subi	r28, 0x76	; 118
    48ee:	de 4f       	sbci	r29, 0xFE	; 254
    48f0:	e8 81       	ld	r30, Y
    48f2:	f9 81       	ldd	r31, Y+1	; 0x01
    48f4:	ca 58       	subi	r28, 0x8A	; 138
    48f6:	d1 40       	sbci	r29, 0x01	; 1
    48f8:	31 96       	adiw	r30, 0x01	; 1
    48fa:	c6 57       	subi	r28, 0x76	; 118
    48fc:	de 4f       	sbci	r29, 0xFE	; 254
    48fe:	f9 83       	std	Y+1, r31	; 0x01
    4900:	e8 83       	st	Y, r30
    4902:	ca 58       	subi	r28, 0x8A	; 138
    4904:	d1 40       	sbci	r29, 0x01	; 1
    4906:	c2 57       	subi	r28, 0x72	; 114
    4908:	de 4f       	sbci	r29, 0xFE	; 254
    490a:	f8 81       	ld	r31, Y
    490c:	ce 58       	subi	r28, 0x8E	; 142
    490e:	d1 40       	sbci	r29, 0x01	; 1
    4910:	f1 50       	subi	r31, 0x01	; 1
    4912:	c2 57       	subi	r28, 0x72	; 114
    4914:	de 4f       	sbci	r29, 0xFE	; 254
    4916:	f8 83       	st	Y, r31
    4918:	ce 58       	subi	r28, 0x8E	; 142
    491a:	d1 40       	sbci	r29, 0x01	; 1
    491c:	c2 57       	subi	r28, 0x72	; 114
    491e:	de 4f       	sbci	r29, 0xFE	; 254
    4920:	88 81       	ld	r24, Y
    4922:	ce 58       	subi	r28, 0x8E	; 142
    4924:	d1 40       	sbci	r29, 0x01	; 1
    4926:	88 23       	and	r24, r24
    4928:	31 f6       	brne	.-116    	; 0x48b6 <CheckLogin+0x422>
    492a:	1b ae       	std	Y+59, r1	; 0x3b
    492c:	de 01       	movw	r26, r28
    492e:	dc 96       	adiw	r26, 0x3c	; 60
    4930:	c1 57       	subi	r28, 0x71	; 113
    4932:	de 4f       	sbci	r29, 0xFE	; 254
    4934:	b9 83       	std	Y+1, r27	; 0x01
    4936:	a8 83       	st	Y, r26
    4938:	cf 58       	subi	r28, 0x8F	; 143
    493a:	d1 40       	sbci	r29, 0x01	; 1
    493c:	ee ee       	ldi	r30, 0xEE	; 238
    493e:	f0 e0       	ldi	r31, 0x00	; 0
    4940:	cf 56       	subi	r28, 0x6F	; 111
    4942:	de 4f       	sbci	r29, 0xFE	; 254
    4944:	f9 83       	std	Y+1, r31	; 0x01
    4946:	e8 83       	st	Y, r30
    4948:	c1 59       	subi	r28, 0x91	; 145
    494a:	d1 40       	sbci	r29, 0x01	; 1
    494c:	f7 e0       	ldi	r31, 0x07	; 7
    494e:	cd 56       	subi	r28, 0x6D	; 109
    4950:	de 4f       	sbci	r29, 0xFE	; 254
    4952:	f8 83       	st	Y, r31
    4954:	c3 59       	subi	r28, 0x93	; 147
    4956:	d1 40       	sbci	r29, 0x01	; 1
    4958:	cf 56       	subi	r28, 0x6F	; 111
    495a:	de 4f       	sbci	r29, 0xFE	; 254
    495c:	a8 81       	ld	r26, Y
    495e:	b9 81       	ldd	r27, Y+1	; 0x01
    4960:	c1 59       	subi	r28, 0x91	; 145
    4962:	d1 40       	sbci	r29, 0x01	; 1
    4964:	0c 90       	ld	r0, X
    4966:	cf 56       	subi	r28, 0x6F	; 111
    4968:	de 4f       	sbci	r29, 0xFE	; 254
    496a:	e8 81       	ld	r30, Y
    496c:	f9 81       	ldd	r31, Y+1	; 0x01
    496e:	c1 59       	subi	r28, 0x91	; 145
    4970:	d1 40       	sbci	r29, 0x01	; 1
    4972:	31 96       	adiw	r30, 0x01	; 1
    4974:	cf 56       	subi	r28, 0x6F	; 111
    4976:	de 4f       	sbci	r29, 0xFE	; 254
    4978:	f9 83       	std	Y+1, r31	; 0x01
    497a:	e8 83       	st	Y, r30
    497c:	c1 59       	subi	r28, 0x91	; 145
    497e:	d1 40       	sbci	r29, 0x01	; 1
    4980:	c1 57       	subi	r28, 0x71	; 113
    4982:	de 4f       	sbci	r29, 0xFE	; 254
    4984:	a8 81       	ld	r26, Y
    4986:	b9 81       	ldd	r27, Y+1	; 0x01
    4988:	cf 58       	subi	r28, 0x8F	; 143
    498a:	d1 40       	sbci	r29, 0x01	; 1
    498c:	0c 92       	st	X, r0
    498e:	c1 57       	subi	r28, 0x71	; 113
    4990:	de 4f       	sbci	r29, 0xFE	; 254
    4992:	e8 81       	ld	r30, Y
    4994:	f9 81       	ldd	r31, Y+1	; 0x01
    4996:	cf 58       	subi	r28, 0x8F	; 143
    4998:	d1 40       	sbci	r29, 0x01	; 1
    499a:	31 96       	adiw	r30, 0x01	; 1
    499c:	c1 57       	subi	r28, 0x71	; 113
    499e:	de 4f       	sbci	r29, 0xFE	; 254
    49a0:	f9 83       	std	Y+1, r31	; 0x01
    49a2:	e8 83       	st	Y, r30
    49a4:	cf 58       	subi	r28, 0x8F	; 143
    49a6:	d1 40       	sbci	r29, 0x01	; 1
    49a8:	cd 56       	subi	r28, 0x6D	; 109
    49aa:	de 4f       	sbci	r29, 0xFE	; 254
    49ac:	f8 81       	ld	r31, Y
    49ae:	c3 59       	subi	r28, 0x93	; 147
    49b0:	d1 40       	sbci	r29, 0x01	; 1
    49b2:	f1 50       	subi	r31, 0x01	; 1
    49b4:	cd 56       	subi	r28, 0x6D	; 109
    49b6:	de 4f       	sbci	r29, 0xFE	; 254
    49b8:	f8 83       	st	Y, r31
    49ba:	c3 59       	subi	r28, 0x93	; 147
    49bc:	d1 40       	sbci	r29, 0x01	; 1
    49be:	cd 56       	subi	r28, 0x6D	; 109
    49c0:	de 4f       	sbci	r29, 0xFE	; 254
    49c2:	88 81       	ld	r24, Y
    49c4:	c3 59       	subi	r28, 0x93	; 147
    49c6:	d1 40       	sbci	r29, 0x01	; 1
    49c8:	88 23       	and	r24, r24
    49ca:	31 f6       	brne	.-116    	; 0x4958 <CheckLogin+0x4c4>
    49cc:	fe 01       	movw	r30, r28
    49ce:	ed 5b       	subi	r30, 0xBD	; 189
    49d0:	ff 4f       	sbci	r31, 0xFF	; 255
    49d2:	10 82       	st	Z, r1
    49d4:	de 01       	movw	r26, r28
    49d6:	ac 5b       	subi	r26, 0xBC	; 188
    49d8:	bf 4f       	sbci	r27, 0xFF	; 255
    49da:	cc 56       	subi	r28, 0x6C	; 108
    49dc:	de 4f       	sbci	r29, 0xFE	; 254
    49de:	b9 83       	std	Y+1, r27	; 0x01
    49e0:	a8 83       	st	Y, r26
    49e2:	c4 59       	subi	r28, 0x94	; 148
    49e4:	d1 40       	sbci	r29, 0x01	; 1
    49e6:	cc 56       	subi	r28, 0x6C	; 108
    49e8:	de 4f       	sbci	r29, 0xFE	; 254
    49ea:	e8 81       	ld	r30, Y
    49ec:	f9 81       	ldd	r31, Y+1	; 0x01
    49ee:	c4 59       	subi	r28, 0x94	; 148
    49f0:	d1 40       	sbci	r29, 0x01	; 1
    49f2:	ca 56       	subi	r28, 0x6A	; 106
    49f4:	de 4f       	sbci	r29, 0xFE	; 254
    49f6:	f9 83       	std	Y+1, r31	; 0x01
    49f8:	e8 83       	st	Y, r30
    49fa:	c6 59       	subi	r28, 0x96	; 150
    49fc:	d1 40       	sbci	r29, 0x01	; 1
    49fe:	86 ef       	ldi	r24, 0xF6	; 246
    4a00:	90 e0       	ldi	r25, 0x00	; 0
    4a02:	c8 56       	subi	r28, 0x68	; 104
    4a04:	de 4f       	sbci	r29, 0xFE	; 254
    4a06:	99 83       	std	Y+1, r25	; 0x01
    4a08:	88 83       	st	Y, r24
    4a0a:	c8 59       	subi	r28, 0x98	; 152
    4a0c:	d1 40       	sbci	r29, 0x01	; 1
    4a0e:	97 e0       	ldi	r25, 0x07	; 7
    4a10:	c6 56       	subi	r28, 0x66	; 102
    4a12:	de 4f       	sbci	r29, 0xFE	; 254
    4a14:	98 83       	st	Y, r25
    4a16:	ca 59       	subi	r28, 0x9A	; 154
    4a18:	d1 40       	sbci	r29, 0x01	; 1
    4a1a:	c8 56       	subi	r28, 0x68	; 104
    4a1c:	de 4f       	sbci	r29, 0xFE	; 254
    4a1e:	a8 81       	ld	r26, Y
    4a20:	b9 81       	ldd	r27, Y+1	; 0x01
    4a22:	c8 59       	subi	r28, 0x98	; 152
    4a24:	d1 40       	sbci	r29, 0x01	; 1
    4a26:	0c 90       	ld	r0, X
    4a28:	c8 56       	subi	r28, 0x68	; 104
    4a2a:	de 4f       	sbci	r29, 0xFE	; 254
    4a2c:	e8 81       	ld	r30, Y
    4a2e:	f9 81       	ldd	r31, Y+1	; 0x01
    4a30:	c8 59       	subi	r28, 0x98	; 152
    4a32:	d1 40       	sbci	r29, 0x01	; 1
    4a34:	31 96       	adiw	r30, 0x01	; 1
    4a36:	c8 56       	subi	r28, 0x68	; 104
    4a38:	de 4f       	sbci	r29, 0xFE	; 254
    4a3a:	f9 83       	std	Y+1, r31	; 0x01
    4a3c:	e8 83       	st	Y, r30
    4a3e:	c8 59       	subi	r28, 0x98	; 152
    4a40:	d1 40       	sbci	r29, 0x01	; 1
    4a42:	ca 56       	subi	r28, 0x6A	; 106
    4a44:	de 4f       	sbci	r29, 0xFE	; 254
    4a46:	a8 81       	ld	r26, Y
    4a48:	b9 81       	ldd	r27, Y+1	; 0x01
    4a4a:	c6 59       	subi	r28, 0x96	; 150
    4a4c:	d1 40       	sbci	r29, 0x01	; 1
    4a4e:	0c 92       	st	X, r0
    4a50:	ca 56       	subi	r28, 0x6A	; 106
    4a52:	de 4f       	sbci	r29, 0xFE	; 254
    4a54:	e8 81       	ld	r30, Y
    4a56:	f9 81       	ldd	r31, Y+1	; 0x01
    4a58:	c6 59       	subi	r28, 0x96	; 150
    4a5a:	d1 40       	sbci	r29, 0x01	; 1
    4a5c:	31 96       	adiw	r30, 0x01	; 1
    4a5e:	ca 56       	subi	r28, 0x6A	; 106
    4a60:	de 4f       	sbci	r29, 0xFE	; 254
    4a62:	f9 83       	std	Y+1, r31	; 0x01
    4a64:	e8 83       	st	Y, r30
    4a66:	c6 59       	subi	r28, 0x96	; 150
    4a68:	d1 40       	sbci	r29, 0x01	; 1
    4a6a:	c6 56       	subi	r28, 0x66	; 102
    4a6c:	de 4f       	sbci	r29, 0xFE	; 254
    4a6e:	f8 81       	ld	r31, Y
    4a70:	ca 59       	subi	r28, 0x9A	; 154
    4a72:	d1 40       	sbci	r29, 0x01	; 1
    4a74:	f1 50       	subi	r31, 0x01	; 1
    4a76:	c6 56       	subi	r28, 0x66	; 102
    4a78:	de 4f       	sbci	r29, 0xFE	; 254
    4a7a:	f8 83       	st	Y, r31
    4a7c:	ca 59       	subi	r28, 0x9A	; 154
    4a7e:	d1 40       	sbci	r29, 0x01	; 1
    4a80:	c6 56       	subi	r28, 0x66	; 102
    4a82:	de 4f       	sbci	r29, 0xFE	; 254
    4a84:	88 81       	ld	r24, Y
    4a86:	ca 59       	subi	r28, 0x9A	; 154
    4a88:	d1 40       	sbci	r29, 0x01	; 1
    4a8a:	88 23       	and	r24, r24
    4a8c:	31 f6       	brne	.-116    	; 0x4a1a <CheckLogin+0x586>
    4a8e:	cc 56       	subi	r28, 0x6C	; 108
    4a90:	de 4f       	sbci	r29, 0xFE	; 254
    4a92:	a8 81       	ld	r26, Y
    4a94:	b9 81       	ldd	r27, Y+1	; 0x01
    4a96:	c4 59       	subi	r28, 0x94	; 148
    4a98:	d1 40       	sbci	r29, 0x01	; 1
    4a9a:	17 96       	adiw	r26, 0x07	; 7
    4a9c:	1c 92       	st	X, r1
    4a9e:	ce 01       	movw	r24, r28
    4aa0:	84 5b       	subi	r24, 0xB4	; 180
    4aa2:	9f 4f       	sbci	r25, 0xFF	; 255
    4aa4:	c5 56       	subi	r28, 0x65	; 101
    4aa6:	de 4f       	sbci	r29, 0xFE	; 254
    4aa8:	99 83       	std	Y+1, r25	; 0x01
    4aaa:	88 83       	st	Y, r24
    4aac:	cb 59       	subi	r28, 0x9B	; 155
    4aae:	d1 40       	sbci	r29, 0x01	; 1
    4ab0:	ee ef       	ldi	r30, 0xFE	; 254
    4ab2:	f0 e0       	ldi	r31, 0x00	; 0
    4ab4:	c3 56       	subi	r28, 0x63	; 99
    4ab6:	de 4f       	sbci	r29, 0xFE	; 254
    4ab8:	f9 83       	std	Y+1, r31	; 0x01
    4aba:	e8 83       	st	Y, r30
    4abc:	cd 59       	subi	r28, 0x9D	; 157
    4abe:	d1 40       	sbci	r29, 0x01	; 1
    4ac0:	f8 e0       	ldi	r31, 0x08	; 8
    4ac2:	c1 56       	subi	r28, 0x61	; 97
    4ac4:	de 4f       	sbci	r29, 0xFE	; 254
    4ac6:	f8 83       	st	Y, r31
    4ac8:	cf 59       	subi	r28, 0x9F	; 159
    4aca:	d1 40       	sbci	r29, 0x01	; 1
    4acc:	c3 56       	subi	r28, 0x63	; 99
    4ace:	de 4f       	sbci	r29, 0xFE	; 254
    4ad0:	a8 81       	ld	r26, Y
    4ad2:	b9 81       	ldd	r27, Y+1	; 0x01
    4ad4:	cd 59       	subi	r28, 0x9D	; 157
    4ad6:	d1 40       	sbci	r29, 0x01	; 1
    4ad8:	0c 90       	ld	r0, X
    4ada:	c3 56       	subi	r28, 0x63	; 99
    4adc:	de 4f       	sbci	r29, 0xFE	; 254
    4ade:	e8 81       	ld	r30, Y
    4ae0:	f9 81       	ldd	r31, Y+1	; 0x01
    4ae2:	cd 59       	subi	r28, 0x9D	; 157
    4ae4:	d1 40       	sbci	r29, 0x01	; 1
    4ae6:	31 96       	adiw	r30, 0x01	; 1
    4ae8:	c3 56       	subi	r28, 0x63	; 99
    4aea:	de 4f       	sbci	r29, 0xFE	; 254
    4aec:	f9 83       	std	Y+1, r31	; 0x01
    4aee:	e8 83       	st	Y, r30
    4af0:	cd 59       	subi	r28, 0x9D	; 157
    4af2:	d1 40       	sbci	r29, 0x01	; 1
    4af4:	c5 56       	subi	r28, 0x65	; 101
    4af6:	de 4f       	sbci	r29, 0xFE	; 254
    4af8:	a8 81       	ld	r26, Y
    4afa:	b9 81       	ldd	r27, Y+1	; 0x01
    4afc:	cb 59       	subi	r28, 0x9B	; 155
    4afe:	d1 40       	sbci	r29, 0x01	; 1
    4b00:	0c 92       	st	X, r0
    4b02:	c5 56       	subi	r28, 0x65	; 101
    4b04:	de 4f       	sbci	r29, 0xFE	; 254
    4b06:	e8 81       	ld	r30, Y
    4b08:	f9 81       	ldd	r31, Y+1	; 0x01
    4b0a:	cb 59       	subi	r28, 0x9B	; 155
    4b0c:	d1 40       	sbci	r29, 0x01	; 1
    4b0e:	31 96       	adiw	r30, 0x01	; 1
    4b10:	c5 56       	subi	r28, 0x65	; 101
    4b12:	de 4f       	sbci	r29, 0xFE	; 254
    4b14:	f9 83       	std	Y+1, r31	; 0x01
    4b16:	e8 83       	st	Y, r30
    4b18:	cb 59       	subi	r28, 0x9B	; 155
    4b1a:	d1 40       	sbci	r29, 0x01	; 1
    4b1c:	c1 56       	subi	r28, 0x61	; 97
    4b1e:	de 4f       	sbci	r29, 0xFE	; 254
    4b20:	f8 81       	ld	r31, Y
    4b22:	cf 59       	subi	r28, 0x9F	; 159
    4b24:	d1 40       	sbci	r29, 0x01	; 1
    4b26:	f1 50       	subi	r31, 0x01	; 1
    4b28:	c1 56       	subi	r28, 0x61	; 97
    4b2a:	de 4f       	sbci	r29, 0xFE	; 254
    4b2c:	f8 83       	st	Y, r31
    4b2e:	cf 59       	subi	r28, 0x9F	; 159
    4b30:	d1 40       	sbci	r29, 0x01	; 1
    4b32:	c1 56       	subi	r28, 0x61	; 97
    4b34:	de 4f       	sbci	r29, 0xFE	; 254
    4b36:	88 81       	ld	r24, Y
    4b38:	cf 59       	subi	r28, 0x9F	; 159
    4b3a:	d1 40       	sbci	r29, 0x01	; 1
    4b3c:	88 23       	and	r24, r24
    4b3e:	31 f6       	brne	.-116    	; 0x4acc <CheckLogin+0x638>
     char password[10][8] = { "wael1\r", "wael2\r", "wael3\r", "wael4\r",
			"wael5\r", "wael6\r", "wael7\r", "wael8\r", "wael9\r", "wael10\r" };
    4b40:	ce 01       	movw	r24, r28
    4b42:	8c 5a       	subi	r24, 0xAC	; 172
    4b44:	9f 4f       	sbci	r25, 0xFF	; 255
    4b46:	20 e5       	ldi	r18, 0x50	; 80
    4b48:	fc 01       	movw	r30, r24
    4b4a:	df 01       	movw	r26, r30
    4b4c:	82 2f       	mov	r24, r18
    4b4e:	1d 92       	st	X+, r1
    4b50:	8a 95       	dec	r24
    4b52:	e9 f7       	brne	.-6      	; 0x4b4e <CheckLogin+0x6ba>
    4b54:	de 01       	movw	r26, r28
    4b56:	ac 5a       	subi	r26, 0xAC	; 172
    4b58:	bf 4f       	sbci	r27, 0xFF	; 255
    4b5a:	c0 56       	subi	r28, 0x60	; 96
    4b5c:	de 4f       	sbci	r29, 0xFE	; 254
    4b5e:	b9 83       	std	Y+1, r27	; 0x01
    4b60:	a8 83       	st	Y, r26
    4b62:	c0 5a       	subi	r28, 0xA0	; 160
    4b64:	d1 40       	sbci	r29, 0x01	; 1
    4b66:	c0 56       	subi	r28, 0x60	; 96
    4b68:	de 4f       	sbci	r29, 0xFE	; 254
    4b6a:	e8 81       	ld	r30, Y
    4b6c:	f9 81       	ldd	r31, Y+1	; 0x01
    4b6e:	c0 5a       	subi	r28, 0xA0	; 160
    4b70:	d1 40       	sbci	r29, 0x01	; 1
    4b72:	ce 55       	subi	r28, 0x5E	; 94
    4b74:	de 4f       	sbci	r29, 0xFE	; 254
    4b76:	f9 83       	std	Y+1, r31	; 0x01
    4b78:	e8 83       	st	Y, r30
    4b7a:	c2 5a       	subi	r28, 0xA2	; 162
    4b7c:	d1 40       	sbci	r29, 0x01	; 1
    4b7e:	86 eb       	ldi	r24, 0xB6	; 182
    4b80:	90 e0       	ldi	r25, 0x00	; 0
    4b82:	cc 55       	subi	r28, 0x5C	; 92
    4b84:	de 4f       	sbci	r29, 0xFE	; 254
    4b86:	99 83       	std	Y+1, r25	; 0x01
    4b88:	88 83       	st	Y, r24
    4b8a:	c4 5a       	subi	r28, 0xA4	; 164
    4b8c:	d1 40       	sbci	r29, 0x01	; 1
    4b8e:	97 e0       	ldi	r25, 0x07	; 7
    4b90:	ca 55       	subi	r28, 0x5A	; 90
    4b92:	de 4f       	sbci	r29, 0xFE	; 254
    4b94:	98 83       	st	Y, r25
    4b96:	c6 5a       	subi	r28, 0xA6	; 166
    4b98:	d1 40       	sbci	r29, 0x01	; 1
    4b9a:	cc 55       	subi	r28, 0x5C	; 92
    4b9c:	de 4f       	sbci	r29, 0xFE	; 254
    4b9e:	a8 81       	ld	r26, Y
    4ba0:	b9 81       	ldd	r27, Y+1	; 0x01
    4ba2:	c4 5a       	subi	r28, 0xA4	; 164
    4ba4:	d1 40       	sbci	r29, 0x01	; 1
    4ba6:	0c 90       	ld	r0, X
    4ba8:	cc 55       	subi	r28, 0x5C	; 92
    4baa:	de 4f       	sbci	r29, 0xFE	; 254
    4bac:	e8 81       	ld	r30, Y
    4bae:	f9 81       	ldd	r31, Y+1	; 0x01
    4bb0:	c4 5a       	subi	r28, 0xA4	; 164
    4bb2:	d1 40       	sbci	r29, 0x01	; 1
    4bb4:	31 96       	adiw	r30, 0x01	; 1
    4bb6:	cc 55       	subi	r28, 0x5C	; 92
    4bb8:	de 4f       	sbci	r29, 0xFE	; 254
    4bba:	f9 83       	std	Y+1, r31	; 0x01
    4bbc:	e8 83       	st	Y, r30
    4bbe:	c4 5a       	subi	r28, 0xA4	; 164
    4bc0:	d1 40       	sbci	r29, 0x01	; 1
    4bc2:	ce 55       	subi	r28, 0x5E	; 94
    4bc4:	de 4f       	sbci	r29, 0xFE	; 254
    4bc6:	a8 81       	ld	r26, Y
    4bc8:	b9 81       	ldd	r27, Y+1	; 0x01
    4bca:	c2 5a       	subi	r28, 0xA2	; 162
    4bcc:	d1 40       	sbci	r29, 0x01	; 1
    4bce:	0c 92       	st	X, r0
    4bd0:	ce 55       	subi	r28, 0x5E	; 94
    4bd2:	de 4f       	sbci	r29, 0xFE	; 254
    4bd4:	e8 81       	ld	r30, Y
    4bd6:	f9 81       	ldd	r31, Y+1	; 0x01
    4bd8:	c2 5a       	subi	r28, 0xA2	; 162
    4bda:	d1 40       	sbci	r29, 0x01	; 1
    4bdc:	31 96       	adiw	r30, 0x01	; 1
    4bde:	ce 55       	subi	r28, 0x5E	; 94
    4be0:	de 4f       	sbci	r29, 0xFE	; 254
    4be2:	f9 83       	std	Y+1, r31	; 0x01
    4be4:	e8 83       	st	Y, r30
    4be6:	c2 5a       	subi	r28, 0xA2	; 162
    4be8:	d1 40       	sbci	r29, 0x01	; 1
    4bea:	ca 55       	subi	r28, 0x5A	; 90
    4bec:	de 4f       	sbci	r29, 0xFE	; 254
    4bee:	f8 81       	ld	r31, Y
    4bf0:	c6 5a       	subi	r28, 0xA6	; 166
    4bf2:	d1 40       	sbci	r29, 0x01	; 1
    4bf4:	f1 50       	subi	r31, 0x01	; 1
    4bf6:	ca 55       	subi	r28, 0x5A	; 90
    4bf8:	de 4f       	sbci	r29, 0xFE	; 254
    4bfa:	f8 83       	st	Y, r31
    4bfc:	c6 5a       	subi	r28, 0xA6	; 166
    4bfe:	d1 40       	sbci	r29, 0x01	; 1
    4c00:	ca 55       	subi	r28, 0x5A	; 90
    4c02:	de 4f       	sbci	r29, 0xFE	; 254
    4c04:	88 81       	ld	r24, Y
    4c06:	c6 5a       	subi	r28, 0xA6	; 166
    4c08:	d1 40       	sbci	r29, 0x01	; 1
    4c0a:	88 23       	and	r24, r24
    4c0c:	31 f6       	brne	.-116    	; 0x4b9a <CheckLogin+0x706>
    4c0e:	c0 56       	subi	r28, 0x60	; 96
    4c10:	de 4f       	sbci	r29, 0xFE	; 254
    4c12:	a8 81       	ld	r26, Y
    4c14:	b9 81       	ldd	r27, Y+1	; 0x01
    4c16:	c0 5a       	subi	r28, 0xA0	; 160
    4c18:	d1 40       	sbci	r29, 0x01	; 1
    4c1a:	17 96       	adiw	r26, 0x07	; 7
    4c1c:	1c 92       	st	X, r1
    4c1e:	fe 01       	movw	r30, r28
    4c20:	ec 5a       	subi	r30, 0xAC	; 172
    4c22:	ff 4f       	sbci	r31, 0xFF	; 255
    4c24:	c9 55       	subi	r28, 0x59	; 89
    4c26:	de 4f       	sbci	r29, 0xFE	; 254
    4c28:	f9 83       	std	Y+1, r31	; 0x01
    4c2a:	e8 83       	st	Y, r30
    4c2c:	c7 5a       	subi	r28, 0xA7	; 167
    4c2e:	d1 40       	sbci	r29, 0x01	; 1
    4c30:	c9 55       	subi	r28, 0x59	; 89
    4c32:	de 4f       	sbci	r29, 0xFE	; 254
    4c34:	88 81       	ld	r24, Y
    4c36:	99 81       	ldd	r25, Y+1	; 0x01
    4c38:	c7 5a       	subi	r28, 0xA7	; 167
    4c3a:	d1 40       	sbci	r29, 0x01	; 1
    4c3c:	08 96       	adiw	r24, 0x08	; 8
    4c3e:	c7 55       	subi	r28, 0x57	; 87
    4c40:	de 4f       	sbci	r29, 0xFE	; 254
    4c42:	99 83       	std	Y+1, r25	; 0x01
    4c44:	88 83       	st	Y, r24
    4c46:	c9 5a       	subi	r28, 0xA9	; 169
    4c48:	d1 40       	sbci	r29, 0x01	; 1
    4c4a:	ae eb       	ldi	r26, 0xBE	; 190
    4c4c:	b0 e0       	ldi	r27, 0x00	; 0
    4c4e:	c5 55       	subi	r28, 0x55	; 85
    4c50:	de 4f       	sbci	r29, 0xFE	; 254
    4c52:	b9 83       	std	Y+1, r27	; 0x01
    4c54:	a8 83       	st	Y, r26
    4c56:	cb 5a       	subi	r28, 0xAB	; 171
    4c58:	d1 40       	sbci	r29, 0x01	; 1
    4c5a:	b7 e0       	ldi	r27, 0x07	; 7
    4c5c:	c3 55       	subi	r28, 0x53	; 83
    4c5e:	de 4f       	sbci	r29, 0xFE	; 254
    4c60:	b8 83       	st	Y, r27
    4c62:	cd 5a       	subi	r28, 0xAD	; 173
    4c64:	d1 40       	sbci	r29, 0x01	; 1
    4c66:	c5 55       	subi	r28, 0x55	; 85
    4c68:	de 4f       	sbci	r29, 0xFE	; 254
    4c6a:	e8 81       	ld	r30, Y
    4c6c:	f9 81       	ldd	r31, Y+1	; 0x01
    4c6e:	cb 5a       	subi	r28, 0xAB	; 171
    4c70:	d1 40       	sbci	r29, 0x01	; 1
    4c72:	00 80       	ld	r0, Z
    4c74:	c5 55       	subi	r28, 0x55	; 85
    4c76:	de 4f       	sbci	r29, 0xFE	; 254
    4c78:	88 81       	ld	r24, Y
    4c7a:	99 81       	ldd	r25, Y+1	; 0x01
    4c7c:	cb 5a       	subi	r28, 0xAB	; 171
    4c7e:	d1 40       	sbci	r29, 0x01	; 1
    4c80:	01 96       	adiw	r24, 0x01	; 1
    4c82:	c5 55       	subi	r28, 0x55	; 85
    4c84:	de 4f       	sbci	r29, 0xFE	; 254
    4c86:	99 83       	std	Y+1, r25	; 0x01
    4c88:	88 83       	st	Y, r24
    4c8a:	cb 5a       	subi	r28, 0xAB	; 171
    4c8c:	d1 40       	sbci	r29, 0x01	; 1
    4c8e:	c7 55       	subi	r28, 0x57	; 87
    4c90:	de 4f       	sbci	r29, 0xFE	; 254
    4c92:	a8 81       	ld	r26, Y
    4c94:	b9 81       	ldd	r27, Y+1	; 0x01
    4c96:	c9 5a       	subi	r28, 0xA9	; 169
    4c98:	d1 40       	sbci	r29, 0x01	; 1
    4c9a:	0c 92       	st	X, r0
    4c9c:	c7 55       	subi	r28, 0x57	; 87
    4c9e:	de 4f       	sbci	r29, 0xFE	; 254
    4ca0:	e8 81       	ld	r30, Y
    4ca2:	f9 81       	ldd	r31, Y+1	; 0x01
    4ca4:	c9 5a       	subi	r28, 0xA9	; 169
    4ca6:	d1 40       	sbci	r29, 0x01	; 1
    4ca8:	31 96       	adiw	r30, 0x01	; 1
    4caa:	c7 55       	subi	r28, 0x57	; 87
    4cac:	de 4f       	sbci	r29, 0xFE	; 254
    4cae:	f9 83       	std	Y+1, r31	; 0x01
    4cb0:	e8 83       	st	Y, r30
    4cb2:	c9 5a       	subi	r28, 0xA9	; 169
    4cb4:	d1 40       	sbci	r29, 0x01	; 1
    4cb6:	c3 55       	subi	r28, 0x53	; 83
    4cb8:	de 4f       	sbci	r29, 0xFE	; 254
    4cba:	f8 81       	ld	r31, Y
    4cbc:	cd 5a       	subi	r28, 0xAD	; 173
    4cbe:	d1 40       	sbci	r29, 0x01	; 1
    4cc0:	f1 50       	subi	r31, 0x01	; 1
    4cc2:	c3 55       	subi	r28, 0x53	; 83
    4cc4:	de 4f       	sbci	r29, 0xFE	; 254
    4cc6:	f8 83       	st	Y, r31
    4cc8:	cd 5a       	subi	r28, 0xAD	; 173
    4cca:	d1 40       	sbci	r29, 0x01	; 1
    4ccc:	c3 55       	subi	r28, 0x53	; 83
    4cce:	de 4f       	sbci	r29, 0xFE	; 254
    4cd0:	88 81       	ld	r24, Y
    4cd2:	cd 5a       	subi	r28, 0xAD	; 173
    4cd4:	d1 40       	sbci	r29, 0x01	; 1
    4cd6:	88 23       	and	r24, r24
    4cd8:	31 f6       	brne	.-116    	; 0x4c66 <CheckLogin+0x7d2>
    4cda:	c9 55       	subi	r28, 0x59	; 89
    4cdc:	de 4f       	sbci	r29, 0xFE	; 254
    4cde:	a8 81       	ld	r26, Y
    4ce0:	b9 81       	ldd	r27, Y+1	; 0x01
    4ce2:	c7 5a       	subi	r28, 0xA7	; 167
    4ce4:	d1 40       	sbci	r29, 0x01	; 1
    4ce6:	1f 96       	adiw	r26, 0x0f	; 15
    4ce8:	1c 92       	st	X, r1
    4cea:	fe 01       	movw	r30, r28
    4cec:	ec 5a       	subi	r30, 0xAC	; 172
    4cee:	ff 4f       	sbci	r31, 0xFF	; 255
    4cf0:	c2 55       	subi	r28, 0x52	; 82
    4cf2:	de 4f       	sbci	r29, 0xFE	; 254
    4cf4:	f9 83       	std	Y+1, r31	; 0x01
    4cf6:	e8 83       	st	Y, r30
    4cf8:	ce 5a       	subi	r28, 0xAE	; 174
    4cfa:	d1 40       	sbci	r29, 0x01	; 1
    4cfc:	c2 55       	subi	r28, 0x52	; 82
    4cfe:	de 4f       	sbci	r29, 0xFE	; 254
    4d00:	88 81       	ld	r24, Y
    4d02:	99 81       	ldd	r25, Y+1	; 0x01
    4d04:	ce 5a       	subi	r28, 0xAE	; 174
    4d06:	d1 40       	sbci	r29, 0x01	; 1
    4d08:	40 96       	adiw	r24, 0x10	; 16
    4d0a:	c0 55       	subi	r28, 0x50	; 80
    4d0c:	de 4f       	sbci	r29, 0xFE	; 254
    4d0e:	99 83       	std	Y+1, r25	; 0x01
    4d10:	88 83       	st	Y, r24
    4d12:	c0 5b       	subi	r28, 0xB0	; 176
    4d14:	d1 40       	sbci	r29, 0x01	; 1
    4d16:	a6 ec       	ldi	r26, 0xC6	; 198
    4d18:	b0 e0       	ldi	r27, 0x00	; 0
    4d1a:	ce 54       	subi	r28, 0x4E	; 78
    4d1c:	de 4f       	sbci	r29, 0xFE	; 254
    4d1e:	b9 83       	std	Y+1, r27	; 0x01
    4d20:	a8 83       	st	Y, r26
    4d22:	c2 5b       	subi	r28, 0xB2	; 178
    4d24:	d1 40       	sbci	r29, 0x01	; 1
    4d26:	b7 e0       	ldi	r27, 0x07	; 7
    4d28:	cc 54       	subi	r28, 0x4C	; 76
    4d2a:	de 4f       	sbci	r29, 0xFE	; 254
    4d2c:	b8 83       	st	Y, r27
    4d2e:	c4 5b       	subi	r28, 0xB4	; 180
    4d30:	d1 40       	sbci	r29, 0x01	; 1
    4d32:	ce 54       	subi	r28, 0x4E	; 78
    4d34:	de 4f       	sbci	r29, 0xFE	; 254
    4d36:	e8 81       	ld	r30, Y
    4d38:	f9 81       	ldd	r31, Y+1	; 0x01
    4d3a:	c2 5b       	subi	r28, 0xB2	; 178
    4d3c:	d1 40       	sbci	r29, 0x01	; 1
    4d3e:	00 80       	ld	r0, Z
    4d40:	ce 54       	subi	r28, 0x4E	; 78
    4d42:	de 4f       	sbci	r29, 0xFE	; 254
    4d44:	88 81       	ld	r24, Y
    4d46:	99 81       	ldd	r25, Y+1	; 0x01
    4d48:	c2 5b       	subi	r28, 0xB2	; 178
    4d4a:	d1 40       	sbci	r29, 0x01	; 1
    4d4c:	01 96       	adiw	r24, 0x01	; 1
    4d4e:	ce 54       	subi	r28, 0x4E	; 78
    4d50:	de 4f       	sbci	r29, 0xFE	; 254
    4d52:	99 83       	std	Y+1, r25	; 0x01
    4d54:	88 83       	st	Y, r24
    4d56:	c2 5b       	subi	r28, 0xB2	; 178
    4d58:	d1 40       	sbci	r29, 0x01	; 1
    4d5a:	c0 55       	subi	r28, 0x50	; 80
    4d5c:	de 4f       	sbci	r29, 0xFE	; 254
    4d5e:	a8 81       	ld	r26, Y
    4d60:	b9 81       	ldd	r27, Y+1	; 0x01
    4d62:	c0 5b       	subi	r28, 0xB0	; 176
    4d64:	d1 40       	sbci	r29, 0x01	; 1
    4d66:	0c 92       	st	X, r0
    4d68:	c0 55       	subi	r28, 0x50	; 80
    4d6a:	de 4f       	sbci	r29, 0xFE	; 254
    4d6c:	e8 81       	ld	r30, Y
    4d6e:	f9 81       	ldd	r31, Y+1	; 0x01
    4d70:	c0 5b       	subi	r28, 0xB0	; 176
    4d72:	d1 40       	sbci	r29, 0x01	; 1
    4d74:	31 96       	adiw	r30, 0x01	; 1
    4d76:	c0 55       	subi	r28, 0x50	; 80
    4d78:	de 4f       	sbci	r29, 0xFE	; 254
    4d7a:	f9 83       	std	Y+1, r31	; 0x01
    4d7c:	e8 83       	st	Y, r30
    4d7e:	c0 5b       	subi	r28, 0xB0	; 176
    4d80:	d1 40       	sbci	r29, 0x01	; 1
    4d82:	cc 54       	subi	r28, 0x4C	; 76
    4d84:	de 4f       	sbci	r29, 0xFE	; 254
    4d86:	f8 81       	ld	r31, Y
    4d88:	c4 5b       	subi	r28, 0xB4	; 180
    4d8a:	d1 40       	sbci	r29, 0x01	; 1
    4d8c:	f1 50       	subi	r31, 0x01	; 1
    4d8e:	cc 54       	subi	r28, 0x4C	; 76
    4d90:	de 4f       	sbci	r29, 0xFE	; 254
    4d92:	f8 83       	st	Y, r31
    4d94:	c4 5b       	subi	r28, 0xB4	; 180
    4d96:	d1 40       	sbci	r29, 0x01	; 1
    4d98:	cc 54       	subi	r28, 0x4C	; 76
    4d9a:	de 4f       	sbci	r29, 0xFE	; 254
    4d9c:	88 81       	ld	r24, Y
    4d9e:	c4 5b       	subi	r28, 0xB4	; 180
    4da0:	d1 40       	sbci	r29, 0x01	; 1
    4da2:	88 23       	and	r24, r24
    4da4:	31 f6       	brne	.-116    	; 0x4d32 <CheckLogin+0x89e>
    4da6:	c2 55       	subi	r28, 0x52	; 82
    4da8:	de 4f       	sbci	r29, 0xFE	; 254
    4daa:	a8 81       	ld	r26, Y
    4dac:	b9 81       	ldd	r27, Y+1	; 0x01
    4dae:	ce 5a       	subi	r28, 0xAE	; 174
    4db0:	d1 40       	sbci	r29, 0x01	; 1
    4db2:	57 96       	adiw	r26, 0x17	; 23
    4db4:	1c 92       	st	X, r1
    4db6:	fe 01       	movw	r30, r28
    4db8:	ec 5a       	subi	r30, 0xAC	; 172
    4dba:	ff 4f       	sbci	r31, 0xFF	; 255
    4dbc:	cb 54       	subi	r28, 0x4B	; 75
    4dbe:	de 4f       	sbci	r29, 0xFE	; 254
    4dc0:	f9 83       	std	Y+1, r31	; 0x01
    4dc2:	e8 83       	st	Y, r30
    4dc4:	c5 5b       	subi	r28, 0xB5	; 181
    4dc6:	d1 40       	sbci	r29, 0x01	; 1
    4dc8:	cb 54       	subi	r28, 0x4B	; 75
    4dca:	de 4f       	sbci	r29, 0xFE	; 254
    4dcc:	88 81       	ld	r24, Y
    4dce:	99 81       	ldd	r25, Y+1	; 0x01
    4dd0:	c5 5b       	subi	r28, 0xB5	; 181
    4dd2:	d1 40       	sbci	r29, 0x01	; 1
    4dd4:	48 96       	adiw	r24, 0x18	; 24
    4dd6:	c9 54       	subi	r28, 0x49	; 73
    4dd8:	de 4f       	sbci	r29, 0xFE	; 254
    4dda:	99 83       	std	Y+1, r25	; 0x01
    4ddc:	88 83       	st	Y, r24
    4dde:	c7 5b       	subi	r28, 0xB7	; 183
    4de0:	d1 40       	sbci	r29, 0x01	; 1
    4de2:	ae ec       	ldi	r26, 0xCE	; 206
    4de4:	b0 e0       	ldi	r27, 0x00	; 0
    4de6:	c7 54       	subi	r28, 0x47	; 71
    4de8:	de 4f       	sbci	r29, 0xFE	; 254
    4dea:	b9 83       	std	Y+1, r27	; 0x01
    4dec:	a8 83       	st	Y, r26
    4dee:	c9 5b       	subi	r28, 0xB9	; 185
    4df0:	d1 40       	sbci	r29, 0x01	; 1
    4df2:	b7 e0       	ldi	r27, 0x07	; 7
    4df4:	c5 54       	subi	r28, 0x45	; 69
    4df6:	de 4f       	sbci	r29, 0xFE	; 254
    4df8:	b8 83       	st	Y, r27
    4dfa:	cb 5b       	subi	r28, 0xBB	; 187
    4dfc:	d1 40       	sbci	r29, 0x01	; 1
    4dfe:	c7 54       	subi	r28, 0x47	; 71
    4e00:	de 4f       	sbci	r29, 0xFE	; 254
    4e02:	e8 81       	ld	r30, Y
    4e04:	f9 81       	ldd	r31, Y+1	; 0x01
    4e06:	c9 5b       	subi	r28, 0xB9	; 185
    4e08:	d1 40       	sbci	r29, 0x01	; 1
    4e0a:	00 80       	ld	r0, Z
    4e0c:	c7 54       	subi	r28, 0x47	; 71
    4e0e:	de 4f       	sbci	r29, 0xFE	; 254
    4e10:	88 81       	ld	r24, Y
    4e12:	99 81       	ldd	r25, Y+1	; 0x01
    4e14:	c9 5b       	subi	r28, 0xB9	; 185
    4e16:	d1 40       	sbci	r29, 0x01	; 1
    4e18:	01 96       	adiw	r24, 0x01	; 1
    4e1a:	c7 54       	subi	r28, 0x47	; 71
    4e1c:	de 4f       	sbci	r29, 0xFE	; 254
    4e1e:	99 83       	std	Y+1, r25	; 0x01
    4e20:	88 83       	st	Y, r24
    4e22:	c9 5b       	subi	r28, 0xB9	; 185
    4e24:	d1 40       	sbci	r29, 0x01	; 1
    4e26:	c9 54       	subi	r28, 0x49	; 73
    4e28:	de 4f       	sbci	r29, 0xFE	; 254
    4e2a:	a8 81       	ld	r26, Y
    4e2c:	b9 81       	ldd	r27, Y+1	; 0x01
    4e2e:	c7 5b       	subi	r28, 0xB7	; 183
    4e30:	d1 40       	sbci	r29, 0x01	; 1
    4e32:	0c 92       	st	X, r0
    4e34:	c9 54       	subi	r28, 0x49	; 73
    4e36:	de 4f       	sbci	r29, 0xFE	; 254
    4e38:	e8 81       	ld	r30, Y
    4e3a:	f9 81       	ldd	r31, Y+1	; 0x01
    4e3c:	c7 5b       	subi	r28, 0xB7	; 183
    4e3e:	d1 40       	sbci	r29, 0x01	; 1
    4e40:	31 96       	adiw	r30, 0x01	; 1
    4e42:	c9 54       	subi	r28, 0x49	; 73
    4e44:	de 4f       	sbci	r29, 0xFE	; 254
    4e46:	f9 83       	std	Y+1, r31	; 0x01
    4e48:	e8 83       	st	Y, r30
    4e4a:	c7 5b       	subi	r28, 0xB7	; 183
    4e4c:	d1 40       	sbci	r29, 0x01	; 1
    4e4e:	c5 54       	subi	r28, 0x45	; 69
    4e50:	de 4f       	sbci	r29, 0xFE	; 254
    4e52:	f8 81       	ld	r31, Y
    4e54:	cb 5b       	subi	r28, 0xBB	; 187
    4e56:	d1 40       	sbci	r29, 0x01	; 1
    4e58:	f1 50       	subi	r31, 0x01	; 1
    4e5a:	c5 54       	subi	r28, 0x45	; 69
    4e5c:	de 4f       	sbci	r29, 0xFE	; 254
    4e5e:	f8 83       	st	Y, r31
    4e60:	cb 5b       	subi	r28, 0xBB	; 187
    4e62:	d1 40       	sbci	r29, 0x01	; 1
    4e64:	c5 54       	subi	r28, 0x45	; 69
    4e66:	de 4f       	sbci	r29, 0xFE	; 254
    4e68:	88 81       	ld	r24, Y
    4e6a:	cb 5b       	subi	r28, 0xBB	; 187
    4e6c:	d1 40       	sbci	r29, 0x01	; 1
    4e6e:	88 23       	and	r24, r24
    4e70:	31 f6       	brne	.-116    	; 0x4dfe <CheckLogin+0x96a>
    4e72:	cb 54       	subi	r28, 0x4B	; 75
    4e74:	de 4f       	sbci	r29, 0xFE	; 254
    4e76:	a8 81       	ld	r26, Y
    4e78:	b9 81       	ldd	r27, Y+1	; 0x01
    4e7a:	c5 5b       	subi	r28, 0xB5	; 181
    4e7c:	d1 40       	sbci	r29, 0x01	; 1
    4e7e:	5f 96       	adiw	r26, 0x1f	; 31
    4e80:	1c 92       	st	X, r1
    4e82:	fe 01       	movw	r30, r28
    4e84:	ec 5a       	subi	r30, 0xAC	; 172
    4e86:	ff 4f       	sbci	r31, 0xFF	; 255
    4e88:	c4 54       	subi	r28, 0x44	; 68
    4e8a:	de 4f       	sbci	r29, 0xFE	; 254
    4e8c:	f9 83       	std	Y+1, r31	; 0x01
    4e8e:	e8 83       	st	Y, r30
    4e90:	cc 5b       	subi	r28, 0xBC	; 188
    4e92:	d1 40       	sbci	r29, 0x01	; 1
    4e94:	c4 54       	subi	r28, 0x44	; 68
    4e96:	de 4f       	sbci	r29, 0xFE	; 254
    4e98:	88 81       	ld	r24, Y
    4e9a:	99 81       	ldd	r25, Y+1	; 0x01
    4e9c:	cc 5b       	subi	r28, 0xBC	; 188
    4e9e:	d1 40       	sbci	r29, 0x01	; 1
    4ea0:	80 96       	adiw	r24, 0x20	; 32
    4ea2:	c2 54       	subi	r28, 0x42	; 66
    4ea4:	de 4f       	sbci	r29, 0xFE	; 254
    4ea6:	99 83       	std	Y+1, r25	; 0x01
    4ea8:	88 83       	st	Y, r24
    4eaa:	ce 5b       	subi	r28, 0xBE	; 190
    4eac:	d1 40       	sbci	r29, 0x01	; 1
    4eae:	a6 ed       	ldi	r26, 0xD6	; 214
    4eb0:	b0 e0       	ldi	r27, 0x00	; 0
    4eb2:	c0 54       	subi	r28, 0x40	; 64
    4eb4:	de 4f       	sbci	r29, 0xFE	; 254
    4eb6:	b9 83       	std	Y+1, r27	; 0x01
    4eb8:	a8 83       	st	Y, r26
    4eba:	c0 5c       	subi	r28, 0xC0	; 192
    4ebc:	d1 40       	sbci	r29, 0x01	; 1
    4ebe:	b7 e0       	ldi	r27, 0x07	; 7
    4ec0:	ce 53       	subi	r28, 0x3E	; 62
    4ec2:	de 4f       	sbci	r29, 0xFE	; 254
    4ec4:	b8 83       	st	Y, r27
    4ec6:	c2 5c       	subi	r28, 0xC2	; 194
    4ec8:	d1 40       	sbci	r29, 0x01	; 1
    4eca:	c0 54       	subi	r28, 0x40	; 64
    4ecc:	de 4f       	sbci	r29, 0xFE	; 254
    4ece:	e8 81       	ld	r30, Y
    4ed0:	f9 81       	ldd	r31, Y+1	; 0x01
    4ed2:	c0 5c       	subi	r28, 0xC0	; 192
    4ed4:	d1 40       	sbci	r29, 0x01	; 1
    4ed6:	00 80       	ld	r0, Z
    4ed8:	c0 54       	subi	r28, 0x40	; 64
    4eda:	de 4f       	sbci	r29, 0xFE	; 254
    4edc:	88 81       	ld	r24, Y
    4ede:	99 81       	ldd	r25, Y+1	; 0x01
    4ee0:	c0 5c       	subi	r28, 0xC0	; 192
    4ee2:	d1 40       	sbci	r29, 0x01	; 1
    4ee4:	01 96       	adiw	r24, 0x01	; 1
    4ee6:	c0 54       	subi	r28, 0x40	; 64
    4ee8:	de 4f       	sbci	r29, 0xFE	; 254
    4eea:	99 83       	std	Y+1, r25	; 0x01
    4eec:	88 83       	st	Y, r24
    4eee:	c0 5c       	subi	r28, 0xC0	; 192
    4ef0:	d1 40       	sbci	r29, 0x01	; 1
    4ef2:	c2 54       	subi	r28, 0x42	; 66
    4ef4:	de 4f       	sbci	r29, 0xFE	; 254
    4ef6:	a8 81       	ld	r26, Y
    4ef8:	b9 81       	ldd	r27, Y+1	; 0x01
    4efa:	ce 5b       	subi	r28, 0xBE	; 190
    4efc:	d1 40       	sbci	r29, 0x01	; 1
    4efe:	0c 92       	st	X, r0
    4f00:	c2 54       	subi	r28, 0x42	; 66
    4f02:	de 4f       	sbci	r29, 0xFE	; 254
    4f04:	e8 81       	ld	r30, Y
    4f06:	f9 81       	ldd	r31, Y+1	; 0x01
    4f08:	ce 5b       	subi	r28, 0xBE	; 190
    4f0a:	d1 40       	sbci	r29, 0x01	; 1
    4f0c:	31 96       	adiw	r30, 0x01	; 1
    4f0e:	c2 54       	subi	r28, 0x42	; 66
    4f10:	de 4f       	sbci	r29, 0xFE	; 254
    4f12:	f9 83       	std	Y+1, r31	; 0x01
    4f14:	e8 83       	st	Y, r30
    4f16:	ce 5b       	subi	r28, 0xBE	; 190
    4f18:	d1 40       	sbci	r29, 0x01	; 1
    4f1a:	ce 53       	subi	r28, 0x3E	; 62
    4f1c:	de 4f       	sbci	r29, 0xFE	; 254
    4f1e:	f8 81       	ld	r31, Y
    4f20:	c2 5c       	subi	r28, 0xC2	; 194
    4f22:	d1 40       	sbci	r29, 0x01	; 1
    4f24:	f1 50       	subi	r31, 0x01	; 1
    4f26:	ce 53       	subi	r28, 0x3E	; 62
    4f28:	de 4f       	sbci	r29, 0xFE	; 254
    4f2a:	f8 83       	st	Y, r31
    4f2c:	c2 5c       	subi	r28, 0xC2	; 194
    4f2e:	d1 40       	sbci	r29, 0x01	; 1
    4f30:	ce 53       	subi	r28, 0x3E	; 62
    4f32:	de 4f       	sbci	r29, 0xFE	; 254
    4f34:	88 81       	ld	r24, Y
    4f36:	c2 5c       	subi	r28, 0xC2	; 194
    4f38:	d1 40       	sbci	r29, 0x01	; 1
    4f3a:	88 23       	and	r24, r24
    4f3c:	31 f6       	brne	.-116    	; 0x4eca <CheckLogin+0xa36>
    4f3e:	c4 54       	subi	r28, 0x44	; 68
    4f40:	de 4f       	sbci	r29, 0xFE	; 254
    4f42:	a8 81       	ld	r26, Y
    4f44:	b9 81       	ldd	r27, Y+1	; 0x01
    4f46:	cc 5b       	subi	r28, 0xBC	; 188
    4f48:	d1 40       	sbci	r29, 0x01	; 1
    4f4a:	97 96       	adiw	r26, 0x27	; 39
    4f4c:	1c 92       	st	X, r1
    4f4e:	fe 01       	movw	r30, r28
    4f50:	ec 5a       	subi	r30, 0xAC	; 172
    4f52:	ff 4f       	sbci	r31, 0xFF	; 255
    4f54:	cd 53       	subi	r28, 0x3D	; 61
    4f56:	de 4f       	sbci	r29, 0xFE	; 254
    4f58:	f9 83       	std	Y+1, r31	; 0x01
    4f5a:	e8 83       	st	Y, r30
    4f5c:	c3 5c       	subi	r28, 0xC3	; 195
    4f5e:	d1 40       	sbci	r29, 0x01	; 1
    4f60:	cd 53       	subi	r28, 0x3D	; 61
    4f62:	de 4f       	sbci	r29, 0xFE	; 254
    4f64:	88 81       	ld	r24, Y
    4f66:	99 81       	ldd	r25, Y+1	; 0x01
    4f68:	c3 5c       	subi	r28, 0xC3	; 195
    4f6a:	d1 40       	sbci	r29, 0x01	; 1
    4f6c:	88 96       	adiw	r24, 0x28	; 40
    4f6e:	cb 53       	subi	r28, 0x3B	; 59
    4f70:	de 4f       	sbci	r29, 0xFE	; 254
    4f72:	99 83       	std	Y+1, r25	; 0x01
    4f74:	88 83       	st	Y, r24
    4f76:	c5 5c       	subi	r28, 0xC5	; 197
    4f78:	d1 40       	sbci	r29, 0x01	; 1
    4f7a:	ae ed       	ldi	r26, 0xDE	; 222
    4f7c:	b0 e0       	ldi	r27, 0x00	; 0
    4f7e:	c9 53       	subi	r28, 0x39	; 57
    4f80:	de 4f       	sbci	r29, 0xFE	; 254
    4f82:	b9 83       	std	Y+1, r27	; 0x01
    4f84:	a8 83       	st	Y, r26
    4f86:	c7 5c       	subi	r28, 0xC7	; 199
    4f88:	d1 40       	sbci	r29, 0x01	; 1
    4f8a:	b7 e0       	ldi	r27, 0x07	; 7
    4f8c:	c7 53       	subi	r28, 0x37	; 55
    4f8e:	de 4f       	sbci	r29, 0xFE	; 254
    4f90:	b8 83       	st	Y, r27
    4f92:	c9 5c       	subi	r28, 0xC9	; 201
    4f94:	d1 40       	sbci	r29, 0x01	; 1
    4f96:	c9 53       	subi	r28, 0x39	; 57
    4f98:	de 4f       	sbci	r29, 0xFE	; 254
    4f9a:	e8 81       	ld	r30, Y
    4f9c:	f9 81       	ldd	r31, Y+1	; 0x01
    4f9e:	c7 5c       	subi	r28, 0xC7	; 199
    4fa0:	d1 40       	sbci	r29, 0x01	; 1
    4fa2:	00 80       	ld	r0, Z
    4fa4:	c9 53       	subi	r28, 0x39	; 57
    4fa6:	de 4f       	sbci	r29, 0xFE	; 254
    4fa8:	88 81       	ld	r24, Y
    4faa:	99 81       	ldd	r25, Y+1	; 0x01
    4fac:	c7 5c       	subi	r28, 0xC7	; 199
    4fae:	d1 40       	sbci	r29, 0x01	; 1
    4fb0:	01 96       	adiw	r24, 0x01	; 1
    4fb2:	c9 53       	subi	r28, 0x39	; 57
    4fb4:	de 4f       	sbci	r29, 0xFE	; 254
    4fb6:	99 83       	std	Y+1, r25	; 0x01
    4fb8:	88 83       	st	Y, r24
    4fba:	c7 5c       	subi	r28, 0xC7	; 199
    4fbc:	d1 40       	sbci	r29, 0x01	; 1
    4fbe:	cb 53       	subi	r28, 0x3B	; 59
    4fc0:	de 4f       	sbci	r29, 0xFE	; 254
    4fc2:	a8 81       	ld	r26, Y
    4fc4:	b9 81       	ldd	r27, Y+1	; 0x01
    4fc6:	c5 5c       	subi	r28, 0xC5	; 197
    4fc8:	d1 40       	sbci	r29, 0x01	; 1
    4fca:	0c 92       	st	X, r0
    4fcc:	cb 53       	subi	r28, 0x3B	; 59
    4fce:	de 4f       	sbci	r29, 0xFE	; 254
    4fd0:	e8 81       	ld	r30, Y
    4fd2:	f9 81       	ldd	r31, Y+1	; 0x01
    4fd4:	c5 5c       	subi	r28, 0xC5	; 197
    4fd6:	d1 40       	sbci	r29, 0x01	; 1
    4fd8:	31 96       	adiw	r30, 0x01	; 1
    4fda:	cb 53       	subi	r28, 0x3B	; 59
    4fdc:	de 4f       	sbci	r29, 0xFE	; 254
    4fde:	f9 83       	std	Y+1, r31	; 0x01
    4fe0:	e8 83       	st	Y, r30
    4fe2:	c5 5c       	subi	r28, 0xC5	; 197
    4fe4:	d1 40       	sbci	r29, 0x01	; 1
    4fe6:	c7 53       	subi	r28, 0x37	; 55
    4fe8:	de 4f       	sbci	r29, 0xFE	; 254
    4fea:	f8 81       	ld	r31, Y
    4fec:	c9 5c       	subi	r28, 0xC9	; 201
    4fee:	d1 40       	sbci	r29, 0x01	; 1
    4ff0:	f1 50       	subi	r31, 0x01	; 1
    4ff2:	c7 53       	subi	r28, 0x37	; 55
    4ff4:	de 4f       	sbci	r29, 0xFE	; 254
    4ff6:	f8 83       	st	Y, r31
    4ff8:	c9 5c       	subi	r28, 0xC9	; 201
    4ffa:	d1 40       	sbci	r29, 0x01	; 1
    4ffc:	c7 53       	subi	r28, 0x37	; 55
    4ffe:	de 4f       	sbci	r29, 0xFE	; 254
    5000:	88 81       	ld	r24, Y
    5002:	c9 5c       	subi	r28, 0xC9	; 201
    5004:	d1 40       	sbci	r29, 0x01	; 1
    5006:	88 23       	and	r24, r24
    5008:	31 f6       	brne	.-116    	; 0x4f96 <CheckLogin+0xb02>
    500a:	cd 53       	subi	r28, 0x3D	; 61
    500c:	de 4f       	sbci	r29, 0xFE	; 254
    500e:	a8 81       	ld	r26, Y
    5010:	b9 81       	ldd	r27, Y+1	; 0x01
    5012:	c3 5c       	subi	r28, 0xC3	; 195
    5014:	d1 40       	sbci	r29, 0x01	; 1
    5016:	9f 96       	adiw	r26, 0x2f	; 47
    5018:	1c 92       	st	X, r1
    501a:	fe 01       	movw	r30, r28
    501c:	ec 5a       	subi	r30, 0xAC	; 172
    501e:	ff 4f       	sbci	r31, 0xFF	; 255
    5020:	c6 53       	subi	r28, 0x36	; 54
    5022:	de 4f       	sbci	r29, 0xFE	; 254
    5024:	f9 83       	std	Y+1, r31	; 0x01
    5026:	e8 83       	st	Y, r30
    5028:	ca 5c       	subi	r28, 0xCA	; 202
    502a:	d1 40       	sbci	r29, 0x01	; 1
    502c:	c6 53       	subi	r28, 0x36	; 54
    502e:	de 4f       	sbci	r29, 0xFE	; 254
    5030:	88 81       	ld	r24, Y
    5032:	99 81       	ldd	r25, Y+1	; 0x01
    5034:	ca 5c       	subi	r28, 0xCA	; 202
    5036:	d1 40       	sbci	r29, 0x01	; 1
    5038:	c0 96       	adiw	r24, 0x30	; 48
    503a:	c4 53       	subi	r28, 0x34	; 52
    503c:	de 4f       	sbci	r29, 0xFE	; 254
    503e:	99 83       	std	Y+1, r25	; 0x01
    5040:	88 83       	st	Y, r24
    5042:	cc 5c       	subi	r28, 0xCC	; 204
    5044:	d1 40       	sbci	r29, 0x01	; 1
    5046:	a6 ee       	ldi	r26, 0xE6	; 230
    5048:	b0 e0       	ldi	r27, 0x00	; 0
    504a:	c2 53       	subi	r28, 0x32	; 50
    504c:	de 4f       	sbci	r29, 0xFE	; 254
    504e:	b9 83       	std	Y+1, r27	; 0x01
    5050:	a8 83       	st	Y, r26
    5052:	ce 5c       	subi	r28, 0xCE	; 206
    5054:	d1 40       	sbci	r29, 0x01	; 1
    5056:	b7 e0       	ldi	r27, 0x07	; 7
    5058:	c0 53       	subi	r28, 0x30	; 48
    505a:	de 4f       	sbci	r29, 0xFE	; 254
    505c:	b8 83       	st	Y, r27
    505e:	c0 5d       	subi	r28, 0xD0	; 208
    5060:	d1 40       	sbci	r29, 0x01	; 1
    5062:	c2 53       	subi	r28, 0x32	; 50
    5064:	de 4f       	sbci	r29, 0xFE	; 254
    5066:	e8 81       	ld	r30, Y
    5068:	f9 81       	ldd	r31, Y+1	; 0x01
    506a:	ce 5c       	subi	r28, 0xCE	; 206
    506c:	d1 40       	sbci	r29, 0x01	; 1
    506e:	00 80       	ld	r0, Z
    5070:	c2 53       	subi	r28, 0x32	; 50
    5072:	de 4f       	sbci	r29, 0xFE	; 254
    5074:	88 81       	ld	r24, Y
    5076:	99 81       	ldd	r25, Y+1	; 0x01
    5078:	ce 5c       	subi	r28, 0xCE	; 206
    507a:	d1 40       	sbci	r29, 0x01	; 1
    507c:	01 96       	adiw	r24, 0x01	; 1
    507e:	c2 53       	subi	r28, 0x32	; 50
    5080:	de 4f       	sbci	r29, 0xFE	; 254
    5082:	99 83       	std	Y+1, r25	; 0x01
    5084:	88 83       	st	Y, r24
    5086:	ce 5c       	subi	r28, 0xCE	; 206
    5088:	d1 40       	sbci	r29, 0x01	; 1
    508a:	c4 53       	subi	r28, 0x34	; 52
    508c:	de 4f       	sbci	r29, 0xFE	; 254
    508e:	a8 81       	ld	r26, Y
    5090:	b9 81       	ldd	r27, Y+1	; 0x01
    5092:	cc 5c       	subi	r28, 0xCC	; 204
    5094:	d1 40       	sbci	r29, 0x01	; 1
    5096:	0c 92       	st	X, r0
    5098:	c4 53       	subi	r28, 0x34	; 52
    509a:	de 4f       	sbci	r29, 0xFE	; 254
    509c:	e8 81       	ld	r30, Y
    509e:	f9 81       	ldd	r31, Y+1	; 0x01
    50a0:	cc 5c       	subi	r28, 0xCC	; 204
    50a2:	d1 40       	sbci	r29, 0x01	; 1
    50a4:	31 96       	adiw	r30, 0x01	; 1
    50a6:	c4 53       	subi	r28, 0x34	; 52
    50a8:	de 4f       	sbci	r29, 0xFE	; 254
    50aa:	f9 83       	std	Y+1, r31	; 0x01
    50ac:	e8 83       	st	Y, r30
    50ae:	cc 5c       	subi	r28, 0xCC	; 204
    50b0:	d1 40       	sbci	r29, 0x01	; 1
    50b2:	c0 53       	subi	r28, 0x30	; 48
    50b4:	de 4f       	sbci	r29, 0xFE	; 254
    50b6:	f8 81       	ld	r31, Y
    50b8:	c0 5d       	subi	r28, 0xD0	; 208
    50ba:	d1 40       	sbci	r29, 0x01	; 1
    50bc:	f1 50       	subi	r31, 0x01	; 1
    50be:	c0 53       	subi	r28, 0x30	; 48
    50c0:	de 4f       	sbci	r29, 0xFE	; 254
    50c2:	f8 83       	st	Y, r31
    50c4:	c0 5d       	subi	r28, 0xD0	; 208
    50c6:	d1 40       	sbci	r29, 0x01	; 1
    50c8:	c0 53       	subi	r28, 0x30	; 48
    50ca:	de 4f       	sbci	r29, 0xFE	; 254
    50cc:	88 81       	ld	r24, Y
    50ce:	c0 5d       	subi	r28, 0xD0	; 208
    50d0:	d1 40       	sbci	r29, 0x01	; 1
    50d2:	88 23       	and	r24, r24
    50d4:	31 f6       	brne	.-116    	; 0x5062 <CheckLogin+0xbce>
    50d6:	c6 53       	subi	r28, 0x36	; 54
    50d8:	de 4f       	sbci	r29, 0xFE	; 254
    50da:	a8 81       	ld	r26, Y
    50dc:	b9 81       	ldd	r27, Y+1	; 0x01
    50de:	ca 5c       	subi	r28, 0xCA	; 202
    50e0:	d1 40       	sbci	r29, 0x01	; 1
    50e2:	d7 96       	adiw	r26, 0x37	; 55
    50e4:	1c 92       	st	X, r1
    50e6:	fe 01       	movw	r30, r28
    50e8:	ec 5a       	subi	r30, 0xAC	; 172
    50ea:	ff 4f       	sbci	r31, 0xFF	; 255
    50ec:	cf 52       	subi	r28, 0x2F	; 47
    50ee:	de 4f       	sbci	r29, 0xFE	; 254
    50f0:	f9 83       	std	Y+1, r31	; 0x01
    50f2:	e8 83       	st	Y, r30
    50f4:	c1 5d       	subi	r28, 0xD1	; 209
    50f6:	d1 40       	sbci	r29, 0x01	; 1
    50f8:	cf 52       	subi	r28, 0x2F	; 47
    50fa:	de 4f       	sbci	r29, 0xFE	; 254
    50fc:	88 81       	ld	r24, Y
    50fe:	99 81       	ldd	r25, Y+1	; 0x01
    5100:	c1 5d       	subi	r28, 0xD1	; 209
    5102:	d1 40       	sbci	r29, 0x01	; 1
    5104:	c8 96       	adiw	r24, 0x38	; 56
    5106:	cd 52       	subi	r28, 0x2D	; 45
    5108:	de 4f       	sbci	r29, 0xFE	; 254
    510a:	99 83       	std	Y+1, r25	; 0x01
    510c:	88 83       	st	Y, r24
    510e:	c3 5d       	subi	r28, 0xD3	; 211
    5110:	d1 40       	sbci	r29, 0x01	; 1
    5112:	ae ee       	ldi	r26, 0xEE	; 238
    5114:	b0 e0       	ldi	r27, 0x00	; 0
    5116:	cb 52       	subi	r28, 0x2B	; 43
    5118:	de 4f       	sbci	r29, 0xFE	; 254
    511a:	b9 83       	std	Y+1, r27	; 0x01
    511c:	a8 83       	st	Y, r26
    511e:	c5 5d       	subi	r28, 0xD5	; 213
    5120:	d1 40       	sbci	r29, 0x01	; 1
    5122:	b7 e0       	ldi	r27, 0x07	; 7
    5124:	c9 52       	subi	r28, 0x29	; 41
    5126:	de 4f       	sbci	r29, 0xFE	; 254
    5128:	b8 83       	st	Y, r27
    512a:	c7 5d       	subi	r28, 0xD7	; 215
    512c:	d1 40       	sbci	r29, 0x01	; 1
    512e:	cb 52       	subi	r28, 0x2B	; 43
    5130:	de 4f       	sbci	r29, 0xFE	; 254
    5132:	e8 81       	ld	r30, Y
    5134:	f9 81       	ldd	r31, Y+1	; 0x01
    5136:	c5 5d       	subi	r28, 0xD5	; 213
    5138:	d1 40       	sbci	r29, 0x01	; 1
    513a:	00 80       	ld	r0, Z
    513c:	cb 52       	subi	r28, 0x2B	; 43
    513e:	de 4f       	sbci	r29, 0xFE	; 254
    5140:	88 81       	ld	r24, Y
    5142:	99 81       	ldd	r25, Y+1	; 0x01
    5144:	c5 5d       	subi	r28, 0xD5	; 213
    5146:	d1 40       	sbci	r29, 0x01	; 1
    5148:	01 96       	adiw	r24, 0x01	; 1
    514a:	cb 52       	subi	r28, 0x2B	; 43
    514c:	de 4f       	sbci	r29, 0xFE	; 254
    514e:	99 83       	std	Y+1, r25	; 0x01
    5150:	88 83       	st	Y, r24
    5152:	c5 5d       	subi	r28, 0xD5	; 213
    5154:	d1 40       	sbci	r29, 0x01	; 1
    5156:	cd 52       	subi	r28, 0x2D	; 45
    5158:	de 4f       	sbci	r29, 0xFE	; 254
    515a:	a8 81       	ld	r26, Y
    515c:	b9 81       	ldd	r27, Y+1	; 0x01
    515e:	c3 5d       	subi	r28, 0xD3	; 211
    5160:	d1 40       	sbci	r29, 0x01	; 1
    5162:	0c 92       	st	X, r0
    5164:	cd 52       	subi	r28, 0x2D	; 45
    5166:	de 4f       	sbci	r29, 0xFE	; 254
    5168:	e8 81       	ld	r30, Y
    516a:	f9 81       	ldd	r31, Y+1	; 0x01
    516c:	c3 5d       	subi	r28, 0xD3	; 211
    516e:	d1 40       	sbci	r29, 0x01	; 1
    5170:	31 96       	adiw	r30, 0x01	; 1
    5172:	cd 52       	subi	r28, 0x2D	; 45
    5174:	de 4f       	sbci	r29, 0xFE	; 254
    5176:	f9 83       	std	Y+1, r31	; 0x01
    5178:	e8 83       	st	Y, r30
    517a:	c3 5d       	subi	r28, 0xD3	; 211
    517c:	d1 40       	sbci	r29, 0x01	; 1
    517e:	c9 52       	subi	r28, 0x29	; 41
    5180:	de 4f       	sbci	r29, 0xFE	; 254
    5182:	f8 81       	ld	r31, Y
    5184:	c7 5d       	subi	r28, 0xD7	; 215
    5186:	d1 40       	sbci	r29, 0x01	; 1
    5188:	f1 50       	subi	r31, 0x01	; 1
    518a:	c9 52       	subi	r28, 0x29	; 41
    518c:	de 4f       	sbci	r29, 0xFE	; 254
    518e:	f8 83       	st	Y, r31
    5190:	c7 5d       	subi	r28, 0xD7	; 215
    5192:	d1 40       	sbci	r29, 0x01	; 1
    5194:	c9 52       	subi	r28, 0x29	; 41
    5196:	de 4f       	sbci	r29, 0xFE	; 254
    5198:	88 81       	ld	r24, Y
    519a:	c7 5d       	subi	r28, 0xD7	; 215
    519c:	d1 40       	sbci	r29, 0x01	; 1
    519e:	88 23       	and	r24, r24
    51a0:	31 f6       	brne	.-116    	; 0x512e <CheckLogin+0xc9a>
    51a2:	cf 52       	subi	r28, 0x2F	; 47
    51a4:	de 4f       	sbci	r29, 0xFE	; 254
    51a6:	a8 81       	ld	r26, Y
    51a8:	b9 81       	ldd	r27, Y+1	; 0x01
    51aa:	c1 5d       	subi	r28, 0xD1	; 209
    51ac:	d1 40       	sbci	r29, 0x01	; 1
    51ae:	df 96       	adiw	r26, 0x3f	; 63
    51b0:	1c 92       	st	X, r1
    51b2:	fe 01       	movw	r30, r28
    51b4:	ec 5a       	subi	r30, 0xAC	; 172
    51b6:	ff 4f       	sbci	r31, 0xFF	; 255
    51b8:	c8 52       	subi	r28, 0x28	; 40
    51ba:	de 4f       	sbci	r29, 0xFE	; 254
    51bc:	f9 83       	std	Y+1, r31	; 0x01
    51be:	e8 83       	st	Y, r30
    51c0:	c8 5d       	subi	r28, 0xD8	; 216
    51c2:	d1 40       	sbci	r29, 0x01	; 1
    51c4:	c8 52       	subi	r28, 0x28	; 40
    51c6:	de 4f       	sbci	r29, 0xFE	; 254
    51c8:	88 81       	ld	r24, Y
    51ca:	99 81       	ldd	r25, Y+1	; 0x01
    51cc:	c8 5d       	subi	r28, 0xD8	; 216
    51ce:	d1 40       	sbci	r29, 0x01	; 1
    51d0:	80 5c       	subi	r24, 0xC0	; 192
    51d2:	9f 4f       	sbci	r25, 0xFF	; 255
    51d4:	c6 52       	subi	r28, 0x26	; 38
    51d6:	de 4f       	sbci	r29, 0xFE	; 254
    51d8:	99 83       	std	Y+1, r25	; 0x01
    51da:	88 83       	st	Y, r24
    51dc:	ca 5d       	subi	r28, 0xDA	; 218
    51de:	d1 40       	sbci	r29, 0x01	; 1
    51e0:	a6 ef       	ldi	r26, 0xF6	; 246
    51e2:	b0 e0       	ldi	r27, 0x00	; 0
    51e4:	c4 52       	subi	r28, 0x24	; 36
    51e6:	de 4f       	sbci	r29, 0xFE	; 254
    51e8:	b9 83       	std	Y+1, r27	; 0x01
    51ea:	a8 83       	st	Y, r26
    51ec:	cc 5d       	subi	r28, 0xDC	; 220
    51ee:	d1 40       	sbci	r29, 0x01	; 1
    51f0:	b7 e0       	ldi	r27, 0x07	; 7
    51f2:	c2 52       	subi	r28, 0x22	; 34
    51f4:	de 4f       	sbci	r29, 0xFE	; 254
    51f6:	b8 83       	st	Y, r27
    51f8:	ce 5d       	subi	r28, 0xDE	; 222
    51fa:	d1 40       	sbci	r29, 0x01	; 1
    51fc:	c4 52       	subi	r28, 0x24	; 36
    51fe:	de 4f       	sbci	r29, 0xFE	; 254
    5200:	e8 81       	ld	r30, Y
    5202:	f9 81       	ldd	r31, Y+1	; 0x01
    5204:	cc 5d       	subi	r28, 0xDC	; 220
    5206:	d1 40       	sbci	r29, 0x01	; 1
    5208:	00 80       	ld	r0, Z
    520a:	c4 52       	subi	r28, 0x24	; 36
    520c:	de 4f       	sbci	r29, 0xFE	; 254
    520e:	88 81       	ld	r24, Y
    5210:	99 81       	ldd	r25, Y+1	; 0x01
    5212:	cc 5d       	subi	r28, 0xDC	; 220
    5214:	d1 40       	sbci	r29, 0x01	; 1
    5216:	01 96       	adiw	r24, 0x01	; 1
    5218:	c4 52       	subi	r28, 0x24	; 36
    521a:	de 4f       	sbci	r29, 0xFE	; 254
    521c:	99 83       	std	Y+1, r25	; 0x01
    521e:	88 83       	st	Y, r24
    5220:	cc 5d       	subi	r28, 0xDC	; 220
    5222:	d1 40       	sbci	r29, 0x01	; 1
    5224:	c6 52       	subi	r28, 0x26	; 38
    5226:	de 4f       	sbci	r29, 0xFE	; 254
    5228:	a8 81       	ld	r26, Y
    522a:	b9 81       	ldd	r27, Y+1	; 0x01
    522c:	ca 5d       	subi	r28, 0xDA	; 218
    522e:	d1 40       	sbci	r29, 0x01	; 1
    5230:	0c 92       	st	X, r0
    5232:	c6 52       	subi	r28, 0x26	; 38
    5234:	de 4f       	sbci	r29, 0xFE	; 254
    5236:	e8 81       	ld	r30, Y
    5238:	f9 81       	ldd	r31, Y+1	; 0x01
    523a:	ca 5d       	subi	r28, 0xDA	; 218
    523c:	d1 40       	sbci	r29, 0x01	; 1
    523e:	31 96       	adiw	r30, 0x01	; 1
    5240:	c6 52       	subi	r28, 0x26	; 38
    5242:	de 4f       	sbci	r29, 0xFE	; 254
    5244:	f9 83       	std	Y+1, r31	; 0x01
    5246:	e8 83       	st	Y, r30
    5248:	ca 5d       	subi	r28, 0xDA	; 218
    524a:	d1 40       	sbci	r29, 0x01	; 1
    524c:	c2 52       	subi	r28, 0x22	; 34
    524e:	de 4f       	sbci	r29, 0xFE	; 254
    5250:	f8 81       	ld	r31, Y
    5252:	ce 5d       	subi	r28, 0xDE	; 222
    5254:	d1 40       	sbci	r29, 0x01	; 1
    5256:	f1 50       	subi	r31, 0x01	; 1
    5258:	c2 52       	subi	r28, 0x22	; 34
    525a:	de 4f       	sbci	r29, 0xFE	; 254
    525c:	f8 83       	st	Y, r31
    525e:	ce 5d       	subi	r28, 0xDE	; 222
    5260:	d1 40       	sbci	r29, 0x01	; 1
    5262:	c2 52       	subi	r28, 0x22	; 34
    5264:	de 4f       	sbci	r29, 0xFE	; 254
    5266:	88 81       	ld	r24, Y
    5268:	ce 5d       	subi	r28, 0xDE	; 222
    526a:	d1 40       	sbci	r29, 0x01	; 1
    526c:	88 23       	and	r24, r24
    526e:	31 f6       	brne	.-116    	; 0x51fc <CheckLogin+0xd68>
    5270:	c8 52       	subi	r28, 0x28	; 40
    5272:	de 4f       	sbci	r29, 0xFE	; 254
    5274:	e8 81       	ld	r30, Y
    5276:	f9 81       	ldd	r31, Y+1	; 0x01
    5278:	c8 5d       	subi	r28, 0xD8	; 216
    527a:	d1 40       	sbci	r29, 0x01	; 1
    527c:	e9 5b       	subi	r30, 0xB9	; 185
    527e:	ff 4f       	sbci	r31, 0xFF	; 255
    5280:	10 82       	st	Z, r1
    5282:	ce 01       	movw	r24, r28
    5284:	8c 5a       	subi	r24, 0xAC	; 172
    5286:	9f 4f       	sbci	r25, 0xFF	; 255
    5288:	88 5b       	subi	r24, 0xB8	; 184
    528a:	9f 4f       	sbci	r25, 0xFF	; 255
    528c:	c1 52       	subi	r28, 0x21	; 33
    528e:	de 4f       	sbci	r29, 0xFE	; 254
    5290:	99 83       	std	Y+1, r25	; 0x01
    5292:	88 83       	st	Y, r24
    5294:	cf 5d       	subi	r28, 0xDF	; 223
    5296:	d1 40       	sbci	r29, 0x01	; 1
    5298:	ae ef       	ldi	r26, 0xFE	; 254
    529a:	b0 e0       	ldi	r27, 0x00	; 0
    529c:	cf 51       	subi	r28, 0x1F	; 31
    529e:	de 4f       	sbci	r29, 0xFE	; 254
    52a0:	b9 83       	std	Y+1, r27	; 0x01
    52a2:	a8 83       	st	Y, r26
    52a4:	c1 5e       	subi	r28, 0xE1	; 225
    52a6:	d1 40       	sbci	r29, 0x01	; 1
    52a8:	b8 e0       	ldi	r27, 0x08	; 8
    52aa:	cd 51       	subi	r28, 0x1D	; 29
    52ac:	de 4f       	sbci	r29, 0xFE	; 254
    52ae:	b8 83       	st	Y, r27
    52b0:	c3 5e       	subi	r28, 0xE3	; 227
    52b2:	d1 40       	sbci	r29, 0x01	; 1
    52b4:	cf 51       	subi	r28, 0x1F	; 31
    52b6:	de 4f       	sbci	r29, 0xFE	; 254
    52b8:	e8 81       	ld	r30, Y
    52ba:	f9 81       	ldd	r31, Y+1	; 0x01
    52bc:	c1 5e       	subi	r28, 0xE1	; 225
    52be:	d1 40       	sbci	r29, 0x01	; 1
    52c0:	00 80       	ld	r0, Z
    52c2:	cf 51       	subi	r28, 0x1F	; 31
    52c4:	de 4f       	sbci	r29, 0xFE	; 254
    52c6:	88 81       	ld	r24, Y
    52c8:	99 81       	ldd	r25, Y+1	; 0x01
    52ca:	c1 5e       	subi	r28, 0xE1	; 225
    52cc:	d1 40       	sbci	r29, 0x01	; 1
    52ce:	01 96       	adiw	r24, 0x01	; 1
    52d0:	cf 51       	subi	r28, 0x1F	; 31
    52d2:	de 4f       	sbci	r29, 0xFE	; 254
    52d4:	99 83       	std	Y+1, r25	; 0x01
    52d6:	88 83       	st	Y, r24
    52d8:	c1 5e       	subi	r28, 0xE1	; 225
    52da:	d1 40       	sbci	r29, 0x01	; 1
    52dc:	c1 52       	subi	r28, 0x21	; 33
    52de:	de 4f       	sbci	r29, 0xFE	; 254
    52e0:	a8 81       	ld	r26, Y
    52e2:	b9 81       	ldd	r27, Y+1	; 0x01
    52e4:	cf 5d       	subi	r28, 0xDF	; 223
    52e6:	d1 40       	sbci	r29, 0x01	; 1
    52e8:	0c 92       	st	X, r0
    52ea:	c1 52       	subi	r28, 0x21	; 33
    52ec:	de 4f       	sbci	r29, 0xFE	; 254
    52ee:	e8 81       	ld	r30, Y
    52f0:	f9 81       	ldd	r31, Y+1	; 0x01
    52f2:	cf 5d       	subi	r28, 0xDF	; 223
    52f4:	d1 40       	sbci	r29, 0x01	; 1
    52f6:	31 96       	adiw	r30, 0x01	; 1
    52f8:	c1 52       	subi	r28, 0x21	; 33
    52fa:	de 4f       	sbci	r29, 0xFE	; 254
    52fc:	f9 83       	std	Y+1, r31	; 0x01
    52fe:	e8 83       	st	Y, r30
    5300:	cf 5d       	subi	r28, 0xDF	; 223
    5302:	d1 40       	sbci	r29, 0x01	; 1
    5304:	cd 51       	subi	r28, 0x1D	; 29
    5306:	de 4f       	sbci	r29, 0xFE	; 254
    5308:	f8 81       	ld	r31, Y
    530a:	c3 5e       	subi	r28, 0xE3	; 227
    530c:	d1 40       	sbci	r29, 0x01	; 1
    530e:	f1 50       	subi	r31, 0x01	; 1
    5310:	cd 51       	subi	r28, 0x1D	; 29
    5312:	de 4f       	sbci	r29, 0xFE	; 254
    5314:	f8 83       	st	Y, r31
    5316:	c3 5e       	subi	r28, 0xE3	; 227
    5318:	d1 40       	sbci	r29, 0x01	; 1
    531a:	cd 51       	subi	r28, 0x1D	; 29
    531c:	de 4f       	sbci	r29, 0xFE	; 254
    531e:	88 81       	ld	r24, Y
    5320:	c3 5e       	subi	r28, 0xE3	; 227
    5322:	d1 40       	sbci	r29, 0x01	; 1
    5324:	88 23       	and	r24, r24
    5326:	31 f6       	brne	.-116    	; 0x52b4 <CheckLogin+0xe20>
	 char trails = 0, rxusername[100], rxpassword[100];
    5328:	19 82       	std	Y+1, r1	; 0x01
	USART_Flush();
    532a:	0e 94 41 2c 	call	0x5882	; 0x5882 <USART_Flush>
	USART_SendString("Enter UserName\r");
    532e:	86 e9       	ldi	r24, 0x96	; 150
    5330:	90 e0       	ldi	r25, 0x00	; 0
    5332:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <USART_SendString>
	while (!Usart_ReceiveString_Del(rxusername,'\r'));
    5336:	ce 01       	movw	r24, r28
    5338:	8c 55       	subi	r24, 0x5C	; 92
    533a:	9f 4f       	sbci	r25, 0xFF	; 255
    533c:	6d e0       	ldi	r22, 0x0D	; 13
    533e:	0e 94 7f 2c 	call	0x58fe	; 0x58fe <Usart_ReceiveString_Del>
    5342:	88 23       	and	r24, r24
    5344:	c1 f3       	breq	.-16     	; 0x5336 <CheckLogin+0xea2>
	USART_SendString("Enter Password\r");
    5346:	86 ea       	ldi	r24, 0xA6	; 166
    5348:	90 e0       	ldi	r25, 0x00	; 0
    534a:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <USART_SendString>
	while (!Usart_ReceiveString_Del(rxpassword,'\r'));
    534e:	ce 01       	movw	r24, r28
    5350:	88 5f       	subi	r24, 0xF8	; 248
    5352:	9e 4f       	sbci	r25, 0xFE	; 254
    5354:	6d e0       	ldi	r22, 0x0D	; 13
    5356:	0e 94 7f 2c 	call	0x58fe	; 0x58fe <Usart_ReceiveString_Del>
    535a:	88 23       	and	r24, r24
    535c:	c1 f3       	breq	.-16     	; 0x534e <CheckLogin+0xeba>

	for (i = 0; i < 10; i++) {
    535e:	1b 82       	std	Y+3, r1	; 0x03
    5360:	31 c0       	rjmp	.+98     	; 0x53c4 <CheckLogin+0xf30>
		if (!strcmp(username[i], rxusername)
    5362:	9e 01       	movw	r18, r28
    5364:	2c 5f       	subi	r18, 0xFC	; 252
    5366:	3f 4f       	sbci	r19, 0xFF	; 255
    5368:	8b 81       	ldd	r24, Y+3	; 0x03
    536a:	88 2f       	mov	r24, r24
    536c:	90 e0       	ldi	r25, 0x00	; 0
    536e:	88 0f       	add	r24, r24
    5370:	99 1f       	adc	r25, r25
    5372:	88 0f       	add	r24, r24
    5374:	99 1f       	adc	r25, r25
    5376:	88 0f       	add	r24, r24
    5378:	99 1f       	adc	r25, r25
    537a:	82 0f       	add	r24, r18
    537c:	93 1f       	adc	r25, r19
    537e:	9e 01       	movw	r18, r28
    5380:	2c 55       	subi	r18, 0x5C	; 92
    5382:	3f 4f       	sbci	r19, 0xFF	; 255
    5384:	b9 01       	movw	r22, r18
    5386:	0e 94 cb 2e 	call	0x5d96	; 0x5d96 <strcmp>
    538a:	00 97       	sbiw	r24, 0x00	; 0
    538c:	c1 f4       	brne	.+48     	; 0x53be <CheckLogin+0xf2a>
    538e:	9e 01       	movw	r18, r28
    5390:	2c 5a       	subi	r18, 0xAC	; 172
    5392:	3f 4f       	sbci	r19, 0xFF	; 255
    5394:	8b 81       	ldd	r24, Y+3	; 0x03
    5396:	88 2f       	mov	r24, r24
    5398:	90 e0       	ldi	r25, 0x00	; 0
    539a:	88 0f       	add	r24, r24
    539c:	99 1f       	adc	r25, r25
    539e:	88 0f       	add	r24, r24
    53a0:	99 1f       	adc	r25, r25
    53a2:	88 0f       	add	r24, r24
    53a4:	99 1f       	adc	r25, r25
    53a6:	82 0f       	add	r24, r18
    53a8:	93 1f       	adc	r25, r19
    53aa:	9e 01       	movw	r18, r28
    53ac:	28 5f       	subi	r18, 0xF8	; 248
    53ae:	3e 4f       	sbci	r19, 0xFE	; 254
    53b0:	b9 01       	movw	r22, r18
    53b2:	0e 94 cb 2e 	call	0x5d96	; 0x5d96 <strcmp>
    53b6:	00 97       	sbiw	r24, 0x00	; 0
    53b8:	11 f4       	brne	.+4      	; 0x53be <CheckLogin+0xf2a>
				&& !strcmp(password[i], rxpassword)) {
			state = 1;
    53ba:	81 e0       	ldi	r24, 0x01	; 1
    53bc:	8a 83       	std	Y+2, r24	; 0x02
	USART_SendString("Enter UserName\r");
	while (!Usart_ReceiveString_Del(rxusername,'\r'));
	USART_SendString("Enter Password\r");
	while (!Usart_ReceiveString_Del(rxpassword,'\r'));

	for (i = 0; i < 10; i++) {
    53be:	8b 81       	ldd	r24, Y+3	; 0x03
    53c0:	8f 5f       	subi	r24, 0xFF	; 255
    53c2:	8b 83       	std	Y+3, r24	; 0x03
    53c4:	8b 81       	ldd	r24, Y+3	; 0x03
    53c6:	8a 30       	cpi	r24, 0x0A	; 10
    53c8:	60 f2       	brcs	.-104    	; 0x5362 <CheckLogin+0xece>
				&& !strcmp(password[i], rxpassword)) {
			state = 1;
		}
	}

	return state;
    53ca:	8a 81       	ldd	r24, Y+2	; 0x02
}
    53cc:	cd 51       	subi	r28, 0x1D	; 29
    53ce:	de 4f       	sbci	r29, 0xFE	; 254
    53d0:	0f b6       	in	r0, 0x3f	; 63
    53d2:	f8 94       	cli
    53d4:	de bf       	out	0x3e, r29	; 62
    53d6:	0f be       	out	0x3f, r0	; 63
    53d8:	cd bf       	out	0x3d, r28	; 61
    53da:	cf 91       	pop	r28
    53dc:	df 91       	pop	r29
    53de:	08 95       	ret

000053e0 <Alarm>:

void Alarm(void) {
    53e0:	df 93       	push	r29
    53e2:	cf 93       	push	r28
    53e4:	cd b7       	in	r28, 0x3d	; 61
    53e6:	de b7       	in	r29, 0x3e	; 62
    53e8:	2e 97       	sbiw	r28, 0x0e	; 14
    53ea:	0f b6       	in	r0, 0x3f	; 63
    53ec:	f8 94       	cli
    53ee:	de bf       	out	0x3e, r29	; 62
    53f0:	0f be       	out	0x3f, r0	; 63
    53f2:	cd bf       	out	0x3d, r28	; 61
    53f4:	80 e0       	ldi	r24, 0x00	; 0
    53f6:	90 e0       	ldi	r25, 0x00	; 0
    53f8:	a8 e4       	ldi	r26, 0x48	; 72
    53fa:	b3 e4       	ldi	r27, 0x43	; 67
    53fc:	8b 87       	std	Y+11, r24	; 0x0b
    53fe:	9c 87       	std	Y+12, r25	; 0x0c
    5400:	ad 87       	std	Y+13, r26	; 0x0d
    5402:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5404:	6b 85       	ldd	r22, Y+11	; 0x0b
    5406:	7c 85       	ldd	r23, Y+12	; 0x0c
    5408:	8d 85       	ldd	r24, Y+13	; 0x0d
    540a:	9e 85       	ldd	r25, Y+14	; 0x0e
    540c:	20 e0       	ldi	r18, 0x00	; 0
    540e:	30 e0       	ldi	r19, 0x00	; 0
    5410:	4a ef       	ldi	r20, 0xFA	; 250
    5412:	54 e4       	ldi	r21, 0x44	; 68
    5414:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5418:	dc 01       	movw	r26, r24
    541a:	cb 01       	movw	r24, r22
    541c:	8f 83       	std	Y+7, r24	; 0x07
    541e:	98 87       	std	Y+8, r25	; 0x08
    5420:	a9 87       	std	Y+9, r26	; 0x09
    5422:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5424:	6f 81       	ldd	r22, Y+7	; 0x07
    5426:	78 85       	ldd	r23, Y+8	; 0x08
    5428:	89 85       	ldd	r24, Y+9	; 0x09
    542a:	9a 85       	ldd	r25, Y+10	; 0x0a
    542c:	20 e0       	ldi	r18, 0x00	; 0
    542e:	30 e0       	ldi	r19, 0x00	; 0
    5430:	40 e8       	ldi	r20, 0x80	; 128
    5432:	5f e3       	ldi	r21, 0x3F	; 63
    5434:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    5438:	88 23       	and	r24, r24
    543a:	2c f4       	brge	.+10     	; 0x5446 <Alarm+0x66>
		__ticks = 1;
    543c:	81 e0       	ldi	r24, 0x01	; 1
    543e:	90 e0       	ldi	r25, 0x00	; 0
    5440:	9e 83       	std	Y+6, r25	; 0x06
    5442:	8d 83       	std	Y+5, r24	; 0x05
    5444:	3f c0       	rjmp	.+126    	; 0x54c4 <Alarm+0xe4>
	else if (__tmp > 65535)
    5446:	6f 81       	ldd	r22, Y+7	; 0x07
    5448:	78 85       	ldd	r23, Y+8	; 0x08
    544a:	89 85       	ldd	r24, Y+9	; 0x09
    544c:	9a 85       	ldd	r25, Y+10	; 0x0a
    544e:	20 e0       	ldi	r18, 0x00	; 0
    5450:	3f ef       	ldi	r19, 0xFF	; 255
    5452:	4f e7       	ldi	r20, 0x7F	; 127
    5454:	57 e4       	ldi	r21, 0x47	; 71
    5456:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    545a:	18 16       	cp	r1, r24
    545c:	4c f5       	brge	.+82     	; 0x54b0 <Alarm+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    545e:	6b 85       	ldd	r22, Y+11	; 0x0b
    5460:	7c 85       	ldd	r23, Y+12	; 0x0c
    5462:	8d 85       	ldd	r24, Y+13	; 0x0d
    5464:	9e 85       	ldd	r25, Y+14	; 0x0e
    5466:	20 e0       	ldi	r18, 0x00	; 0
    5468:	30 e0       	ldi	r19, 0x00	; 0
    546a:	40 e2       	ldi	r20, 0x20	; 32
    546c:	51 e4       	ldi	r21, 0x41	; 65
    546e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5472:	dc 01       	movw	r26, r24
    5474:	cb 01       	movw	r24, r22
    5476:	bc 01       	movw	r22, r24
    5478:	cd 01       	movw	r24, r26
    547a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    547e:	dc 01       	movw	r26, r24
    5480:	cb 01       	movw	r24, r22
    5482:	9e 83       	std	Y+6, r25	; 0x06
    5484:	8d 83       	std	Y+5, r24	; 0x05
    5486:	0f c0       	rjmp	.+30     	; 0x54a6 <Alarm+0xc6>
    5488:	88 ec       	ldi	r24, 0xC8	; 200
    548a:	90 e0       	ldi	r25, 0x00	; 0
    548c:	9c 83       	std	Y+4, r25	; 0x04
    548e:	8b 83       	std	Y+3, r24	; 0x03
    5490:	8b 81       	ldd	r24, Y+3	; 0x03
    5492:	9c 81       	ldd	r25, Y+4	; 0x04
    5494:	01 97       	sbiw	r24, 0x01	; 1
    5496:	f1 f7       	brne	.-4      	; 0x5494 <Alarm+0xb4>
    5498:	9c 83       	std	Y+4, r25	; 0x04
    549a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    549c:	8d 81       	ldd	r24, Y+5	; 0x05
    549e:	9e 81       	ldd	r25, Y+6	; 0x06
    54a0:	01 97       	sbiw	r24, 0x01	; 1
    54a2:	9e 83       	std	Y+6, r25	; 0x06
    54a4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    54a6:	8d 81       	ldd	r24, Y+5	; 0x05
    54a8:	9e 81       	ldd	r25, Y+6	; 0x06
    54aa:	00 97       	sbiw	r24, 0x00	; 0
    54ac:	69 f7       	brne	.-38     	; 0x5488 <Alarm+0xa8>
    54ae:	14 c0       	rjmp	.+40     	; 0x54d8 <Alarm+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    54b0:	6f 81       	ldd	r22, Y+7	; 0x07
    54b2:	78 85       	ldd	r23, Y+8	; 0x08
    54b4:	89 85       	ldd	r24, Y+9	; 0x09
    54b6:	9a 85       	ldd	r25, Y+10	; 0x0a
    54b8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    54bc:	dc 01       	movw	r26, r24
    54be:	cb 01       	movw	r24, r22
    54c0:	9e 83       	std	Y+6, r25	; 0x06
    54c2:	8d 83       	std	Y+5, r24	; 0x05
    54c4:	8d 81       	ldd	r24, Y+5	; 0x05
    54c6:	9e 81       	ldd	r25, Y+6	; 0x06
    54c8:	9a 83       	std	Y+2, r25	; 0x02
    54ca:	89 83       	std	Y+1, r24	; 0x01
    54cc:	89 81       	ldd	r24, Y+1	; 0x01
    54ce:	9a 81       	ldd	r25, Y+2	; 0x02
    54d0:	01 97       	sbiw	r24, 0x01	; 1
    54d2:	f1 f7       	brne	.-4      	; 0x54d0 <Alarm+0xf0>
    54d4:	9a 83       	std	Y+2, r25	; 0x02
    54d6:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(200);
	LED1_BUZZER_LED2 ^= (1 << BuzzerPin) | (1 << LED1pin);
    54d8:	a8 e3       	ldi	r26, 0x38	; 56
    54da:	b0 e0       	ldi	r27, 0x00	; 0
    54dc:	e8 e3       	ldi	r30, 0x38	; 56
    54de:	f0 e0       	ldi	r31, 0x00	; 0
    54e0:	90 81       	ld	r25, Z
    54e2:	83 e0       	ldi	r24, 0x03	; 3
    54e4:	89 27       	eor	r24, r25
    54e6:	8c 93       	st	X, r24

}
    54e8:	2e 96       	adiw	r28, 0x0e	; 14
    54ea:	0f b6       	in	r0, 0x3f	; 63
    54ec:	f8 94       	cli
    54ee:	de bf       	out	0x3e, r29	; 62
    54f0:	0f be       	out	0x3f, r0	; 63
    54f2:	cd bf       	out	0x3d, r28	; 61
    54f4:	cf 91       	pop	r28
    54f6:	df 91       	pop	r29
    54f8:	08 95       	ret

000054fa <SmartLock_Feature>:
void SmartLock_Feature(void) {
    54fa:	df 93       	push	r29
    54fc:	cf 93       	push	r28
    54fe:	cd b7       	in	r28, 0x3d	; 61
    5500:	de b7       	in	r29, 0x3e	; 62
    5502:	6f 97       	sbiw	r28, 0x1f	; 31
    5504:	0f b6       	in	r0, 0x3f	; 63
    5506:	f8 94       	cli
    5508:	de bf       	out	0x3e, r29	; 62
    550a:	0f be       	out	0x3f, r0	; 63
    550c:	cd bf       	out	0x3d, r28	; 61

	USART_SendString(" Send 1 to turn on/of led\r");
    550e:	86 e0       	ldi	r24, 0x06	; 6
    5510:	91 e0       	ldi	r25, 0x01	; 1
    5512:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <USART_SendString>
    5516:	80 e0       	ldi	r24, 0x00	; 0
    5518:	90 e0       	ldi	r25, 0x00	; 0
    551a:	a6 e9       	ldi	r26, 0x96	; 150
    551c:	b3 e4       	ldi	r27, 0x43	; 67
    551e:	89 8f       	std	Y+25, r24	; 0x19
    5520:	9a 8f       	std	Y+26, r25	; 0x1a
    5522:	ab 8f       	std	Y+27, r26	; 0x1b
    5524:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5526:	69 8d       	ldd	r22, Y+25	; 0x19
    5528:	7a 8d       	ldd	r23, Y+26	; 0x1a
    552a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    552c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    552e:	20 e0       	ldi	r18, 0x00	; 0
    5530:	30 e0       	ldi	r19, 0x00	; 0
    5532:	4a ef       	ldi	r20, 0xFA	; 250
    5534:	54 e4       	ldi	r21, 0x44	; 68
    5536:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    553a:	dc 01       	movw	r26, r24
    553c:	cb 01       	movw	r24, r22
    553e:	8d 8b       	std	Y+21, r24	; 0x15
    5540:	9e 8b       	std	Y+22, r25	; 0x16
    5542:	af 8b       	std	Y+23, r26	; 0x17
    5544:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    5546:	6d 89       	ldd	r22, Y+21	; 0x15
    5548:	7e 89       	ldd	r23, Y+22	; 0x16
    554a:	8f 89       	ldd	r24, Y+23	; 0x17
    554c:	98 8d       	ldd	r25, Y+24	; 0x18
    554e:	20 e0       	ldi	r18, 0x00	; 0
    5550:	30 e0       	ldi	r19, 0x00	; 0
    5552:	40 e8       	ldi	r20, 0x80	; 128
    5554:	5f e3       	ldi	r21, 0x3F	; 63
    5556:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    555a:	88 23       	and	r24, r24
    555c:	2c f4       	brge	.+10     	; 0x5568 <SmartLock_Feature+0x6e>
		__ticks = 1;
    555e:	81 e0       	ldi	r24, 0x01	; 1
    5560:	90 e0       	ldi	r25, 0x00	; 0
    5562:	9c 8b       	std	Y+20, r25	; 0x14
    5564:	8b 8b       	std	Y+19, r24	; 0x13
    5566:	3f c0       	rjmp	.+126    	; 0x55e6 <SmartLock_Feature+0xec>
	else if (__tmp > 65535)
    5568:	6d 89       	ldd	r22, Y+21	; 0x15
    556a:	7e 89       	ldd	r23, Y+22	; 0x16
    556c:	8f 89       	ldd	r24, Y+23	; 0x17
    556e:	98 8d       	ldd	r25, Y+24	; 0x18
    5570:	20 e0       	ldi	r18, 0x00	; 0
    5572:	3f ef       	ldi	r19, 0xFF	; 255
    5574:	4f e7       	ldi	r20, 0x7F	; 127
    5576:	57 e4       	ldi	r21, 0x47	; 71
    5578:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    557c:	18 16       	cp	r1, r24
    557e:	4c f5       	brge	.+82     	; 0x55d2 <SmartLock_Feature+0xd8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5580:	69 8d       	ldd	r22, Y+25	; 0x19
    5582:	7a 8d       	ldd	r23, Y+26	; 0x1a
    5584:	8b 8d       	ldd	r24, Y+27	; 0x1b
    5586:	9c 8d       	ldd	r25, Y+28	; 0x1c
    5588:	20 e0       	ldi	r18, 0x00	; 0
    558a:	30 e0       	ldi	r19, 0x00	; 0
    558c:	40 e2       	ldi	r20, 0x20	; 32
    558e:	51 e4       	ldi	r21, 0x41	; 65
    5590:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5594:	dc 01       	movw	r26, r24
    5596:	cb 01       	movw	r24, r22
    5598:	bc 01       	movw	r22, r24
    559a:	cd 01       	movw	r24, r26
    559c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    55a0:	dc 01       	movw	r26, r24
    55a2:	cb 01       	movw	r24, r22
    55a4:	9c 8b       	std	Y+20, r25	; 0x14
    55a6:	8b 8b       	std	Y+19, r24	; 0x13
    55a8:	0f c0       	rjmp	.+30     	; 0x55c8 <SmartLock_Feature+0xce>
    55aa:	88 ec       	ldi	r24, 0xC8	; 200
    55ac:	90 e0       	ldi	r25, 0x00	; 0
    55ae:	9a 8b       	std	Y+18, r25	; 0x12
    55b0:	89 8b       	std	Y+17, r24	; 0x11
    55b2:	89 89       	ldd	r24, Y+17	; 0x11
    55b4:	9a 89       	ldd	r25, Y+18	; 0x12
    55b6:	01 97       	sbiw	r24, 0x01	; 1
    55b8:	f1 f7       	brne	.-4      	; 0x55b6 <SmartLock_Feature+0xbc>
    55ba:	9a 8b       	std	Y+18, r25	; 0x12
    55bc:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    55be:	8b 89       	ldd	r24, Y+19	; 0x13
    55c0:	9c 89       	ldd	r25, Y+20	; 0x14
    55c2:	01 97       	sbiw	r24, 0x01	; 1
    55c4:	9c 8b       	std	Y+20, r25	; 0x14
    55c6:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    55c8:	8b 89       	ldd	r24, Y+19	; 0x13
    55ca:	9c 89       	ldd	r25, Y+20	; 0x14
    55cc:	00 97       	sbiw	r24, 0x00	; 0
    55ce:	69 f7       	brne	.-38     	; 0x55aa <SmartLock_Feature+0xb0>
    55d0:	14 c0       	rjmp	.+40     	; 0x55fa <SmartLock_Feature+0x100>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    55d2:	6d 89       	ldd	r22, Y+21	; 0x15
    55d4:	7e 89       	ldd	r23, Y+22	; 0x16
    55d6:	8f 89       	ldd	r24, Y+23	; 0x17
    55d8:	98 8d       	ldd	r25, Y+24	; 0x18
    55da:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    55de:	dc 01       	movw	r26, r24
    55e0:	cb 01       	movw	r24, r22
    55e2:	9c 8b       	std	Y+20, r25	; 0x14
    55e4:	8b 8b       	std	Y+19, r24	; 0x13
    55e6:	8b 89       	ldd	r24, Y+19	; 0x13
    55e8:	9c 89       	ldd	r25, Y+20	; 0x14
    55ea:	98 8b       	std	Y+16, r25	; 0x10
    55ec:	8f 87       	std	Y+15, r24	; 0x0f
    55ee:	8f 85       	ldd	r24, Y+15	; 0x0f
    55f0:	98 89       	ldd	r25, Y+16	; 0x10
    55f2:	01 97       	sbiw	r24, 0x01	; 1
    55f4:	f1 f7       	brne	.-4      	; 0x55f2 <SmartLock_Feature+0xf8>
    55f6:	98 8b       	std	Y+16, r25	; 0x10
    55f8:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(300);
	USART_SendString(" 2 to lock/unlock the door\r");
    55fa:	81 e2       	ldi	r24, 0x21	; 33
    55fc:	91 e0       	ldi	r25, 0x01	; 1
    55fe:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <USART_SendString>
    5602:	80 e0       	ldi	r24, 0x00	; 0
    5604:	90 e0       	ldi	r25, 0x00	; 0
    5606:	a6 e9       	ldi	r26, 0x96	; 150
    5608:	b3 e4       	ldi	r27, 0x43	; 67
    560a:	8b 87       	std	Y+11, r24	; 0x0b
    560c:	9c 87       	std	Y+12, r25	; 0x0c
    560e:	ad 87       	std	Y+13, r26	; 0x0d
    5610:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5612:	6b 85       	ldd	r22, Y+11	; 0x0b
    5614:	7c 85       	ldd	r23, Y+12	; 0x0c
    5616:	8d 85       	ldd	r24, Y+13	; 0x0d
    5618:	9e 85       	ldd	r25, Y+14	; 0x0e
    561a:	20 e0       	ldi	r18, 0x00	; 0
    561c:	30 e0       	ldi	r19, 0x00	; 0
    561e:	4a ef       	ldi	r20, 0xFA	; 250
    5620:	54 e4       	ldi	r21, 0x44	; 68
    5622:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5626:	dc 01       	movw	r26, r24
    5628:	cb 01       	movw	r24, r22
    562a:	8f 83       	std	Y+7, r24	; 0x07
    562c:	98 87       	std	Y+8, r25	; 0x08
    562e:	a9 87       	std	Y+9, r26	; 0x09
    5630:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5632:	6f 81       	ldd	r22, Y+7	; 0x07
    5634:	78 85       	ldd	r23, Y+8	; 0x08
    5636:	89 85       	ldd	r24, Y+9	; 0x09
    5638:	9a 85       	ldd	r25, Y+10	; 0x0a
    563a:	20 e0       	ldi	r18, 0x00	; 0
    563c:	30 e0       	ldi	r19, 0x00	; 0
    563e:	40 e8       	ldi	r20, 0x80	; 128
    5640:	5f e3       	ldi	r21, 0x3F	; 63
    5642:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    5646:	88 23       	and	r24, r24
    5648:	2c f4       	brge	.+10     	; 0x5654 <SmartLock_Feature+0x15a>
		__ticks = 1;
    564a:	81 e0       	ldi	r24, 0x01	; 1
    564c:	90 e0       	ldi	r25, 0x00	; 0
    564e:	9e 83       	std	Y+6, r25	; 0x06
    5650:	8d 83       	std	Y+5, r24	; 0x05
    5652:	3f c0       	rjmp	.+126    	; 0x56d2 <SmartLock_Feature+0x1d8>
	else if (__tmp > 65535)
    5654:	6f 81       	ldd	r22, Y+7	; 0x07
    5656:	78 85       	ldd	r23, Y+8	; 0x08
    5658:	89 85       	ldd	r24, Y+9	; 0x09
    565a:	9a 85       	ldd	r25, Y+10	; 0x0a
    565c:	20 e0       	ldi	r18, 0x00	; 0
    565e:	3f ef       	ldi	r19, 0xFF	; 255
    5660:	4f e7       	ldi	r20, 0x7F	; 127
    5662:	57 e4       	ldi	r21, 0x47	; 71
    5664:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    5668:	18 16       	cp	r1, r24
    566a:	4c f5       	brge	.+82     	; 0x56be <SmartLock_Feature+0x1c4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    566c:	6b 85       	ldd	r22, Y+11	; 0x0b
    566e:	7c 85       	ldd	r23, Y+12	; 0x0c
    5670:	8d 85       	ldd	r24, Y+13	; 0x0d
    5672:	9e 85       	ldd	r25, Y+14	; 0x0e
    5674:	20 e0       	ldi	r18, 0x00	; 0
    5676:	30 e0       	ldi	r19, 0x00	; 0
    5678:	40 e2       	ldi	r20, 0x20	; 32
    567a:	51 e4       	ldi	r21, 0x41	; 65
    567c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5680:	dc 01       	movw	r26, r24
    5682:	cb 01       	movw	r24, r22
    5684:	bc 01       	movw	r22, r24
    5686:	cd 01       	movw	r24, r26
    5688:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    568c:	dc 01       	movw	r26, r24
    568e:	cb 01       	movw	r24, r22
    5690:	9e 83       	std	Y+6, r25	; 0x06
    5692:	8d 83       	std	Y+5, r24	; 0x05
    5694:	0f c0       	rjmp	.+30     	; 0x56b4 <SmartLock_Feature+0x1ba>
    5696:	88 ec       	ldi	r24, 0xC8	; 200
    5698:	90 e0       	ldi	r25, 0x00	; 0
    569a:	9c 83       	std	Y+4, r25	; 0x04
    569c:	8b 83       	std	Y+3, r24	; 0x03
    569e:	8b 81       	ldd	r24, Y+3	; 0x03
    56a0:	9c 81       	ldd	r25, Y+4	; 0x04
    56a2:	01 97       	sbiw	r24, 0x01	; 1
    56a4:	f1 f7       	brne	.-4      	; 0x56a2 <SmartLock_Feature+0x1a8>
    56a6:	9c 83       	std	Y+4, r25	; 0x04
    56a8:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    56aa:	8d 81       	ldd	r24, Y+5	; 0x05
    56ac:	9e 81       	ldd	r25, Y+6	; 0x06
    56ae:	01 97       	sbiw	r24, 0x01	; 1
    56b0:	9e 83       	std	Y+6, r25	; 0x06
    56b2:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    56b4:	8d 81       	ldd	r24, Y+5	; 0x05
    56b6:	9e 81       	ldd	r25, Y+6	; 0x06
    56b8:	00 97       	sbiw	r24, 0x00	; 0
    56ba:	69 f7       	brne	.-38     	; 0x5696 <SmartLock_Feature+0x19c>
    56bc:	14 c0       	rjmp	.+40     	; 0x56e6 <SmartLock_Feature+0x1ec>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    56be:	6f 81       	ldd	r22, Y+7	; 0x07
    56c0:	78 85       	ldd	r23, Y+8	; 0x08
    56c2:	89 85       	ldd	r24, Y+9	; 0x09
    56c4:	9a 85       	ldd	r25, Y+10	; 0x0a
    56c6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    56ca:	dc 01       	movw	r26, r24
    56cc:	cb 01       	movw	r24, r22
    56ce:	9e 83       	std	Y+6, r25	; 0x06
    56d0:	8d 83       	std	Y+5, r24	; 0x05
    56d2:	8d 81       	ldd	r24, Y+5	; 0x05
    56d4:	9e 81       	ldd	r25, Y+6	; 0x06
    56d6:	9a 83       	std	Y+2, r25	; 0x02
    56d8:	89 83       	std	Y+1, r24	; 0x01
    56da:	89 81       	ldd	r24, Y+1	; 0x01
    56dc:	9a 81       	ldd	r25, Y+2	; 0x02
    56de:	01 97       	sbiw	r24, 0x01	; 1
    56e0:	f1 f7       	brne	.-4      	; 0x56de <SmartLock_Feature+0x1e4>
    56e2:	9a 83       	std	Y+2, r25	; 0x02
    56e4:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(300);
	USART_SendString(" 3 to exit\r");
    56e6:	8d e3       	ldi	r24, 0x3D	; 61
    56e8:	91 e0       	ldi	r25, 0x01	; 1
    56ea:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <USART_SendString>
	char Feature = 0;
    56ee:	1d 8e       	std	Y+29, r1	; 0x1d
    56f0:	23 c0       	rjmp	.+70     	; 0x5738 <SmartLock_Feature+0x23e>
	while (Feature != '3') {
		switch (Feature) {
    56f2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    56f4:	28 2f       	mov	r18, r24
    56f6:	30 e0       	ldi	r19, 0x00	; 0
    56f8:	3f 8f       	std	Y+31, r19	; 0x1f
    56fa:	2e 8f       	std	Y+30, r18	; 0x1e
    56fc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    56fe:	9f 8d       	ldd	r25, Y+31	; 0x1f
    5700:	81 33       	cpi	r24, 0x31	; 49
    5702:	91 05       	cpc	r25, r1
    5704:	31 f0       	breq	.+12     	; 0x5712 <SmartLock_Feature+0x218>
    5706:	2e 8d       	ldd	r18, Y+30	; 0x1e
    5708:	3f 8d       	ldd	r19, Y+31	; 0x1f
    570a:	22 33       	cpi	r18, 0x32	; 50
    570c:	31 05       	cpc	r19, r1
    570e:	69 f0       	breq	.+26     	; 0x572a <SmartLock_Feature+0x230>
    5710:	10 c0       	rjmp	.+32     	; 0x5732 <SmartLock_Feature+0x238>
		case LIGHT:
		    LED1_BUZZER_LED2 ^= (1 << PB2);
    5712:	a8 e3       	ldi	r26, 0x38	; 56
    5714:	b0 e0       	ldi	r27, 0x00	; 0
    5716:	e8 e3       	ldi	r30, 0x38	; 56
    5718:	f0 e0       	ldi	r31, 0x00	; 0
    571a:	90 81       	ld	r25, Z
    571c:	84 e0       	ldi	r24, 0x04	; 4
    571e:	89 27       	eor	r24, r25
    5720:	8c 93       	st	X, r24
			Feature = USART_RxChar();
    5722:	0e 94 1b 2c 	call	0x5836	; 0x5836 <USART_RxChar>
    5726:	8d 8f       	std	Y+29, r24	; 0x1d
    5728:	07 c0       	rjmp	.+14     	; 0x5738 <SmartLock_Feature+0x23e>
			break;
		case LOCK:
			Feature = USART_RxChar();
    572a:	0e 94 1b 2c 	call	0x5836	; 0x5836 <USART_RxChar>
    572e:	8d 8f       	std	Y+29, r24	; 0x1d
    5730:	03 c0       	rjmp	.+6      	; 0x5738 <SmartLock_Feature+0x23e>
			break;
		default:
			Feature = USART_RxChar();
    5732:	0e 94 1b 2c 	call	0x5836	; 0x5836 <USART_RxChar>
    5736:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(300);
	USART_SendString(" 2 to lock/unlock the door\r");
	_delay_ms(300);
	USART_SendString(" 3 to exit\r");
	char Feature = 0;
	while (Feature != '3') {
    5738:	8d 8d       	ldd	r24, Y+29	; 0x1d
    573a:	83 33       	cpi	r24, 0x33	; 51
    573c:	d1 f6       	brne	.-76     	; 0x56f2 <SmartLock_Feature+0x1f8>
		default:
			Feature = USART_RxChar();
			break;
		}
	}
}
    573e:	6f 96       	adiw	r28, 0x1f	; 31
    5740:	0f b6       	in	r0, 0x3f	; 63
    5742:	f8 94       	cli
    5744:	de bf       	out	0x3e, r29	; 62
    5746:	0f be       	out	0x3f, r0	; 63
    5748:	cd bf       	out	0x3d, r28	; 61
    574a:	cf 91       	pop	r28
    574c:	df 91       	pop	r29
    574e:	08 95       	ret

00005750 <USART_Init>:
 */ 

#include "USART_RS232_H_file.h"						/* Include USART header file */

void USART_Init(unsigned long BAUDRATE)				/* USART initialize function */
{ 
    5750:	0f 93       	push	r16
    5752:	1f 93       	push	r17
    5754:	df 93       	push	r29
    5756:	cf 93       	push	r28
    5758:	00 d0       	rcall	.+0      	; 0x575a <USART_Init+0xa>
    575a:	00 d0       	rcall	.+0      	; 0x575c <USART_Init+0xc>
    575c:	cd b7       	in	r28, 0x3d	; 61
    575e:	de b7       	in	r29, 0x3e	; 62
    5760:	69 83       	std	Y+1, r22	; 0x01
    5762:	7a 83       	std	Y+2, r23	; 0x02
    5764:	8b 83       	std	Y+3, r24	; 0x03
    5766:	9c 83       	std	Y+4, r25	; 0x04
	UCSRB |= (1 << RXEN) | (1 << TXEN);				/* Enable USART transmitter and receiver */
    5768:	aa e2       	ldi	r26, 0x2A	; 42
    576a:	b0 e0       	ldi	r27, 0x00	; 0
    576c:	ea e2       	ldi	r30, 0x2A	; 42
    576e:	f0 e0       	ldi	r31, 0x00	; 0
    5770:	80 81       	ld	r24, Z
    5772:	88 61       	ori	r24, 0x18	; 24
    5774:	8c 93       	st	X, r24
	UCSRC |= (1 << URSEL)| (1 << UCSZ0) | (1 << UCSZ1);	/* Write USCRC for 8 bit data and 1 stop bit */ 
    5776:	a0 e4       	ldi	r26, 0x40	; 64
    5778:	b0 e0       	ldi	r27, 0x00	; 0
    577a:	e0 e4       	ldi	r30, 0x40	; 64
    577c:	f0 e0       	ldi	r31, 0x00	; 0
    577e:	80 81       	ld	r24, Z
    5780:	86 68       	ori	r24, 0x86	; 134
    5782:	8c 93       	st	X, r24
	UBRRL = BAUD_PRESCALE;							/* Load UBRRL with lower 8 bit of prescale value */
    5784:	09 e2       	ldi	r16, 0x29	; 41
    5786:	10 e0       	ldi	r17, 0x00	; 0
    5788:	89 81       	ldd	r24, Y+1	; 0x01
    578a:	9a 81       	ldd	r25, Y+2	; 0x02
    578c:	ab 81       	ldd	r26, Y+3	; 0x03
    578e:	bc 81       	ldd	r27, Y+4	; 0x04
    5790:	88 0f       	add	r24, r24
    5792:	99 1f       	adc	r25, r25
    5794:	aa 1f       	adc	r26, r26
    5796:	bb 1f       	adc	r27, r27
    5798:	88 0f       	add	r24, r24
    579a:	99 1f       	adc	r25, r25
    579c:	aa 1f       	adc	r26, r26
    579e:	bb 1f       	adc	r27, r27
    57a0:	88 0f       	add	r24, r24
    57a2:	99 1f       	adc	r25, r25
    57a4:	aa 1f       	adc	r26, r26
    57a6:	bb 1f       	adc	r27, r27
    57a8:	88 0f       	add	r24, r24
    57aa:	99 1f       	adc	r25, r25
    57ac:	aa 1f       	adc	r26, r26
    57ae:	bb 1f       	adc	r27, r27
    57b0:	9c 01       	movw	r18, r24
    57b2:	ad 01       	movw	r20, r26
    57b4:	80 e0       	ldi	r24, 0x00	; 0
    57b6:	92 e1       	ldi	r25, 0x12	; 18
    57b8:	aa e7       	ldi	r26, 0x7A	; 122
    57ba:	b0 e0       	ldi	r27, 0x00	; 0
    57bc:	bc 01       	movw	r22, r24
    57be:	cd 01       	movw	r24, r26
    57c0:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <__udivmodsi4>
    57c4:	da 01       	movw	r26, r20
    57c6:	c9 01       	movw	r24, r18
    57c8:	81 50       	subi	r24, 0x01	; 1
    57ca:	f8 01       	movw	r30, r16
    57cc:	80 83       	st	Z, r24
	UBRRH = (BAUD_PRESCALE >> 8);					/* Load UBRRH with upper 8 bit of prescale value */
    57ce:	00 e4       	ldi	r16, 0x40	; 64
    57d0:	10 e0       	ldi	r17, 0x00	; 0
    57d2:	89 81       	ldd	r24, Y+1	; 0x01
    57d4:	9a 81       	ldd	r25, Y+2	; 0x02
    57d6:	ab 81       	ldd	r26, Y+3	; 0x03
    57d8:	bc 81       	ldd	r27, Y+4	; 0x04
    57da:	88 0f       	add	r24, r24
    57dc:	99 1f       	adc	r25, r25
    57de:	aa 1f       	adc	r26, r26
    57e0:	bb 1f       	adc	r27, r27
    57e2:	88 0f       	add	r24, r24
    57e4:	99 1f       	adc	r25, r25
    57e6:	aa 1f       	adc	r26, r26
    57e8:	bb 1f       	adc	r27, r27
    57ea:	88 0f       	add	r24, r24
    57ec:	99 1f       	adc	r25, r25
    57ee:	aa 1f       	adc	r26, r26
    57f0:	bb 1f       	adc	r27, r27
    57f2:	88 0f       	add	r24, r24
    57f4:	99 1f       	adc	r25, r25
    57f6:	aa 1f       	adc	r26, r26
    57f8:	bb 1f       	adc	r27, r27
    57fa:	9c 01       	movw	r18, r24
    57fc:	ad 01       	movw	r20, r26
    57fe:	80 e0       	ldi	r24, 0x00	; 0
    5800:	92 e1       	ldi	r25, 0x12	; 18
    5802:	aa e7       	ldi	r26, 0x7A	; 122
    5804:	b0 e0       	ldi	r27, 0x00	; 0
    5806:	bc 01       	movw	r22, r24
    5808:	cd 01       	movw	r24, r26
    580a:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <__udivmodsi4>
    580e:	da 01       	movw	r26, r20
    5810:	c9 01       	movw	r24, r18
    5812:	01 97       	sbiw	r24, 0x01	; 1
    5814:	a1 09       	sbc	r26, r1
    5816:	b1 09       	sbc	r27, r1
    5818:	89 2f       	mov	r24, r25
    581a:	9a 2f       	mov	r25, r26
    581c:	ab 2f       	mov	r26, r27
    581e:	bb 27       	eor	r27, r27
    5820:	f8 01       	movw	r30, r16
    5822:	80 83       	st	Z, r24
}
    5824:	0f 90       	pop	r0
    5826:	0f 90       	pop	r0
    5828:	0f 90       	pop	r0
    582a:	0f 90       	pop	r0
    582c:	cf 91       	pop	r28
    582e:	df 91       	pop	r29
    5830:	1f 91       	pop	r17
    5832:	0f 91       	pop	r16
    5834:	08 95       	ret

00005836 <USART_RxChar>:

char USART_RxChar()									/* Data receiving function */
{
    5836:	df 93       	push	r29
    5838:	cf 93       	push	r28
    583a:	cd b7       	in	r28, 0x3d	; 61
    583c:	de b7       	in	r29, 0x3e	; 62
	while (!(UCSRA & (1 << RXC)));					/* Wait until new data receive */
    583e:	eb e2       	ldi	r30, 0x2B	; 43
    5840:	f0 e0       	ldi	r31, 0x00	; 0
    5842:	80 81       	ld	r24, Z
    5844:	88 23       	and	r24, r24
    5846:	dc f7       	brge	.-10     	; 0x583e <USART_RxChar+0x8>
	return(UDR);									/* Get and return received data */ 
    5848:	ec e2       	ldi	r30, 0x2C	; 44
    584a:	f0 e0       	ldi	r31, 0x00	; 0
    584c:	80 81       	ld	r24, Z
}
    584e:	cf 91       	pop	r28
    5850:	df 91       	pop	r29
    5852:	08 95       	ret

00005854 <USART_TxChar>:

void USART_TxChar(char data)						/* Data transmitting function */
{
    5854:	df 93       	push	r29
    5856:	cf 93       	push	r28
    5858:	0f 92       	push	r0
    585a:	cd b7       	in	r28, 0x3d	; 61
    585c:	de b7       	in	r29, 0x3e	; 62
    585e:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSRA & (1<<UDRE)));					/* Wait until data transmit and buffer get empty */
    5860:	eb e2       	ldi	r30, 0x2B	; 43
    5862:	f0 e0       	ldi	r31, 0x00	; 0
    5864:	80 81       	ld	r24, Z
    5866:	88 2f       	mov	r24, r24
    5868:	90 e0       	ldi	r25, 0x00	; 0
    586a:	80 72       	andi	r24, 0x20	; 32
    586c:	90 70       	andi	r25, 0x00	; 0
    586e:	00 97       	sbiw	r24, 0x00	; 0
    5870:	b9 f3       	breq	.-18     	; 0x5860 <USART_TxChar+0xc>
	UDR = data;										/* Write data to be transmitting in UDR */
    5872:	ec e2       	ldi	r30, 0x2C	; 44
    5874:	f0 e0       	ldi	r31, 0x00	; 0
    5876:	89 81       	ldd	r24, Y+1	; 0x01
    5878:	80 83       	st	Z, r24

}
    587a:	0f 90       	pop	r0
    587c:	cf 91       	pop	r28
    587e:	df 91       	pop	r29
    5880:	08 95       	ret

00005882 <USART_Flush>:
void USART_Flush( void )
{
    5882:	df 93       	push	r29
    5884:	cf 93       	push	r28
    5886:	0f 92       	push	r0
    5888:	cd b7       	in	r28, 0x3d	; 61
    588a:	de b7       	in	r29, 0x3e	; 62
    588c:	04 c0       	rjmp	.+8      	; 0x5896 <USART_Flush+0x14>
unsigned char dummy;
while ( UCSRA & (1<<RXC) )
{
dummy = UDR;
    588e:	ec e2       	ldi	r30, 0x2C	; 44
    5890:	f0 e0       	ldi	r31, 0x00	; 0
    5892:	80 81       	ld	r24, Z
    5894:	89 83       	std	Y+1, r24	; 0x01

}
void USART_Flush( void )
{
unsigned char dummy;
while ( UCSRA & (1<<RXC) )
    5896:	eb e2       	ldi	r30, 0x2B	; 43
    5898:	f0 e0       	ldi	r31, 0x00	; 0
    589a:	80 81       	ld	r24, Z
    589c:	88 23       	and	r24, r24
    589e:	bc f3       	brlt	.-18     	; 0x588e <USART_Flush+0xc>
{
dummy = UDR;
}
}
    58a0:	0f 90       	pop	r0
    58a2:	cf 91       	pop	r28
    58a4:	df 91       	pop	r29
    58a6:	08 95       	ret

000058a8 <USART_SendString>:
void USART_SendString(char *str)					/* Send string of USART data function */ 
{
    58a8:	df 93       	push	r29
    58aa:	cf 93       	push	r28
    58ac:	00 d0       	rcall	.+0      	; 0x58ae <USART_SendString+0x6>
    58ae:	00 d0       	rcall	.+0      	; 0x58b0 <USART_SendString+0x8>
    58b0:	cd b7       	in	r28, 0x3d	; 61
    58b2:	de b7       	in	r29, 0x3e	; 62
    58b4:	9c 83       	std	Y+4, r25	; 0x04
    58b6:	8b 83       	std	Y+3, r24	; 0x03
	int i=0;																	
    58b8:	1a 82       	std	Y+2, r1	; 0x02
    58ba:	19 82       	std	Y+1, r1	; 0x01
    58bc:	0f c0       	rjmp	.+30     	; 0x58dc <USART_SendString+0x34>
	while (str[i]!=0)
	{
		USART_TxChar(str[i]);						/* Send each char of string till the NULL */
    58be:	29 81       	ldd	r18, Y+1	; 0x01
    58c0:	3a 81       	ldd	r19, Y+2	; 0x02
    58c2:	8b 81       	ldd	r24, Y+3	; 0x03
    58c4:	9c 81       	ldd	r25, Y+4	; 0x04
    58c6:	fc 01       	movw	r30, r24
    58c8:	e2 0f       	add	r30, r18
    58ca:	f3 1f       	adc	r31, r19
    58cc:	80 81       	ld	r24, Z
    58ce:	0e 94 2a 2c 	call	0x5854	; 0x5854 <USART_TxChar>
		i++;
    58d2:	89 81       	ldd	r24, Y+1	; 0x01
    58d4:	9a 81       	ldd	r25, Y+2	; 0x02
    58d6:	01 96       	adiw	r24, 0x01	; 1
    58d8:	9a 83       	std	Y+2, r25	; 0x02
    58da:	89 83       	std	Y+1, r24	; 0x01
}
}
void USART_SendString(char *str)					/* Send string of USART data function */ 
{
	int i=0;																	
	while (str[i]!=0)
    58dc:	29 81       	ldd	r18, Y+1	; 0x01
    58de:	3a 81       	ldd	r19, Y+2	; 0x02
    58e0:	8b 81       	ldd	r24, Y+3	; 0x03
    58e2:	9c 81       	ldd	r25, Y+4	; 0x04
    58e4:	fc 01       	movw	r30, r24
    58e6:	e2 0f       	add	r30, r18
    58e8:	f3 1f       	adc	r31, r19
    58ea:	80 81       	ld	r24, Z
    58ec:	88 23       	and	r24, r24
    58ee:	39 f7       	brne	.-50     	; 0x58be <USART_SendString+0x16>
	{
		USART_TxChar(str[i]);						/* Send each char of string till the NULL */
		i++;
	}
}
    58f0:	0f 90       	pop	r0
    58f2:	0f 90       	pop	r0
    58f4:	0f 90       	pop	r0
    58f6:	0f 90       	pop	r0
    58f8:	cf 91       	pop	r28
    58fa:	df 91       	pop	r29
    58fc:	08 95       	ret

000058fe <Usart_ReceiveString_Del>:
uint8_t Usart_ReceiveString_Del( uint8_t* buf,uint8_t delimeter){
    58fe:	0f 93       	push	r16
    5900:	1f 93       	push	r17
    5902:	df 93       	push	r29
    5904:	cf 93       	push	r28
    5906:	cd b7       	in	r28, 0x3d	; 61
    5908:	de b7       	in	r29, 0x3e	; 62
    590a:	28 97       	sbiw	r28, 0x08	; 8
    590c:	0f b6       	in	r0, 0x3f	; 63
    590e:	f8 94       	cli
    5910:	de bf       	out	0x3e, r29	; 62
    5912:	0f be       	out	0x3f, r0	; 63
    5914:	cd bf       	out	0x3d, r28	; 61
    5916:	9f 83       	std	Y+7, r25	; 0x07
    5918:	8e 83       	std	Y+6, r24	; 0x06
    591a:	68 87       	std	Y+8, r22	; 0x08
	uint32_t length=0;
    591c:	1a 82       	std	Y+2, r1	; 0x02
    591e:	1b 82       	std	Y+3, r1	; 0x03
    5920:	1c 82       	std	Y+4, r1	; 0x04
    5922:	1d 82       	std	Y+5, r1	; 0x05
	uint8_t data = delimeter+1;// yamken el zero hwa 7ato delimeter 3aez inital msh delimeter
    5924:	88 85       	ldd	r24, Y+8	; 0x08
    5926:	8f 5f       	subi	r24, 0xFF	; 255
    5928:	89 83       	std	Y+1, r24	; 0x01
    592a:	1f c0       	rjmp	.+62     	; 0x596a <Usart_ReceiveString_Del+0x6c>
	while( data != delimeter )
	{
		    buf[length]= USART_RxChar();
    592c:	2a 81       	ldd	r18, Y+2	; 0x02
    592e:	3b 81       	ldd	r19, Y+3	; 0x03
    5930:	8e 81       	ldd	r24, Y+6	; 0x06
    5932:	9f 81       	ldd	r25, Y+7	; 0x07
    5934:	8c 01       	movw	r16, r24
    5936:	02 0f       	add	r16, r18
    5938:	13 1f       	adc	r17, r19
    593a:	0e 94 1b 2c 	call	0x5836	; 0x5836 <USART_RxChar>
    593e:	f8 01       	movw	r30, r16
    5940:	80 83       	st	Z, r24
			data = buf[length];
    5942:	2a 81       	ldd	r18, Y+2	; 0x02
    5944:	3b 81       	ldd	r19, Y+3	; 0x03
    5946:	8e 81       	ldd	r24, Y+6	; 0x06
    5948:	9f 81       	ldd	r25, Y+7	; 0x07
    594a:	fc 01       	movw	r30, r24
    594c:	e2 0f       	add	r30, r18
    594e:	f3 1f       	adc	r31, r19
    5950:	80 81       	ld	r24, Z
    5952:	89 83       	std	Y+1, r24	; 0x01
			length++;
    5954:	8a 81       	ldd	r24, Y+2	; 0x02
    5956:	9b 81       	ldd	r25, Y+3	; 0x03
    5958:	ac 81       	ldd	r26, Y+4	; 0x04
    595a:	bd 81       	ldd	r27, Y+5	; 0x05
    595c:	01 96       	adiw	r24, 0x01	; 1
    595e:	a1 1d       	adc	r26, r1
    5960:	b1 1d       	adc	r27, r1
    5962:	8a 83       	std	Y+2, r24	; 0x02
    5964:	9b 83       	std	Y+3, r25	; 0x03
    5966:	ac 83       	std	Y+4, r26	; 0x04
    5968:	bd 83       	std	Y+5, r27	; 0x05
	}
}
uint8_t Usart_ReceiveString_Del( uint8_t* buf,uint8_t delimeter){
	uint32_t length=0;
	uint8_t data = delimeter+1;// yamken el zero hwa 7ato delimeter 3aez inital msh delimeter
	while( data != delimeter )
    596a:	99 81       	ldd	r25, Y+1	; 0x01
    596c:	88 85       	ldd	r24, Y+8	; 0x08
    596e:	98 17       	cp	r25, r24
    5970:	e9 f6       	brne	.-70     	; 0x592c <Usart_ReceiveString_Del+0x2e>
		    buf[length]= USART_RxChar();
			data = buf[length];
			length++;

	}
	buf[length]='\0';  // LW BYTES MAFISH EL LINE DAH HATA3AML EL FUNCTION BEL LENGTH
    5972:	2a 81       	ldd	r18, Y+2	; 0x02
    5974:	3b 81       	ldd	r19, Y+3	; 0x03
    5976:	8e 81       	ldd	r24, Y+6	; 0x06
    5978:	9f 81       	ldd	r25, Y+7	; 0x07
    597a:	fc 01       	movw	r30, r24
    597c:	e2 0f       	add	r30, r18
    597e:	f3 1f       	adc	r31, r19
    5980:	10 82       	st	Z, r1
	return  length;
    5982:	8a 81       	ldd	r24, Y+2	; 0x02

}
    5984:	28 96       	adiw	r28, 0x08	; 8
    5986:	0f b6       	in	r0, 0x3f	; 63
    5988:	f8 94       	cli
    598a:	de bf       	out	0x3e, r29	; 62
    598c:	0f be       	out	0x3f, r0	; 63
    598e:	cd bf       	out	0x3d, r28	; 61
    5990:	cf 91       	pop	r28
    5992:	df 91       	pop	r29
    5994:	1f 91       	pop	r17
    5996:	0f 91       	pop	r16
    5998:	08 95       	ret

0000599a <main>:
void T2_SmartLock( void *pvParameters);

xSemaphoreHandle		bsRes ;
char STATUS=0;

int main(void) {
    599a:	af 92       	push	r10
    599c:	bf 92       	push	r11
    599e:	cf 92       	push	r12
    59a0:	df 92       	push	r13
    59a2:	ef 92       	push	r14
    59a4:	ff 92       	push	r15
    59a6:	0f 93       	push	r16
    59a8:	df 93       	push	r29
    59aa:	cf 93       	push	r28
    59ac:	cd b7       	in	r28, 0x3d	; 61
    59ae:	de b7       	in	r29, 0x3e	; 62
	while(!(PINC&(1<<HC_ConnectionStatePin)));
    59b0:	e3 e3       	ldi	r30, 0x33	; 51
    59b2:	f0 e0       	ldi	r31, 0x00	; 0
    59b4:	80 81       	ld	r24, Z
    59b6:	88 2f       	mov	r24, r24
    59b8:	90 e0       	ldi	r25, 0x00	; 0
    59ba:	81 70       	andi	r24, 0x01	; 1
    59bc:	90 70       	andi	r25, 0x00	; 0
    59be:	00 97       	sbiw	r24, 0x00	; 0
    59c0:	b9 f3       	breq	.-18     	; 0x59b0 <main+0x16>
	    SmartLock_Init();
    59c2:	0e 94 3b 21 	call	0x4276	; 0x4276 <SmartLock_Init>
        bsRes= xSemaphoreCreateBinary();
    59c6:	81 e0       	ldi	r24, 0x01	; 1
    59c8:	60 e0       	ldi	r22, 0x00	; 0
    59ca:	43 e0       	ldi	r20, 0x03	; 3
    59cc:	0e 94 83 12 	call	0x2506	; 0x2506 <xQueueGenericCreate>
    59d0:	90 93 fa 07 	sts	0x07FA, r25
    59d4:	80 93 f9 07 	sts	0x07F9, r24
        xTaskCreate(T2_SmartLock,NULL,100,NULL,2,NULL);
    59d8:	89 e4       	ldi	r24, 0x49	; 73
    59da:	9d e2       	ldi	r25, 0x2D	; 45
    59dc:	60 e0       	ldi	r22, 0x00	; 0
    59de:	70 e0       	ldi	r23, 0x00	; 0
    59e0:	44 e6       	ldi	r20, 0x64	; 100
    59e2:	50 e0       	ldi	r21, 0x00	; 0
    59e4:	20 e0       	ldi	r18, 0x00	; 0
    59e6:	30 e0       	ldi	r19, 0x00	; 0
    59e8:	02 e0       	ldi	r16, 0x02	; 2
    59ea:	ee 24       	eor	r14, r14
    59ec:	ff 24       	eor	r15, r15
    59ee:	cc 24       	eor	r12, r12
    59f0:	dd 24       	eor	r13, r13
    59f2:	aa 24       	eor	r10, r10
    59f4:	bb 24       	eor	r11, r11
    59f6:	0e 94 2c 19 	call	0x3258	; 0x3258 <xTaskGenericCreate>
		xTaskCreate(T1_Authentication,NULL,1000,NULL,1,NULL);
    59fa:	81 e1       	ldi	r24, 0x11	; 17
    59fc:	9d e2       	ldi	r25, 0x2D	; 45
    59fe:	60 e0       	ldi	r22, 0x00	; 0
    5a00:	70 e0       	ldi	r23, 0x00	; 0
    5a02:	48 ee       	ldi	r20, 0xE8	; 232
    5a04:	53 e0       	ldi	r21, 0x03	; 3
    5a06:	20 e0       	ldi	r18, 0x00	; 0
    5a08:	30 e0       	ldi	r19, 0x00	; 0
    5a0a:	01 e0       	ldi	r16, 0x01	; 1
    5a0c:	ee 24       	eor	r14, r14
    5a0e:	ff 24       	eor	r15, r15
    5a10:	cc 24       	eor	r12, r12
    5a12:	dd 24       	eor	r13, r13
    5a14:	aa 24       	eor	r10, r10
    5a16:	bb 24       	eor	r11, r11
    5a18:	0e 94 2c 19 	call	0x3258	; 0x3258 <xTaskGenericCreate>
		/* Start OS or Sched */
		vTaskStartScheduler();
    5a1c:	0e 94 1b 1b 	call	0x3636	; 0x3636 <vTaskStartScheduler>
    5a20:	ff cf       	rjmp	.-2      	; 0x5a20 <main+0x86>

00005a22 <T1_Authentication>:
		while(1);
}

void T1_Authentication( void *pvParameters)
{ char trails=0;
    5a22:	df 93       	push	r29
    5a24:	cf 93       	push	r28
    5a26:	00 d0       	rcall	.+0      	; 0x5a28 <T1_Authentication+0x6>
    5a28:	0f 92       	push	r0
    5a2a:	cd b7       	in	r28, 0x3d	; 61
    5a2c:	de b7       	in	r29, 0x3e	; 62
    5a2e:	9b 83       	std	Y+3, r25	; 0x03
    5a30:	8a 83       	std	Y+2, r24	; 0x02
    5a32:	19 82       	std	Y+1, r1	; 0x01
	while(1){
		while(!(PINC&(1<<HC_ConnectionStatePin)));
    5a34:	e3 e3       	ldi	r30, 0x33	; 51
    5a36:	f0 e0       	ldi	r31, 0x00	; 0
    5a38:	80 81       	ld	r24, Z
    5a3a:	88 2f       	mov	r24, r24
    5a3c:	90 e0       	ldi	r25, 0x00	; 0
    5a3e:	81 70       	andi	r24, 0x01	; 1
    5a40:	90 70       	andi	r25, 0x00	; 0
    5a42:	00 97       	sbiw	r24, 0x00	; 0
    5a44:	b9 f3       	breq	.-18     	; 0x5a34 <T1_Authentication+0x12>
		STATUS=CheckLogin();
    5a46:	0e 94 4a 22 	call	0x4494	; 0x4494 <CheckLogin>
    5a4a:	80 93 f8 07 	sts	0x07F8, r24
		if (STATUS==TRUE)
    5a4e:	80 91 f8 07 	lds	r24, 0x07F8
    5a52:	81 30       	cpi	r24, 0x01	; 1
    5a54:	61 f4       	brne	.+24     	; 0x5a6e <T1_Authentication+0x4c>
		{
          xSemaphoreGive(bsRes);
    5a56:	80 91 f9 07 	lds	r24, 0x07F9
    5a5a:	90 91 fa 07 	lds	r25, 0x07FA
    5a5e:	60 e0       	ldi	r22, 0x00	; 0
    5a60:	70 e0       	ldi	r23, 0x00	; 0
    5a62:	40 e0       	ldi	r20, 0x00	; 0
    5a64:	50 e0       	ldi	r21, 0x00	; 0
    5a66:	20 e0       	ldi	r18, 0x00	; 0
    5a68:	0e 94 00 13 	call	0x2600	; 0x2600 <xQueueGenericSend>
    5a6c:	0a c0       	rjmp	.+20     	; 0x5a82 <T1_Authentication+0x60>
		}
		else
		{   trails++;
    5a6e:	89 81       	ldd	r24, Y+1	; 0x01
    5a70:	8f 5f       	subi	r24, 0xFF	; 255
    5a72:	89 83       	std	Y+1, r24	; 0x01
		    USART_SendString("Please enter correct username and password\r");
    5a74:	89 e4       	ldi	r24, 0x49	; 73
    5a76:	91 e0       	ldi	r25, 0x01	; 1
    5a78:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <USART_SendString>
    5a7c:	02 c0       	rjmp	.+4      	; 0x5a82 <T1_Authentication+0x60>
		}
		while(trails>=3)
		{
			Alarm();
    5a7e:	0e 94 f0 29 	call	0x53e0	; 0x53e0 <Alarm>
		}
		else
		{   trails++;
		    USART_SendString("Please enter correct username and password\r");
		}
		while(trails>=3)
    5a82:	89 81       	ldd	r24, Y+1	; 0x01
    5a84:	83 30       	cpi	r24, 0x03	; 3
    5a86:	d8 f7       	brcc	.-10     	; 0x5a7e <T1_Authentication+0x5c>
		{
			Alarm();
		}
 		vTaskDelay(1000);
    5a88:	88 ee       	ldi	r24, 0xE8	; 232
    5a8a:	93 e0       	ldi	r25, 0x03	; 3
    5a8c:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <vTaskDelay>
    5a90:	d1 cf       	rjmp	.-94     	; 0x5a34 <T1_Authentication+0x12>

00005a92 <T2_SmartLock>:

	}}


//--------------------------------------------------
void T2_SmartLock(void* pvData){
    5a92:	df 93       	push	r29
    5a94:	cf 93       	push	r28
    5a96:	00 d0       	rcall	.+0      	; 0x5a98 <T2_SmartLock+0x6>
    5a98:	0f 92       	push	r0
    5a9a:	cd b7       	in	r28, 0x3d	; 61
    5a9c:	de b7       	in	r29, 0x3e	; 62
    5a9e:	9b 83       	std	Y+3, r25	; 0x03
    5aa0:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t result = pdFALSE;
    5aa2:	19 82       	std	Y+1, r1	; 0x01
	while(1){
		result = xSemaphoreTake(bsRes,1000);
    5aa4:	80 91 f9 07 	lds	r24, 0x07F9
    5aa8:	90 91 fa 07 	lds	r25, 0x07FA
    5aac:	60 e0       	ldi	r22, 0x00	; 0
    5aae:	70 e0       	ldi	r23, 0x00	; 0
    5ab0:	48 ee       	ldi	r20, 0xE8	; 232
    5ab2:	53 e0       	ldi	r21, 0x03	; 3
    5ab4:	20 e0       	ldi	r18, 0x00	; 0
    5ab6:	0e 94 0e 14 	call	0x281c	; 0x281c <xQueueGenericReceive>
    5aba:	89 83       	std	Y+1, r24	; 0x01
				if(result == pdTRUE){
    5abc:	89 81       	ldd	r24, Y+1	; 0x01
    5abe:	81 30       	cpi	r24, 0x01	; 1
    5ac0:	11 f4       	brne	.+4      	; 0x5ac6 <T2_SmartLock+0x34>
					SmartLock_Feature();
    5ac2:	0e 94 7d 2a 	call	0x54fa	; 0x54fa <SmartLock_Feature>
				}
     		vTaskDelay(1000);
    5ac6:	88 ee       	ldi	r24, 0xE8	; 232
    5ac8:	93 e0       	ldi	r25, 0x03	; 3
    5aca:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <vTaskDelay>
    5ace:	ea cf       	rjmp	.-44     	; 0x5aa4 <T2_SmartLock+0x12>

00005ad0 <Uart_Init>:
 *  Author: MahmoudH
 */ 
#include "uart.h"

/* Init. uart */
void Uart_Init(unsigned long baudRate){
    5ad0:	df 93       	push	r29
    5ad2:	cf 93       	push	r28
    5ad4:	00 d0       	rcall	.+0      	; 0x5ad6 <Uart_Init+0x6>
    5ad6:	00 d0       	rcall	.+0      	; 0x5ad8 <Uart_Init+0x8>
    5ad8:	00 d0       	rcall	.+0      	; 0x5ada <Uart_Init+0xa>
    5ada:	cd b7       	in	r28, 0x3d	; 61
    5adc:	de b7       	in	r29, 0x3e	; 62
    5ade:	6b 83       	std	Y+3, r22	; 0x03
    5ae0:	7c 83       	std	Y+4, r23	; 0x04
    5ae2:	8d 83       	std	Y+5, r24	; 0x05
    5ae4:	9e 83       	std	Y+6, r25	; 0x06
	unsigned short baud = 0;
    5ae6:	1a 82       	std	Y+2, r1	; 0x02
    5ae8:	19 82       	std	Y+1, r1	; 0x01
	baud = ((F_CPU)/(16*baudRate)) - 1;
    5aea:	8b 81       	ldd	r24, Y+3	; 0x03
    5aec:	9c 81       	ldd	r25, Y+4	; 0x04
    5aee:	ad 81       	ldd	r26, Y+5	; 0x05
    5af0:	be 81       	ldd	r27, Y+6	; 0x06
    5af2:	88 0f       	add	r24, r24
    5af4:	99 1f       	adc	r25, r25
    5af6:	aa 1f       	adc	r26, r26
    5af8:	bb 1f       	adc	r27, r27
    5afa:	88 0f       	add	r24, r24
    5afc:	99 1f       	adc	r25, r25
    5afe:	aa 1f       	adc	r26, r26
    5b00:	bb 1f       	adc	r27, r27
    5b02:	88 0f       	add	r24, r24
    5b04:	99 1f       	adc	r25, r25
    5b06:	aa 1f       	adc	r26, r26
    5b08:	bb 1f       	adc	r27, r27
    5b0a:	88 0f       	add	r24, r24
    5b0c:	99 1f       	adc	r25, r25
    5b0e:	aa 1f       	adc	r26, r26
    5b10:	bb 1f       	adc	r27, r27
    5b12:	9c 01       	movw	r18, r24
    5b14:	ad 01       	movw	r20, r26
    5b16:	80 e0       	ldi	r24, 0x00	; 0
    5b18:	92 e1       	ldi	r25, 0x12	; 18
    5b1a:	aa e7       	ldi	r26, 0x7A	; 122
    5b1c:	b0 e0       	ldi	r27, 0x00	; 0
    5b1e:	bc 01       	movw	r22, r24
    5b20:	cd 01       	movw	r24, r26
    5b22:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <__udivmodsi4>
    5b26:	da 01       	movw	r26, r20
    5b28:	c9 01       	movw	r24, r18
    5b2a:	01 97       	sbiw	r24, 0x01	; 1
    5b2c:	9a 83       	std	Y+2, r25	; 0x02
    5b2e:	89 83       	std	Y+1, r24	; 0x01
	/* Set baud rate */
//	baud = 51;
	UBRRH = (unsigned char)(baud>>8);
    5b30:	e0 e4       	ldi	r30, 0x40	; 64
    5b32:	f0 e0       	ldi	r31, 0x00	; 0
    5b34:	89 81       	ldd	r24, Y+1	; 0x01
    5b36:	9a 81       	ldd	r25, Y+2	; 0x02
    5b38:	89 2f       	mov	r24, r25
    5b3a:	99 27       	eor	r25, r25
    5b3c:	80 83       	st	Z, r24
	UBRRL = (unsigned char)baud;
    5b3e:	e9 e2       	ldi	r30, 0x29	; 41
    5b40:	f0 e0       	ldi	r31, 0x00	; 0
    5b42:	89 81       	ldd	r24, Y+1	; 0x01
    5b44:	80 83       	st	Z, r24
	/* Enable receiver and transmitter */
	UCSRB = (1<<RXEN)|(1<<TXEN);
    5b46:	ea e2       	ldi	r30, 0x2A	; 42
    5b48:	f0 e0       	ldi	r31, 0x00	; 0
    5b4a:	88 e1       	ldi	r24, 0x18	; 24
    5b4c:	80 83       	st	Z, r24
	/* Set frame format: 8data, 1stop bit */
	UCSRC = (1<<URSEL)|(3<<UCSZ0);
    5b4e:	e0 e4       	ldi	r30, 0x40	; 64
    5b50:	f0 e0       	ldi	r31, 0x00	; 0
    5b52:	86 e8       	ldi	r24, 0x86	; 134
    5b54:	80 83       	st	Z, r24
}
    5b56:	26 96       	adiw	r28, 0x06	; 6
    5b58:	0f b6       	in	r0, 0x3f	; 63
    5b5a:	f8 94       	cli
    5b5c:	de bf       	out	0x3e, r29	; 62
    5b5e:	0f be       	out	0x3f, r0	; 63
    5b60:	cd bf       	out	0x3d, r28	; 61
    5b62:	cf 91       	pop	r28
    5b64:	df 91       	pop	r29
    5b66:	08 95       	ret

00005b68 <Uart_SendByte>:
/* Send one Byte */
void Uart_SendByte(unsigned char data){
    5b68:	df 93       	push	r29
    5b6a:	cf 93       	push	r28
    5b6c:	0f 92       	push	r0
    5b6e:	cd b7       	in	r28, 0x3d	; 61
    5b70:	de b7       	in	r29, 0x3e	; 62
    5b72:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)) );
    5b74:	eb e2       	ldi	r30, 0x2B	; 43
    5b76:	f0 e0       	ldi	r31, 0x00	; 0
    5b78:	80 81       	ld	r24, Z
    5b7a:	88 2f       	mov	r24, r24
    5b7c:	90 e0       	ldi	r25, 0x00	; 0
    5b7e:	80 72       	andi	r24, 0x20	; 32
    5b80:	90 70       	andi	r25, 0x00	; 0
    5b82:	00 97       	sbiw	r24, 0x00	; 0
    5b84:	b9 f3       	breq	.-18     	; 0x5b74 <Uart_SendByte+0xc>
	/* Put data into buffer, sends the data */
	UDR = data;
    5b86:	ec e2       	ldi	r30, 0x2C	; 44
    5b88:	f0 e0       	ldi	r31, 0x00	; 0
    5b8a:	89 81       	ldd	r24, Y+1	; 0x01
    5b8c:	80 83       	st	Z, r24
}
    5b8e:	0f 90       	pop	r0
    5b90:	cf 91       	pop	r28
    5b92:	df 91       	pop	r29
    5b94:	08 95       	ret

00005b96 <Uart_SendString>:
/* Send String (number of bytes) */
void Uart_SendString(unsigned char* str){
    5b96:	df 93       	push	r29
    5b98:	cf 93       	push	r28
    5b9a:	00 d0       	rcall	.+0      	; 0x5b9c <Uart_SendString+0x6>
    5b9c:	00 d0       	rcall	.+0      	; 0x5b9e <Uart_SendString+0x8>
    5b9e:	00 d0       	rcall	.+0      	; 0x5ba0 <Uart_SendString+0xa>
    5ba0:	cd b7       	in	r28, 0x3d	; 61
    5ba2:	de b7       	in	r29, 0x3e	; 62
    5ba4:	9e 83       	std	Y+6, r25	; 0x06
    5ba6:	8d 83       	std	Y+5, r24	; 0x05
	unsigned long ind = 0;
    5ba8:	19 82       	std	Y+1, r1	; 0x01
    5baa:	1a 82       	std	Y+2, r1	; 0x02
    5bac:	1b 82       	std	Y+3, r1	; 0x03
    5bae:	1c 82       	std	Y+4, r1	; 0x04
    5bb0:	15 c0       	rjmp	.+42     	; 0x5bdc <Uart_SendString+0x46>
	while(str[ind] != 0){
		Uart_SendByte(str[ind]);
    5bb2:	29 81       	ldd	r18, Y+1	; 0x01
    5bb4:	3a 81       	ldd	r19, Y+2	; 0x02
    5bb6:	8d 81       	ldd	r24, Y+5	; 0x05
    5bb8:	9e 81       	ldd	r25, Y+6	; 0x06
    5bba:	fc 01       	movw	r30, r24
    5bbc:	e2 0f       	add	r30, r18
    5bbe:	f3 1f       	adc	r31, r19
    5bc0:	80 81       	ld	r24, Z
    5bc2:	0e 94 b4 2d 	call	0x5b68	; 0x5b68 <Uart_SendByte>
		ind++;
    5bc6:	89 81       	ldd	r24, Y+1	; 0x01
    5bc8:	9a 81       	ldd	r25, Y+2	; 0x02
    5bca:	ab 81       	ldd	r26, Y+3	; 0x03
    5bcc:	bc 81       	ldd	r27, Y+4	; 0x04
    5bce:	01 96       	adiw	r24, 0x01	; 1
    5bd0:	a1 1d       	adc	r26, r1
    5bd2:	b1 1d       	adc	r27, r1
    5bd4:	89 83       	std	Y+1, r24	; 0x01
    5bd6:	9a 83       	std	Y+2, r25	; 0x02
    5bd8:	ab 83       	std	Y+3, r26	; 0x03
    5bda:	bc 83       	std	Y+4, r27	; 0x04
	UDR = data;
}
/* Send String (number of bytes) */
void Uart_SendString(unsigned char* str){
	unsigned long ind = 0;
	while(str[ind] != 0){
    5bdc:	29 81       	ldd	r18, Y+1	; 0x01
    5bde:	3a 81       	ldd	r19, Y+2	; 0x02
    5be0:	8d 81       	ldd	r24, Y+5	; 0x05
    5be2:	9e 81       	ldd	r25, Y+6	; 0x06
    5be4:	fc 01       	movw	r30, r24
    5be6:	e2 0f       	add	r30, r18
    5be8:	f3 1f       	adc	r31, r19
    5bea:	80 81       	ld	r24, Z
    5bec:	88 23       	and	r24, r24
    5bee:	09 f7       	brne	.-62     	; 0x5bb2 <Uart_SendString+0x1c>
		Uart_SendByte(str[ind]);
		ind++;
	}
}
    5bf0:	26 96       	adiw	r28, 0x06	; 6
    5bf2:	0f b6       	in	r0, 0x3f	; 63
    5bf4:	f8 94       	cli
    5bf6:	de bf       	out	0x3e, r29	; 62
    5bf8:	0f be       	out	0x3f, r0	; 63
    5bfa:	cd bf       	out	0x3d, r28	; 61
    5bfc:	cf 91       	pop	r28
    5bfe:	df 91       	pop	r29
    5c00:	08 95       	ret

00005c02 <Uart_ReceiveByte>:
/* Receive one Byte (Syncro. Function)*/
unsigned char Uart_ReceiveByte(void){
    5c02:	df 93       	push	r29
    5c04:	cf 93       	push	r28
    5c06:	cd b7       	in	r28, 0x3d	; 61
    5c08:	de b7       	in	r29, 0x3e	; 62
	/* Wait for data to be received */
	while ( !(UCSRA & (1<<RXC)) ); /* Blocking Condition */
    5c0a:	eb e2       	ldi	r30, 0x2B	; 43
    5c0c:	f0 e0       	ldi	r31, 0x00	; 0
    5c0e:	80 81       	ld	r24, Z
    5c10:	88 23       	and	r24, r24
    5c12:	dc f7       	brge	.-10     	; 0x5c0a <Uart_ReceiveByte+0x8>
	/* Get and return received data from buffer */
	return UDR;
    5c14:	ec e2       	ldi	r30, 0x2C	; 44
    5c16:	f0 e0       	ldi	r31, 0x00	; 0
    5c18:	80 81       	ld	r24, Z
}
    5c1a:	cf 91       	pop	r28
    5c1c:	df 91       	pop	r29
    5c1e:	08 95       	ret

00005c20 <Uart_ReceiveByte_Unblock>:
/* Receive one Byte (Unblock) */
unsigned char Uart_ReceiveByte_Unblock(unsigned char* dataPtr){
    5c20:	df 93       	push	r29
    5c22:	cf 93       	push	r28
    5c24:	00 d0       	rcall	.+0      	; 0x5c26 <Uart_ReceiveByte_Unblock+0x6>
    5c26:	0f 92       	push	r0
    5c28:	cd b7       	in	r28, 0x3d	; 61
    5c2a:	de b7       	in	r29, 0x3e	; 62
    5c2c:	9b 83       	std	Y+3, r25	; 0x03
    5c2e:	8a 83       	std	Y+2, r24	; 0x02
	unsigned char status = 0;
    5c30:	19 82       	std	Y+1, r1	; 0x01
	if (UCSRA & (1<<RXC)){
    5c32:	eb e2       	ldi	r30, 0x2B	; 43
    5c34:	f0 e0       	ldi	r31, 0x00	; 0
    5c36:	80 81       	ld	r24, Z
    5c38:	88 23       	and	r24, r24
    5c3a:	4c f4       	brge	.+18     	; 0x5c4e <Uart_ReceiveByte_Unblock+0x2e>
		// upload it
		(*dataPtr) = UDR;
    5c3c:	ec e2       	ldi	r30, 0x2C	; 44
    5c3e:	f0 e0       	ldi	r31, 0x00	; 0
    5c40:	80 81       	ld	r24, Z
    5c42:	ea 81       	ldd	r30, Y+2	; 0x02
    5c44:	fb 81       	ldd	r31, Y+3	; 0x03
    5c46:	80 83       	st	Z, r24
		// update status flag
		status = 1;
    5c48:	81 e0       	ldi	r24, 0x01	; 1
    5c4a:	89 83       	std	Y+1, r24	; 0x01
    5c4c:	01 c0       	rjmp	.+2      	; 0x5c50 <Uart_ReceiveByte_Unblock+0x30>
	}
	else{
		status = 0;
    5c4e:	19 82       	std	Y+1, r1	; 0x01
	}
	return status;
    5c50:	89 81       	ldd	r24, Y+1	; 0x01
    5c52:	0f 90       	pop	r0
    5c54:	0f 90       	pop	r0
    5c56:	0f 90       	pop	r0
    5c58:	cf 91       	pop	r28
    5c5a:	df 91       	pop	r29
    5c5c:	08 95       	ret

00005c5e <__mulsi3>:
    5c5e:	62 9f       	mul	r22, r18
    5c60:	d0 01       	movw	r26, r0
    5c62:	73 9f       	mul	r23, r19
    5c64:	f0 01       	movw	r30, r0
    5c66:	82 9f       	mul	r24, r18
    5c68:	e0 0d       	add	r30, r0
    5c6a:	f1 1d       	adc	r31, r1
    5c6c:	64 9f       	mul	r22, r20
    5c6e:	e0 0d       	add	r30, r0
    5c70:	f1 1d       	adc	r31, r1
    5c72:	92 9f       	mul	r25, r18
    5c74:	f0 0d       	add	r31, r0
    5c76:	83 9f       	mul	r24, r19
    5c78:	f0 0d       	add	r31, r0
    5c7a:	74 9f       	mul	r23, r20
    5c7c:	f0 0d       	add	r31, r0
    5c7e:	65 9f       	mul	r22, r21
    5c80:	f0 0d       	add	r31, r0
    5c82:	99 27       	eor	r25, r25
    5c84:	72 9f       	mul	r23, r18
    5c86:	b0 0d       	add	r27, r0
    5c88:	e1 1d       	adc	r30, r1
    5c8a:	f9 1f       	adc	r31, r25
    5c8c:	63 9f       	mul	r22, r19
    5c8e:	b0 0d       	add	r27, r0
    5c90:	e1 1d       	adc	r30, r1
    5c92:	f9 1f       	adc	r31, r25
    5c94:	bd 01       	movw	r22, r26
    5c96:	cf 01       	movw	r24, r30
    5c98:	11 24       	eor	r1, r1
    5c9a:	08 95       	ret

00005c9c <__udivmodsi4>:
    5c9c:	a1 e2       	ldi	r26, 0x21	; 33
    5c9e:	1a 2e       	mov	r1, r26
    5ca0:	aa 1b       	sub	r26, r26
    5ca2:	bb 1b       	sub	r27, r27
    5ca4:	fd 01       	movw	r30, r26
    5ca6:	0d c0       	rjmp	.+26     	; 0x5cc2 <__udivmodsi4_ep>

00005ca8 <__udivmodsi4_loop>:
    5ca8:	aa 1f       	adc	r26, r26
    5caa:	bb 1f       	adc	r27, r27
    5cac:	ee 1f       	adc	r30, r30
    5cae:	ff 1f       	adc	r31, r31
    5cb0:	a2 17       	cp	r26, r18
    5cb2:	b3 07       	cpc	r27, r19
    5cb4:	e4 07       	cpc	r30, r20
    5cb6:	f5 07       	cpc	r31, r21
    5cb8:	20 f0       	brcs	.+8      	; 0x5cc2 <__udivmodsi4_ep>
    5cba:	a2 1b       	sub	r26, r18
    5cbc:	b3 0b       	sbc	r27, r19
    5cbe:	e4 0b       	sbc	r30, r20
    5cc0:	f5 0b       	sbc	r31, r21

00005cc2 <__udivmodsi4_ep>:
    5cc2:	66 1f       	adc	r22, r22
    5cc4:	77 1f       	adc	r23, r23
    5cc6:	88 1f       	adc	r24, r24
    5cc8:	99 1f       	adc	r25, r25
    5cca:	1a 94       	dec	r1
    5ccc:	69 f7       	brne	.-38     	; 0x5ca8 <__udivmodsi4_loop>
    5cce:	60 95       	com	r22
    5cd0:	70 95       	com	r23
    5cd2:	80 95       	com	r24
    5cd4:	90 95       	com	r25
    5cd6:	9b 01       	movw	r18, r22
    5cd8:	ac 01       	movw	r20, r24
    5cda:	bd 01       	movw	r22, r26
    5cdc:	cf 01       	movw	r24, r30
    5cde:	08 95       	ret

00005ce0 <__divmodsi4>:
    5ce0:	97 fb       	bst	r25, 7
    5ce2:	09 2e       	mov	r0, r25
    5ce4:	05 26       	eor	r0, r21
    5ce6:	0e d0       	rcall	.+28     	; 0x5d04 <__divmodsi4_neg1>
    5ce8:	57 fd       	sbrc	r21, 7
    5cea:	04 d0       	rcall	.+8      	; 0x5cf4 <__divmodsi4_neg2>
    5cec:	d7 df       	rcall	.-82     	; 0x5c9c <__udivmodsi4>
    5cee:	0a d0       	rcall	.+20     	; 0x5d04 <__divmodsi4_neg1>
    5cf0:	00 1c       	adc	r0, r0
    5cf2:	38 f4       	brcc	.+14     	; 0x5d02 <__divmodsi4_exit>

00005cf4 <__divmodsi4_neg2>:
    5cf4:	50 95       	com	r21
    5cf6:	40 95       	com	r20
    5cf8:	30 95       	com	r19
    5cfa:	21 95       	neg	r18
    5cfc:	3f 4f       	sbci	r19, 0xFF	; 255
    5cfe:	4f 4f       	sbci	r20, 0xFF	; 255
    5d00:	5f 4f       	sbci	r21, 0xFF	; 255

00005d02 <__divmodsi4_exit>:
    5d02:	08 95       	ret

00005d04 <__divmodsi4_neg1>:
    5d04:	f6 f7       	brtc	.-4      	; 0x5d02 <__divmodsi4_exit>
    5d06:	90 95       	com	r25
    5d08:	80 95       	com	r24
    5d0a:	70 95       	com	r23
    5d0c:	61 95       	neg	r22
    5d0e:	7f 4f       	sbci	r23, 0xFF	; 255
    5d10:	8f 4f       	sbci	r24, 0xFF	; 255
    5d12:	9f 4f       	sbci	r25, 0xFF	; 255
    5d14:	08 95       	ret

00005d16 <__prologue_saves__>:
    5d16:	2f 92       	push	r2
    5d18:	3f 92       	push	r3
    5d1a:	4f 92       	push	r4
    5d1c:	5f 92       	push	r5
    5d1e:	6f 92       	push	r6
    5d20:	7f 92       	push	r7
    5d22:	8f 92       	push	r8
    5d24:	9f 92       	push	r9
    5d26:	af 92       	push	r10
    5d28:	bf 92       	push	r11
    5d2a:	cf 92       	push	r12
    5d2c:	df 92       	push	r13
    5d2e:	ef 92       	push	r14
    5d30:	ff 92       	push	r15
    5d32:	0f 93       	push	r16
    5d34:	1f 93       	push	r17
    5d36:	cf 93       	push	r28
    5d38:	df 93       	push	r29
    5d3a:	cd b7       	in	r28, 0x3d	; 61
    5d3c:	de b7       	in	r29, 0x3e	; 62
    5d3e:	ca 1b       	sub	r28, r26
    5d40:	db 0b       	sbc	r29, r27
    5d42:	0f b6       	in	r0, 0x3f	; 63
    5d44:	f8 94       	cli
    5d46:	de bf       	out	0x3e, r29	; 62
    5d48:	0f be       	out	0x3f, r0	; 63
    5d4a:	cd bf       	out	0x3d, r28	; 61
    5d4c:	09 94       	ijmp

00005d4e <__epilogue_restores__>:
    5d4e:	2a 88       	ldd	r2, Y+18	; 0x12
    5d50:	39 88       	ldd	r3, Y+17	; 0x11
    5d52:	48 88       	ldd	r4, Y+16	; 0x10
    5d54:	5f 84       	ldd	r5, Y+15	; 0x0f
    5d56:	6e 84       	ldd	r6, Y+14	; 0x0e
    5d58:	7d 84       	ldd	r7, Y+13	; 0x0d
    5d5a:	8c 84       	ldd	r8, Y+12	; 0x0c
    5d5c:	9b 84       	ldd	r9, Y+11	; 0x0b
    5d5e:	aa 84       	ldd	r10, Y+10	; 0x0a
    5d60:	b9 84       	ldd	r11, Y+9	; 0x09
    5d62:	c8 84       	ldd	r12, Y+8	; 0x08
    5d64:	df 80       	ldd	r13, Y+7	; 0x07
    5d66:	ee 80       	ldd	r14, Y+6	; 0x06
    5d68:	fd 80       	ldd	r15, Y+5	; 0x05
    5d6a:	0c 81       	ldd	r16, Y+4	; 0x04
    5d6c:	1b 81       	ldd	r17, Y+3	; 0x03
    5d6e:	aa 81       	ldd	r26, Y+2	; 0x02
    5d70:	b9 81       	ldd	r27, Y+1	; 0x01
    5d72:	ce 0f       	add	r28, r30
    5d74:	d1 1d       	adc	r29, r1
    5d76:	0f b6       	in	r0, 0x3f	; 63
    5d78:	f8 94       	cli
    5d7a:	de bf       	out	0x3e, r29	; 62
    5d7c:	0f be       	out	0x3f, r0	; 63
    5d7e:	cd bf       	out	0x3d, r28	; 61
    5d80:	ed 01       	movw	r28, r26
    5d82:	08 95       	ret

00005d84 <memcpy>:
    5d84:	fb 01       	movw	r30, r22
    5d86:	dc 01       	movw	r26, r24
    5d88:	02 c0       	rjmp	.+4      	; 0x5d8e <memcpy+0xa>
    5d8a:	01 90       	ld	r0, Z+
    5d8c:	0d 92       	st	X+, r0
    5d8e:	41 50       	subi	r20, 0x01	; 1
    5d90:	50 40       	sbci	r21, 0x00	; 0
    5d92:	d8 f7       	brcc	.-10     	; 0x5d8a <memcpy+0x6>
    5d94:	08 95       	ret

00005d96 <strcmp>:
    5d96:	fb 01       	movw	r30, r22
    5d98:	dc 01       	movw	r26, r24
    5d9a:	8d 91       	ld	r24, X+
    5d9c:	01 90       	ld	r0, Z+
    5d9e:	80 19       	sub	r24, r0
    5da0:	01 10       	cpse	r0, r1
    5da2:	d9 f3       	breq	.-10     	; 0x5d9a <strcmp+0x4>
    5da4:	99 0b       	sbc	r25, r25
    5da6:	08 95       	ret

00005da8 <_exit>:
    5da8:	f8 94       	cli

00005daa <__stop_program>:
    5daa:	ff cf       	rjmp	.-2      	; 0x5daa <__stop_program>
