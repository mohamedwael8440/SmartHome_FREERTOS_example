
SmartLock_RTOS_IMT.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005dbc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000011e  00800060  00005dbc  00005e50  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000067b  0080017e  0080017e  00005f6e  2**0
                  ALLOC
  3 .stab         000072d8  00000000  00000000  00005f70  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003990  00000000  00000000  0000d248  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00010bd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00010d18  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00010e88  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00012ad1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  000139bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  0001476c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  000148cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00014b59  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00015327  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 5b 1e 	jmp	0x3cb6	; 0x3cb6 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec eb       	ldi	r30, 0xBC	; 188
      68:	fd e5       	ldi	r31, 0x5D	; 93
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ae 37       	cpi	r26, 0x7E	; 126
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	ae e7       	ldi	r26, 0x7E	; 126
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a9 3f       	cpi	r26, 0xF9	; 249
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 9c 2d 	call	0x5b38	; 0x5b38 <main>
      8a:	0c 94 dc 2e 	jmp	0x5db8	; 0x5db8 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 93 2e 	jmp	0x5d26	; 0x5d26 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a4 e7       	ldi	r26, 0x74	; 116
     128:	b1 e0       	ldi	r27, 0x01	; 1
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 af 2e 	jmp	0x5d5e	; 0x5d5e <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 9f 2e 	jmp	0x5d3e	; 0x5d3e <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 bb 2e 	jmp	0x5d76	; 0x5d76 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 9f 2e 	jmp	0x5d3e	; 0x5d3e <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 bb 2e 	jmp	0x5d76	; 0x5d76 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 93 2e 	jmp	0x5d26	; 0x5d26 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	84 e7       	ldi	r24, 0x74	; 116
     496:	91 e0       	ldi	r25, 0x01	; 1
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 af 2e 	jmp	0x5d5e	; 0x5d5e <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 9f 2e 	jmp	0x5d3e	; 0x5d3e <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 bb 2e 	jmp	0x5d76	; 0x5d76 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 9f 2e 	jmp	0x5d3e	; 0x5d3e <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 bb 2e 	jmp	0x5d76	; 0x5d76 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 9f 2e 	jmp	0x5d3e	; 0x5d3e <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 bb 2e 	jmp	0x5d76	; 0x5d76 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 a3 2e 	jmp	0x5d46	; 0x5d46 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 bf 2e 	jmp	0x5d7e	; 0x5d7e <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <USART_Init>:
 */ 

#include "USART_RS232_H_file.h"						/* Include USART header file */

void USART_Init(unsigned long BAUDRATE)				/* USART initialize function */
{ 
     b46:	0f 93       	push	r16
     b48:	1f 93       	push	r17
     b4a:	df 93       	push	r29
     b4c:	cf 93       	push	r28
     b4e:	00 d0       	rcall	.+0      	; 0xb50 <USART_Init+0xa>
     b50:	00 d0       	rcall	.+0      	; 0xb52 <USART_Init+0xc>
     b52:	cd b7       	in	r28, 0x3d	; 61
     b54:	de b7       	in	r29, 0x3e	; 62
     b56:	69 83       	std	Y+1, r22	; 0x01
     b58:	7a 83       	std	Y+2, r23	; 0x02
     b5a:	8b 83       	std	Y+3, r24	; 0x03
     b5c:	9c 83       	std	Y+4, r25	; 0x04
	UCSRB |= (1 << RXEN) | (1 << TXEN);				/* Enable USART transmitter and receiver */
     b5e:	aa e2       	ldi	r26, 0x2A	; 42
     b60:	b0 e0       	ldi	r27, 0x00	; 0
     b62:	ea e2       	ldi	r30, 0x2A	; 42
     b64:	f0 e0       	ldi	r31, 0x00	; 0
     b66:	80 81       	ld	r24, Z
     b68:	88 61       	ori	r24, 0x18	; 24
     b6a:	8c 93       	st	X, r24
	UCSRC |= (1 << URSEL)| (1 << UCSZ0) | (1 << UCSZ1);	/* Write USCRC for 8 bit data and 1 stop bit */ 
     b6c:	a0 e4       	ldi	r26, 0x40	; 64
     b6e:	b0 e0       	ldi	r27, 0x00	; 0
     b70:	e0 e4       	ldi	r30, 0x40	; 64
     b72:	f0 e0       	ldi	r31, 0x00	; 0
     b74:	80 81       	ld	r24, Z
     b76:	86 68       	ori	r24, 0x86	; 134
     b78:	8c 93       	st	X, r24
	UBRRL = BAUD_PRESCALE;							/* Load UBRRL with lower 8 bit of prescale value */
     b7a:	09 e2       	ldi	r16, 0x29	; 41
     b7c:	10 e0       	ldi	r17, 0x00	; 0
     b7e:	89 81       	ldd	r24, Y+1	; 0x01
     b80:	9a 81       	ldd	r25, Y+2	; 0x02
     b82:	ab 81       	ldd	r26, Y+3	; 0x03
     b84:	bc 81       	ldd	r27, Y+4	; 0x04
     b86:	88 0f       	add	r24, r24
     b88:	99 1f       	adc	r25, r25
     b8a:	aa 1f       	adc	r26, r26
     b8c:	bb 1f       	adc	r27, r27
     b8e:	88 0f       	add	r24, r24
     b90:	99 1f       	adc	r25, r25
     b92:	aa 1f       	adc	r26, r26
     b94:	bb 1f       	adc	r27, r27
     b96:	88 0f       	add	r24, r24
     b98:	99 1f       	adc	r25, r25
     b9a:	aa 1f       	adc	r26, r26
     b9c:	bb 1f       	adc	r27, r27
     b9e:	88 0f       	add	r24, r24
     ba0:	99 1f       	adc	r25, r25
     ba2:	aa 1f       	adc	r26, r26
     ba4:	bb 1f       	adc	r27, r27
     ba6:	9c 01       	movw	r18, r24
     ba8:	ad 01       	movw	r20, r26
     baa:	80 e0       	ldi	r24, 0x00	; 0
     bac:	92 e1       	ldi	r25, 0x12	; 18
     bae:	aa e7       	ldi	r26, 0x7A	; 122
     bb0:	b0 e0       	ldi	r27, 0x00	; 0
     bb2:	bc 01       	movw	r22, r24
     bb4:	cd 01       	movw	r24, r26
     bb6:	0e 94 56 2e 	call	0x5cac	; 0x5cac <__udivmodsi4>
     bba:	da 01       	movw	r26, r20
     bbc:	c9 01       	movw	r24, r18
     bbe:	81 50       	subi	r24, 0x01	; 1
     bc0:	f8 01       	movw	r30, r16
     bc2:	80 83       	st	Z, r24
	UBRRH = (BAUD_PRESCALE >> 8);					/* Load UBRRH with upper 8 bit of prescale value */
     bc4:	00 e4       	ldi	r16, 0x40	; 64
     bc6:	10 e0       	ldi	r17, 0x00	; 0
     bc8:	89 81       	ldd	r24, Y+1	; 0x01
     bca:	9a 81       	ldd	r25, Y+2	; 0x02
     bcc:	ab 81       	ldd	r26, Y+3	; 0x03
     bce:	bc 81       	ldd	r27, Y+4	; 0x04
     bd0:	88 0f       	add	r24, r24
     bd2:	99 1f       	adc	r25, r25
     bd4:	aa 1f       	adc	r26, r26
     bd6:	bb 1f       	adc	r27, r27
     bd8:	88 0f       	add	r24, r24
     bda:	99 1f       	adc	r25, r25
     bdc:	aa 1f       	adc	r26, r26
     bde:	bb 1f       	adc	r27, r27
     be0:	88 0f       	add	r24, r24
     be2:	99 1f       	adc	r25, r25
     be4:	aa 1f       	adc	r26, r26
     be6:	bb 1f       	adc	r27, r27
     be8:	88 0f       	add	r24, r24
     bea:	99 1f       	adc	r25, r25
     bec:	aa 1f       	adc	r26, r26
     bee:	bb 1f       	adc	r27, r27
     bf0:	9c 01       	movw	r18, r24
     bf2:	ad 01       	movw	r20, r26
     bf4:	80 e0       	ldi	r24, 0x00	; 0
     bf6:	92 e1       	ldi	r25, 0x12	; 18
     bf8:	aa e7       	ldi	r26, 0x7A	; 122
     bfa:	b0 e0       	ldi	r27, 0x00	; 0
     bfc:	bc 01       	movw	r22, r24
     bfe:	cd 01       	movw	r24, r26
     c00:	0e 94 56 2e 	call	0x5cac	; 0x5cac <__udivmodsi4>
     c04:	da 01       	movw	r26, r20
     c06:	c9 01       	movw	r24, r18
     c08:	01 97       	sbiw	r24, 0x01	; 1
     c0a:	a1 09       	sbc	r26, r1
     c0c:	b1 09       	sbc	r27, r1
     c0e:	89 2f       	mov	r24, r25
     c10:	9a 2f       	mov	r25, r26
     c12:	ab 2f       	mov	r26, r27
     c14:	bb 27       	eor	r27, r27
     c16:	f8 01       	movw	r30, r16
     c18:	80 83       	st	Z, r24
}
     c1a:	0f 90       	pop	r0
     c1c:	0f 90       	pop	r0
     c1e:	0f 90       	pop	r0
     c20:	0f 90       	pop	r0
     c22:	cf 91       	pop	r28
     c24:	df 91       	pop	r29
     c26:	1f 91       	pop	r17
     c28:	0f 91       	pop	r16
     c2a:	08 95       	ret

00000c2c <USART_RxChar>:

char USART_RxChar()									/* Data receiving function */
{
     c2c:	df 93       	push	r29
     c2e:	cf 93       	push	r28
     c30:	cd b7       	in	r28, 0x3d	; 61
     c32:	de b7       	in	r29, 0x3e	; 62
	while (!(UCSRA & (1 << RXC)));					/* Wait until new data receive */
     c34:	eb e2       	ldi	r30, 0x2B	; 43
     c36:	f0 e0       	ldi	r31, 0x00	; 0
     c38:	80 81       	ld	r24, Z
     c3a:	88 23       	and	r24, r24
     c3c:	dc f7       	brge	.-10     	; 0xc34 <USART_RxChar+0x8>
	return(UDR);									/* Get and return received data */ 
     c3e:	ec e2       	ldi	r30, 0x2C	; 44
     c40:	f0 e0       	ldi	r31, 0x00	; 0
     c42:	80 81       	ld	r24, Z
}
     c44:	cf 91       	pop	r28
     c46:	df 91       	pop	r29
     c48:	08 95       	ret

00000c4a <USART_TxChar>:

void USART_TxChar(char data)						/* Data transmitting function */
{
     c4a:	df 93       	push	r29
     c4c:	cf 93       	push	r28
     c4e:	0f 92       	push	r0
     c50:	cd b7       	in	r28, 0x3d	; 61
     c52:	de b7       	in	r29, 0x3e	; 62
     c54:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSRA & (1<<UDRE)));					/* Wait until data transmit and buffer get empty */
     c56:	eb e2       	ldi	r30, 0x2B	; 43
     c58:	f0 e0       	ldi	r31, 0x00	; 0
     c5a:	80 81       	ld	r24, Z
     c5c:	88 2f       	mov	r24, r24
     c5e:	90 e0       	ldi	r25, 0x00	; 0
     c60:	80 72       	andi	r24, 0x20	; 32
     c62:	90 70       	andi	r25, 0x00	; 0
     c64:	00 97       	sbiw	r24, 0x00	; 0
     c66:	b9 f3       	breq	.-18     	; 0xc56 <USART_TxChar+0xc>
	UDR = data;										/* Write data to be transmitting in UDR */
     c68:	ec e2       	ldi	r30, 0x2C	; 44
     c6a:	f0 e0       	ldi	r31, 0x00	; 0
     c6c:	89 81       	ldd	r24, Y+1	; 0x01
     c6e:	80 83       	st	Z, r24

}
     c70:	0f 90       	pop	r0
     c72:	cf 91       	pop	r28
     c74:	df 91       	pop	r29
     c76:	08 95       	ret

00000c78 <USART_Flush>:
void USART_Flush( void )
{
     c78:	df 93       	push	r29
     c7a:	cf 93       	push	r28
     c7c:	0f 92       	push	r0
     c7e:	cd b7       	in	r28, 0x3d	; 61
     c80:	de b7       	in	r29, 0x3e	; 62
     c82:	04 c0       	rjmp	.+8      	; 0xc8c <USART_Flush+0x14>
unsigned char dummy;
while ( UCSRA & (1<<RXC) )
{
dummy = UDR;
     c84:	ec e2       	ldi	r30, 0x2C	; 44
     c86:	f0 e0       	ldi	r31, 0x00	; 0
     c88:	80 81       	ld	r24, Z
     c8a:	89 83       	std	Y+1, r24	; 0x01

}
void USART_Flush( void )
{
unsigned char dummy;
while ( UCSRA & (1<<RXC) )
     c8c:	eb e2       	ldi	r30, 0x2B	; 43
     c8e:	f0 e0       	ldi	r31, 0x00	; 0
     c90:	80 81       	ld	r24, Z
     c92:	88 23       	and	r24, r24
     c94:	bc f3       	brlt	.-18     	; 0xc84 <USART_Flush+0xc>
{
dummy = UDR;
}
}
     c96:	0f 90       	pop	r0
     c98:	cf 91       	pop	r28
     c9a:	df 91       	pop	r29
     c9c:	08 95       	ret

00000c9e <USART_SendString>:
void USART_SendString(char *str)					/* Send string of USART data function */ 
{
     c9e:	df 93       	push	r29
     ca0:	cf 93       	push	r28
     ca2:	00 d0       	rcall	.+0      	; 0xca4 <USART_SendString+0x6>
     ca4:	00 d0       	rcall	.+0      	; 0xca6 <USART_SendString+0x8>
     ca6:	cd b7       	in	r28, 0x3d	; 61
     ca8:	de b7       	in	r29, 0x3e	; 62
     caa:	9c 83       	std	Y+4, r25	; 0x04
     cac:	8b 83       	std	Y+3, r24	; 0x03
	int i=0;																	
     cae:	1a 82       	std	Y+2, r1	; 0x02
     cb0:	19 82       	std	Y+1, r1	; 0x01
     cb2:	0f c0       	rjmp	.+30     	; 0xcd2 <USART_SendString+0x34>
	while (str[i]!=0)
	{
		USART_TxChar(str[i]);						/* Send each char of string till the NULL */
     cb4:	29 81       	ldd	r18, Y+1	; 0x01
     cb6:	3a 81       	ldd	r19, Y+2	; 0x02
     cb8:	8b 81       	ldd	r24, Y+3	; 0x03
     cba:	9c 81       	ldd	r25, Y+4	; 0x04
     cbc:	fc 01       	movw	r30, r24
     cbe:	e2 0f       	add	r30, r18
     cc0:	f3 1f       	adc	r31, r19
     cc2:	80 81       	ld	r24, Z
     cc4:	0e 94 25 06 	call	0xc4a	; 0xc4a <USART_TxChar>
		i++;
     cc8:	89 81       	ldd	r24, Y+1	; 0x01
     cca:	9a 81       	ldd	r25, Y+2	; 0x02
     ccc:	01 96       	adiw	r24, 0x01	; 1
     cce:	9a 83       	std	Y+2, r25	; 0x02
     cd0:	89 83       	std	Y+1, r24	; 0x01
}
}
void USART_SendString(char *str)					/* Send string of USART data function */ 
{
	int i=0;																	
	while (str[i]!=0)
     cd2:	29 81       	ldd	r18, Y+1	; 0x01
     cd4:	3a 81       	ldd	r19, Y+2	; 0x02
     cd6:	8b 81       	ldd	r24, Y+3	; 0x03
     cd8:	9c 81       	ldd	r25, Y+4	; 0x04
     cda:	fc 01       	movw	r30, r24
     cdc:	e2 0f       	add	r30, r18
     cde:	f3 1f       	adc	r31, r19
     ce0:	80 81       	ld	r24, Z
     ce2:	88 23       	and	r24, r24
     ce4:	39 f7       	brne	.-50     	; 0xcb4 <USART_SendString+0x16>
	{
		USART_TxChar(str[i]);						/* Send each char of string till the NULL */
		i++;
	}
}
     ce6:	0f 90       	pop	r0
     ce8:	0f 90       	pop	r0
     cea:	0f 90       	pop	r0
     cec:	0f 90       	pop	r0
     cee:	cf 91       	pop	r28
     cf0:	df 91       	pop	r29
     cf2:	08 95       	ret

00000cf4 <Usart_ReceiveString_Del>:
uint8_t Usart_ReceiveString_Del( uint8_t* buf,uint8_t delimeter){
     cf4:	0f 93       	push	r16
     cf6:	1f 93       	push	r17
     cf8:	df 93       	push	r29
     cfa:	cf 93       	push	r28
     cfc:	cd b7       	in	r28, 0x3d	; 61
     cfe:	de b7       	in	r29, 0x3e	; 62
     d00:	28 97       	sbiw	r28, 0x08	; 8
     d02:	0f b6       	in	r0, 0x3f	; 63
     d04:	f8 94       	cli
     d06:	de bf       	out	0x3e, r29	; 62
     d08:	0f be       	out	0x3f, r0	; 63
     d0a:	cd bf       	out	0x3d, r28	; 61
     d0c:	9f 83       	std	Y+7, r25	; 0x07
     d0e:	8e 83       	std	Y+6, r24	; 0x06
     d10:	68 87       	std	Y+8, r22	; 0x08
	uint32_t length=0;
     d12:	1a 82       	std	Y+2, r1	; 0x02
     d14:	1b 82       	std	Y+3, r1	; 0x03
     d16:	1c 82       	std	Y+4, r1	; 0x04
     d18:	1d 82       	std	Y+5, r1	; 0x05
	uint8_t data = delimeter+1;// yamken el zero hwa 7ato delimeter 3aez inital msh delimeter
     d1a:	88 85       	ldd	r24, Y+8	; 0x08
     d1c:	8f 5f       	subi	r24, 0xFF	; 255
     d1e:	89 83       	std	Y+1, r24	; 0x01
     d20:	1f c0       	rjmp	.+62     	; 0xd60 <Usart_ReceiveString_Del+0x6c>
	while( data != delimeter )
	{
		    buf[length]= USART_RxChar();
     d22:	2a 81       	ldd	r18, Y+2	; 0x02
     d24:	3b 81       	ldd	r19, Y+3	; 0x03
     d26:	8e 81       	ldd	r24, Y+6	; 0x06
     d28:	9f 81       	ldd	r25, Y+7	; 0x07
     d2a:	8c 01       	movw	r16, r24
     d2c:	02 0f       	add	r16, r18
     d2e:	13 1f       	adc	r17, r19
     d30:	0e 94 16 06 	call	0xc2c	; 0xc2c <USART_RxChar>
     d34:	f8 01       	movw	r30, r16
     d36:	80 83       	st	Z, r24
			data = buf[length];
     d38:	2a 81       	ldd	r18, Y+2	; 0x02
     d3a:	3b 81       	ldd	r19, Y+3	; 0x03
     d3c:	8e 81       	ldd	r24, Y+6	; 0x06
     d3e:	9f 81       	ldd	r25, Y+7	; 0x07
     d40:	fc 01       	movw	r30, r24
     d42:	e2 0f       	add	r30, r18
     d44:	f3 1f       	adc	r31, r19
     d46:	80 81       	ld	r24, Z
     d48:	89 83       	std	Y+1, r24	; 0x01
			length++;
     d4a:	8a 81       	ldd	r24, Y+2	; 0x02
     d4c:	9b 81       	ldd	r25, Y+3	; 0x03
     d4e:	ac 81       	ldd	r26, Y+4	; 0x04
     d50:	bd 81       	ldd	r27, Y+5	; 0x05
     d52:	01 96       	adiw	r24, 0x01	; 1
     d54:	a1 1d       	adc	r26, r1
     d56:	b1 1d       	adc	r27, r1
     d58:	8a 83       	std	Y+2, r24	; 0x02
     d5a:	9b 83       	std	Y+3, r25	; 0x03
     d5c:	ac 83       	std	Y+4, r26	; 0x04
     d5e:	bd 83       	std	Y+5, r27	; 0x05
	}
}
uint8_t Usart_ReceiveString_Del( uint8_t* buf,uint8_t delimeter){
	uint32_t length=0;
	uint8_t data = delimeter+1;// yamken el zero hwa 7ato delimeter 3aez inital msh delimeter
	while( data != delimeter )
     d60:	99 81       	ldd	r25, Y+1	; 0x01
     d62:	88 85       	ldd	r24, Y+8	; 0x08
     d64:	98 17       	cp	r25, r24
     d66:	e9 f6       	brne	.-70     	; 0xd22 <Usart_ReceiveString_Del+0x2e>
		    buf[length]= USART_RxChar();
			data = buf[length];
			length++;

	}
	buf[length]='\0';  // LW BYTES MAFISH EL LINE DAH HATA3AML EL FUNCTION BEL LENGTH
     d68:	2a 81       	ldd	r18, Y+2	; 0x02
     d6a:	3b 81       	ldd	r19, Y+3	; 0x03
     d6c:	8e 81       	ldd	r24, Y+6	; 0x06
     d6e:	9f 81       	ldd	r25, Y+7	; 0x07
     d70:	fc 01       	movw	r30, r24
     d72:	e2 0f       	add	r30, r18
     d74:	f3 1f       	adc	r31, r19
     d76:	10 82       	st	Z, r1
	return  length;
     d78:	8a 81       	ldd	r24, Y+2	; 0x02

}
     d7a:	28 96       	adiw	r28, 0x08	; 8
     d7c:	0f b6       	in	r0, 0x3f	; 63
     d7e:	f8 94       	cli
     d80:	de bf       	out	0x3e, r29	; 62
     d82:	0f be       	out	0x3f, r0	; 63
     d84:	cd bf       	out	0x3d, r28	; 61
     d86:	cf 91       	pop	r28
     d88:	df 91       	pop	r29
     d8a:	1f 91       	pop	r17
     d8c:	0f 91       	pop	r16
     d8e:	08 95       	ret

00000d90 <Uart_Init>:
 *  Author: MahmoudH
 */ 
#include "uart.h"

/* Init. uart */
void Uart_Init(unsigned long baudRate){
     d90:	df 93       	push	r29
     d92:	cf 93       	push	r28
     d94:	00 d0       	rcall	.+0      	; 0xd96 <Uart_Init+0x6>
     d96:	00 d0       	rcall	.+0      	; 0xd98 <Uart_Init+0x8>
     d98:	00 d0       	rcall	.+0      	; 0xd9a <Uart_Init+0xa>
     d9a:	cd b7       	in	r28, 0x3d	; 61
     d9c:	de b7       	in	r29, 0x3e	; 62
     d9e:	6b 83       	std	Y+3, r22	; 0x03
     da0:	7c 83       	std	Y+4, r23	; 0x04
     da2:	8d 83       	std	Y+5, r24	; 0x05
     da4:	9e 83       	std	Y+6, r25	; 0x06
	unsigned short baud = 0;
     da6:	1a 82       	std	Y+2, r1	; 0x02
     da8:	19 82       	std	Y+1, r1	; 0x01
	baud = ((F_CPU)/(16*baudRate)) - 1;
     daa:	8b 81       	ldd	r24, Y+3	; 0x03
     dac:	9c 81       	ldd	r25, Y+4	; 0x04
     dae:	ad 81       	ldd	r26, Y+5	; 0x05
     db0:	be 81       	ldd	r27, Y+6	; 0x06
     db2:	88 0f       	add	r24, r24
     db4:	99 1f       	adc	r25, r25
     db6:	aa 1f       	adc	r26, r26
     db8:	bb 1f       	adc	r27, r27
     dba:	88 0f       	add	r24, r24
     dbc:	99 1f       	adc	r25, r25
     dbe:	aa 1f       	adc	r26, r26
     dc0:	bb 1f       	adc	r27, r27
     dc2:	88 0f       	add	r24, r24
     dc4:	99 1f       	adc	r25, r25
     dc6:	aa 1f       	adc	r26, r26
     dc8:	bb 1f       	adc	r27, r27
     dca:	88 0f       	add	r24, r24
     dcc:	99 1f       	adc	r25, r25
     dce:	aa 1f       	adc	r26, r26
     dd0:	bb 1f       	adc	r27, r27
     dd2:	9c 01       	movw	r18, r24
     dd4:	ad 01       	movw	r20, r26
     dd6:	80 e0       	ldi	r24, 0x00	; 0
     dd8:	92 e1       	ldi	r25, 0x12	; 18
     dda:	aa e7       	ldi	r26, 0x7A	; 122
     ddc:	b0 e0       	ldi	r27, 0x00	; 0
     dde:	bc 01       	movw	r22, r24
     de0:	cd 01       	movw	r24, r26
     de2:	0e 94 56 2e 	call	0x5cac	; 0x5cac <__udivmodsi4>
     de6:	da 01       	movw	r26, r20
     de8:	c9 01       	movw	r24, r18
     dea:	01 97       	sbiw	r24, 0x01	; 1
     dec:	9a 83       	std	Y+2, r25	; 0x02
     dee:	89 83       	std	Y+1, r24	; 0x01
	/* Set baud rate */
//	baud = 51;
	UBRRH = (unsigned char)(baud>>8);
     df0:	e0 e4       	ldi	r30, 0x40	; 64
     df2:	f0 e0       	ldi	r31, 0x00	; 0
     df4:	89 81       	ldd	r24, Y+1	; 0x01
     df6:	9a 81       	ldd	r25, Y+2	; 0x02
     df8:	89 2f       	mov	r24, r25
     dfa:	99 27       	eor	r25, r25
     dfc:	80 83       	st	Z, r24
	UBRRL = (unsigned char)baud;
     dfe:	e9 e2       	ldi	r30, 0x29	; 41
     e00:	f0 e0       	ldi	r31, 0x00	; 0
     e02:	89 81       	ldd	r24, Y+1	; 0x01
     e04:	80 83       	st	Z, r24
	/* Enable receiver and transmitter */
	UCSRB = (1<<RXEN)|(1<<TXEN);
     e06:	ea e2       	ldi	r30, 0x2A	; 42
     e08:	f0 e0       	ldi	r31, 0x00	; 0
     e0a:	88 e1       	ldi	r24, 0x18	; 24
     e0c:	80 83       	st	Z, r24
	/* Set frame format: 8data, 1stop bit */
	UCSRC = (1<<URSEL)|(3<<UCSZ0);
     e0e:	e0 e4       	ldi	r30, 0x40	; 64
     e10:	f0 e0       	ldi	r31, 0x00	; 0
     e12:	86 e8       	ldi	r24, 0x86	; 134
     e14:	80 83       	st	Z, r24
}
     e16:	26 96       	adiw	r28, 0x06	; 6
     e18:	0f b6       	in	r0, 0x3f	; 63
     e1a:	f8 94       	cli
     e1c:	de bf       	out	0x3e, r29	; 62
     e1e:	0f be       	out	0x3f, r0	; 63
     e20:	cd bf       	out	0x3d, r28	; 61
     e22:	cf 91       	pop	r28
     e24:	df 91       	pop	r29
     e26:	08 95       	ret

00000e28 <Uart_SendByte>:
/* Send one Byte */
void Uart_SendByte(unsigned char data){
     e28:	df 93       	push	r29
     e2a:	cf 93       	push	r28
     e2c:	0f 92       	push	r0
     e2e:	cd b7       	in	r28, 0x3d	; 61
     e30:	de b7       	in	r29, 0x3e	; 62
     e32:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)) );
     e34:	eb e2       	ldi	r30, 0x2B	; 43
     e36:	f0 e0       	ldi	r31, 0x00	; 0
     e38:	80 81       	ld	r24, Z
     e3a:	88 2f       	mov	r24, r24
     e3c:	90 e0       	ldi	r25, 0x00	; 0
     e3e:	80 72       	andi	r24, 0x20	; 32
     e40:	90 70       	andi	r25, 0x00	; 0
     e42:	00 97       	sbiw	r24, 0x00	; 0
     e44:	b9 f3       	breq	.-18     	; 0xe34 <Uart_SendByte+0xc>
	/* Put data into buffer, sends the data */
	UDR = data;
     e46:	ec e2       	ldi	r30, 0x2C	; 44
     e48:	f0 e0       	ldi	r31, 0x00	; 0
     e4a:	89 81       	ldd	r24, Y+1	; 0x01
     e4c:	80 83       	st	Z, r24
}
     e4e:	0f 90       	pop	r0
     e50:	cf 91       	pop	r28
     e52:	df 91       	pop	r29
     e54:	08 95       	ret

00000e56 <Uart_SendString>:
/* Send String (number of bytes) */
void Uart_SendString(unsigned char* str){
     e56:	df 93       	push	r29
     e58:	cf 93       	push	r28
     e5a:	00 d0       	rcall	.+0      	; 0xe5c <Uart_SendString+0x6>
     e5c:	00 d0       	rcall	.+0      	; 0xe5e <Uart_SendString+0x8>
     e5e:	00 d0       	rcall	.+0      	; 0xe60 <Uart_SendString+0xa>
     e60:	cd b7       	in	r28, 0x3d	; 61
     e62:	de b7       	in	r29, 0x3e	; 62
     e64:	9e 83       	std	Y+6, r25	; 0x06
     e66:	8d 83       	std	Y+5, r24	; 0x05
	unsigned long ind = 0;
     e68:	19 82       	std	Y+1, r1	; 0x01
     e6a:	1a 82       	std	Y+2, r1	; 0x02
     e6c:	1b 82       	std	Y+3, r1	; 0x03
     e6e:	1c 82       	std	Y+4, r1	; 0x04
     e70:	15 c0       	rjmp	.+42     	; 0xe9c <Uart_SendString+0x46>
	while(str[ind] != 0){
		Uart_SendByte(str[ind]);
     e72:	29 81       	ldd	r18, Y+1	; 0x01
     e74:	3a 81       	ldd	r19, Y+2	; 0x02
     e76:	8d 81       	ldd	r24, Y+5	; 0x05
     e78:	9e 81       	ldd	r25, Y+6	; 0x06
     e7a:	fc 01       	movw	r30, r24
     e7c:	e2 0f       	add	r30, r18
     e7e:	f3 1f       	adc	r31, r19
     e80:	80 81       	ld	r24, Z
     e82:	0e 94 14 07 	call	0xe28	; 0xe28 <Uart_SendByte>
		ind++;
     e86:	89 81       	ldd	r24, Y+1	; 0x01
     e88:	9a 81       	ldd	r25, Y+2	; 0x02
     e8a:	ab 81       	ldd	r26, Y+3	; 0x03
     e8c:	bc 81       	ldd	r27, Y+4	; 0x04
     e8e:	01 96       	adiw	r24, 0x01	; 1
     e90:	a1 1d       	adc	r26, r1
     e92:	b1 1d       	adc	r27, r1
     e94:	89 83       	std	Y+1, r24	; 0x01
     e96:	9a 83       	std	Y+2, r25	; 0x02
     e98:	ab 83       	std	Y+3, r26	; 0x03
     e9a:	bc 83       	std	Y+4, r27	; 0x04
	UDR = data;
}
/* Send String (number of bytes) */
void Uart_SendString(unsigned char* str){
	unsigned long ind = 0;
	while(str[ind] != 0){
     e9c:	29 81       	ldd	r18, Y+1	; 0x01
     e9e:	3a 81       	ldd	r19, Y+2	; 0x02
     ea0:	8d 81       	ldd	r24, Y+5	; 0x05
     ea2:	9e 81       	ldd	r25, Y+6	; 0x06
     ea4:	fc 01       	movw	r30, r24
     ea6:	e2 0f       	add	r30, r18
     ea8:	f3 1f       	adc	r31, r19
     eaa:	80 81       	ld	r24, Z
     eac:	88 23       	and	r24, r24
     eae:	09 f7       	brne	.-62     	; 0xe72 <Uart_SendString+0x1c>
		Uart_SendByte(str[ind]);
		ind++;
	}
}
     eb0:	26 96       	adiw	r28, 0x06	; 6
     eb2:	0f b6       	in	r0, 0x3f	; 63
     eb4:	f8 94       	cli
     eb6:	de bf       	out	0x3e, r29	; 62
     eb8:	0f be       	out	0x3f, r0	; 63
     eba:	cd bf       	out	0x3d, r28	; 61
     ebc:	cf 91       	pop	r28
     ebe:	df 91       	pop	r29
     ec0:	08 95       	ret

00000ec2 <Uart_ReceiveByte>:
/* Receive one Byte (Syncro. Function)*/
unsigned char Uart_ReceiveByte(void){
     ec2:	df 93       	push	r29
     ec4:	cf 93       	push	r28
     ec6:	cd b7       	in	r28, 0x3d	; 61
     ec8:	de b7       	in	r29, 0x3e	; 62
	/* Wait for data to be received */
	while ( !(UCSRA & (1<<RXC)) ); /* Blocking Condition */
     eca:	eb e2       	ldi	r30, 0x2B	; 43
     ecc:	f0 e0       	ldi	r31, 0x00	; 0
     ece:	80 81       	ld	r24, Z
     ed0:	88 23       	and	r24, r24
     ed2:	dc f7       	brge	.-10     	; 0xeca <Uart_ReceiveByte+0x8>
	/* Get and return received data from buffer */
	return UDR;
     ed4:	ec e2       	ldi	r30, 0x2C	; 44
     ed6:	f0 e0       	ldi	r31, 0x00	; 0
     ed8:	80 81       	ld	r24, Z
}
     eda:	cf 91       	pop	r28
     edc:	df 91       	pop	r29
     ede:	08 95       	ret

00000ee0 <Uart_ReceiveByte_Unblock>:
/* Receive one Byte (Unblock) */
unsigned char Uart_ReceiveByte_Unblock(unsigned char* dataPtr){
     ee0:	df 93       	push	r29
     ee2:	cf 93       	push	r28
     ee4:	00 d0       	rcall	.+0      	; 0xee6 <Uart_ReceiveByte_Unblock+0x6>
     ee6:	0f 92       	push	r0
     ee8:	cd b7       	in	r28, 0x3d	; 61
     eea:	de b7       	in	r29, 0x3e	; 62
     eec:	9b 83       	std	Y+3, r25	; 0x03
     eee:	8a 83       	std	Y+2, r24	; 0x02
	unsigned char status = 0;
     ef0:	19 82       	std	Y+1, r1	; 0x01
	if (UCSRA & (1<<RXC)){
     ef2:	eb e2       	ldi	r30, 0x2B	; 43
     ef4:	f0 e0       	ldi	r31, 0x00	; 0
     ef6:	80 81       	ld	r24, Z
     ef8:	88 23       	and	r24, r24
     efa:	4c f4       	brge	.+18     	; 0xf0e <Uart_ReceiveByte_Unblock+0x2e>
		// upload it
		(*dataPtr) = UDR;
     efc:	ec e2       	ldi	r30, 0x2C	; 44
     efe:	f0 e0       	ldi	r31, 0x00	; 0
     f00:	80 81       	ld	r24, Z
     f02:	ea 81       	ldd	r30, Y+2	; 0x02
     f04:	fb 81       	ldd	r31, Y+3	; 0x03
     f06:	80 83       	st	Z, r24
		// update status flag
		status = 1;
     f08:	81 e0       	ldi	r24, 0x01	; 1
     f0a:	89 83       	std	Y+1, r24	; 0x01
     f0c:	01 c0       	rjmp	.+2      	; 0xf10 <Uart_ReceiveByte_Unblock+0x30>
	}
	else{
		status = 0;
     f0e:	19 82       	std	Y+1, r1	; 0x01
	}
	return status;
     f10:	89 81       	ldd	r24, Y+1	; 0x01
     f12:	0f 90       	pop	r0
     f14:	0f 90       	pop	r0
     f16:	0f 90       	pop	r0
     f18:	cf 91       	pop	r28
     f1a:	df 91       	pop	r29
     f1c:	08 95       	ret

00000f1e <SmartLock_Init>:

#include "SmartLock.h"



void SmartLock_Init(void) {
     f1e:	df 93       	push	r29
     f20:	cf 93       	push	r28
     f22:	cd b7       	in	r28, 0x3d	; 61
     f24:	de b7       	in	r29, 0x3e	; 62
     f26:	6c 97       	sbiw	r28, 0x1c	; 28
     f28:	0f b6       	in	r0, 0x3f	; 63
     f2a:	f8 94       	cli
     f2c:	de bf       	out	0x3e, r29	; 62
     f2e:	0f be       	out	0x3f, r0	; 63
     f30:	cd bf       	out	0x3d, r28	; 61
	USART_Init(9600); /* initialize USART with 9600 baud rate */
     f32:	60 e8       	ldi	r22, 0x80	; 128
     f34:	75 e2       	ldi	r23, 0x25	; 37
     f36:	80 e0       	ldi	r24, 0x00	; 0
     f38:	90 e0       	ldi	r25, 0x00	; 0
     f3a:	0e 94 a3 05 	call	0xb46	; 0xb46 <USART_Init>
	DDRB = 0xff; /* make PORTB as output port */
     f3e:	e7 e3       	ldi	r30, 0x37	; 55
     f40:	f0 e0       	ldi	r31, 0x00	; 0
     f42:	8f ef       	ldi	r24, 0xFF	; 255
     f44:	80 83       	st	Z, r24
	DDRC = 0X00;
     f46:	e4 e3       	ldi	r30, 0x34	; 52
     f48:	f0 e0       	ldi	r31, 0x00	; 0
     f4a:	10 82       	st	Z, r1
	LED1_BUZZER_Light_Lock = 0;
     f4c:	e8 e3       	ldi	r30, 0x38	; 56
     f4e:	f0 e0       	ldi	r31, 0x00	; 0
     f50:	10 82       	st	Z, r1
	USART_SendString("SmartLock\r");
     f52:	80 e6       	ldi	r24, 0x60	; 96
     f54:	90 e0       	ldi	r25, 0x00	; 0
     f56:	0e 94 4f 06 	call	0xc9e	; 0xc9e <USART_SendString>
     f5a:	80 e0       	ldi	r24, 0x00	; 0
     f5c:	90 e0       	ldi	r25, 0x00	; 0
     f5e:	aa ef       	ldi	r26, 0xFA	; 250
     f60:	b3 e4       	ldi	r27, 0x43	; 67
     f62:	89 8f       	std	Y+25, r24	; 0x19
     f64:	9a 8f       	std	Y+26, r25	; 0x1a
     f66:	ab 8f       	std	Y+27, r26	; 0x1b
     f68:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     f6a:	69 8d       	ldd	r22, Y+25	; 0x19
     f6c:	7a 8d       	ldd	r23, Y+26	; 0x1a
     f6e:	8b 8d       	ldd	r24, Y+27	; 0x1b
     f70:	9c 8d       	ldd	r25, Y+28	; 0x1c
     f72:	20 e0       	ldi	r18, 0x00	; 0
     f74:	30 e0       	ldi	r19, 0x00	; 0
     f76:	4a ef       	ldi	r20, 0xFA	; 250
     f78:	54 e4       	ldi	r21, 0x44	; 68
     f7a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     f7e:	dc 01       	movw	r26, r24
     f80:	cb 01       	movw	r24, r22
     f82:	8d 8b       	std	Y+21, r24	; 0x15
     f84:	9e 8b       	std	Y+22, r25	; 0x16
     f86:	af 8b       	std	Y+23, r26	; 0x17
     f88:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
     f8a:	6d 89       	ldd	r22, Y+21	; 0x15
     f8c:	7e 89       	ldd	r23, Y+22	; 0x16
     f8e:	8f 89       	ldd	r24, Y+23	; 0x17
     f90:	98 8d       	ldd	r25, Y+24	; 0x18
     f92:	20 e0       	ldi	r18, 0x00	; 0
     f94:	30 e0       	ldi	r19, 0x00	; 0
     f96:	40 e8       	ldi	r20, 0x80	; 128
     f98:	5f e3       	ldi	r21, 0x3F	; 63
     f9a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     f9e:	88 23       	and	r24, r24
     fa0:	2c f4       	brge	.+10     	; 0xfac <SmartLock_Init+0x8e>
		__ticks = 1;
     fa2:	81 e0       	ldi	r24, 0x01	; 1
     fa4:	90 e0       	ldi	r25, 0x00	; 0
     fa6:	9c 8b       	std	Y+20, r25	; 0x14
     fa8:	8b 8b       	std	Y+19, r24	; 0x13
     faa:	3f c0       	rjmp	.+126    	; 0x102a <SmartLock_Init+0x10c>
	else if (__tmp > 65535)
     fac:	6d 89       	ldd	r22, Y+21	; 0x15
     fae:	7e 89       	ldd	r23, Y+22	; 0x16
     fb0:	8f 89       	ldd	r24, Y+23	; 0x17
     fb2:	98 8d       	ldd	r25, Y+24	; 0x18
     fb4:	20 e0       	ldi	r18, 0x00	; 0
     fb6:	3f ef       	ldi	r19, 0xFF	; 255
     fb8:	4f e7       	ldi	r20, 0x7F	; 127
     fba:	57 e4       	ldi	r21, 0x47	; 71
     fbc:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     fc0:	18 16       	cp	r1, r24
     fc2:	4c f5       	brge	.+82     	; 0x1016 <SmartLock_Init+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     fc4:	69 8d       	ldd	r22, Y+25	; 0x19
     fc6:	7a 8d       	ldd	r23, Y+26	; 0x1a
     fc8:	8b 8d       	ldd	r24, Y+27	; 0x1b
     fca:	9c 8d       	ldd	r25, Y+28	; 0x1c
     fcc:	20 e0       	ldi	r18, 0x00	; 0
     fce:	30 e0       	ldi	r19, 0x00	; 0
     fd0:	40 e2       	ldi	r20, 0x20	; 32
     fd2:	51 e4       	ldi	r21, 0x41	; 65
     fd4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     fd8:	dc 01       	movw	r26, r24
     fda:	cb 01       	movw	r24, r22
     fdc:	bc 01       	movw	r22, r24
     fde:	cd 01       	movw	r24, r26
     fe0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     fe4:	dc 01       	movw	r26, r24
     fe6:	cb 01       	movw	r24, r22
     fe8:	9c 8b       	std	Y+20, r25	; 0x14
     fea:	8b 8b       	std	Y+19, r24	; 0x13
     fec:	0f c0       	rjmp	.+30     	; 0x100c <SmartLock_Init+0xee>
     fee:	88 ec       	ldi	r24, 0xC8	; 200
     ff0:	90 e0       	ldi	r25, 0x00	; 0
     ff2:	9a 8b       	std	Y+18, r25	; 0x12
     ff4:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     ff6:	89 89       	ldd	r24, Y+17	; 0x11
     ff8:	9a 89       	ldd	r25, Y+18	; 0x12
     ffa:	01 97       	sbiw	r24, 0x01	; 1
     ffc:	f1 f7       	brne	.-4      	; 0xffa <SmartLock_Init+0xdc>
     ffe:	9a 8b       	std	Y+18, r25	; 0x12
    1000:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1002:	8b 89       	ldd	r24, Y+19	; 0x13
    1004:	9c 89       	ldd	r25, Y+20	; 0x14
    1006:	01 97       	sbiw	r24, 0x01	; 1
    1008:	9c 8b       	std	Y+20, r25	; 0x14
    100a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    100c:	8b 89       	ldd	r24, Y+19	; 0x13
    100e:	9c 89       	ldd	r25, Y+20	; 0x14
    1010:	00 97       	sbiw	r24, 0x00	; 0
    1012:	69 f7       	brne	.-38     	; 0xfee <SmartLock_Init+0xd0>
    1014:	14 c0       	rjmp	.+40     	; 0x103e <SmartLock_Init+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1016:	6d 89       	ldd	r22, Y+21	; 0x15
    1018:	7e 89       	ldd	r23, Y+22	; 0x16
    101a:	8f 89       	ldd	r24, Y+23	; 0x17
    101c:	98 8d       	ldd	r25, Y+24	; 0x18
    101e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1022:	dc 01       	movw	r26, r24
    1024:	cb 01       	movw	r24, r22
    1026:	9c 8b       	std	Y+20, r25	; 0x14
    1028:	8b 8b       	std	Y+19, r24	; 0x13
    102a:	8b 89       	ldd	r24, Y+19	; 0x13
    102c:	9c 89       	ldd	r25, Y+20	; 0x14
    102e:	98 8b       	std	Y+16, r25	; 0x10
    1030:	8f 87       	std	Y+15, r24	; 0x0f
    1032:	8f 85       	ldd	r24, Y+15	; 0x0f
    1034:	98 89       	ldd	r25, Y+16	; 0x10
    1036:	01 97       	sbiw	r24, 0x01	; 1
    1038:	f1 f7       	brne	.-4      	; 0x1036 <SmartLock_Init+0x118>
    103a:	98 8b       	std	Y+16, r25	; 0x10
    103c:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(500);
	USART_SendString("Please Login\r");
    103e:	8b e6       	ldi	r24, 0x6B	; 107
    1040:	90 e0       	ldi	r25, 0x00	; 0
    1042:	0e 94 4f 06 	call	0xc9e	; 0xc9e <USART_SendString>
    1046:	80 e0       	ldi	r24, 0x00	; 0
    1048:	90 e0       	ldi	r25, 0x00	; 0
    104a:	aa ef       	ldi	r26, 0xFA	; 250
    104c:	b3 e4       	ldi	r27, 0x43	; 67
    104e:	8b 87       	std	Y+11, r24	; 0x0b
    1050:	9c 87       	std	Y+12, r25	; 0x0c
    1052:	ad 87       	std	Y+13, r26	; 0x0d
    1054:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1056:	6b 85       	ldd	r22, Y+11	; 0x0b
    1058:	7c 85       	ldd	r23, Y+12	; 0x0c
    105a:	8d 85       	ldd	r24, Y+13	; 0x0d
    105c:	9e 85       	ldd	r25, Y+14	; 0x0e
    105e:	20 e0       	ldi	r18, 0x00	; 0
    1060:	30 e0       	ldi	r19, 0x00	; 0
    1062:	4a ef       	ldi	r20, 0xFA	; 250
    1064:	54 e4       	ldi	r21, 0x44	; 68
    1066:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    106a:	dc 01       	movw	r26, r24
    106c:	cb 01       	movw	r24, r22
    106e:	8f 83       	std	Y+7, r24	; 0x07
    1070:	98 87       	std	Y+8, r25	; 0x08
    1072:	a9 87       	std	Y+9, r26	; 0x09
    1074:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1076:	6f 81       	ldd	r22, Y+7	; 0x07
    1078:	78 85       	ldd	r23, Y+8	; 0x08
    107a:	89 85       	ldd	r24, Y+9	; 0x09
    107c:	9a 85       	ldd	r25, Y+10	; 0x0a
    107e:	20 e0       	ldi	r18, 0x00	; 0
    1080:	30 e0       	ldi	r19, 0x00	; 0
    1082:	40 e8       	ldi	r20, 0x80	; 128
    1084:	5f e3       	ldi	r21, 0x3F	; 63
    1086:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    108a:	88 23       	and	r24, r24
    108c:	2c f4       	brge	.+10     	; 0x1098 <SmartLock_Init+0x17a>
		__ticks = 1;
    108e:	81 e0       	ldi	r24, 0x01	; 1
    1090:	90 e0       	ldi	r25, 0x00	; 0
    1092:	9e 83       	std	Y+6, r25	; 0x06
    1094:	8d 83       	std	Y+5, r24	; 0x05
    1096:	3f c0       	rjmp	.+126    	; 0x1116 <SmartLock_Init+0x1f8>
	else if (__tmp > 65535)
    1098:	6f 81       	ldd	r22, Y+7	; 0x07
    109a:	78 85       	ldd	r23, Y+8	; 0x08
    109c:	89 85       	ldd	r24, Y+9	; 0x09
    109e:	9a 85       	ldd	r25, Y+10	; 0x0a
    10a0:	20 e0       	ldi	r18, 0x00	; 0
    10a2:	3f ef       	ldi	r19, 0xFF	; 255
    10a4:	4f e7       	ldi	r20, 0x7F	; 127
    10a6:	57 e4       	ldi	r21, 0x47	; 71
    10a8:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    10ac:	18 16       	cp	r1, r24
    10ae:	4c f5       	brge	.+82     	; 0x1102 <SmartLock_Init+0x1e4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    10b0:	6b 85       	ldd	r22, Y+11	; 0x0b
    10b2:	7c 85       	ldd	r23, Y+12	; 0x0c
    10b4:	8d 85       	ldd	r24, Y+13	; 0x0d
    10b6:	9e 85       	ldd	r25, Y+14	; 0x0e
    10b8:	20 e0       	ldi	r18, 0x00	; 0
    10ba:	30 e0       	ldi	r19, 0x00	; 0
    10bc:	40 e2       	ldi	r20, 0x20	; 32
    10be:	51 e4       	ldi	r21, 0x41	; 65
    10c0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    10c4:	dc 01       	movw	r26, r24
    10c6:	cb 01       	movw	r24, r22
    10c8:	bc 01       	movw	r22, r24
    10ca:	cd 01       	movw	r24, r26
    10cc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    10d0:	dc 01       	movw	r26, r24
    10d2:	cb 01       	movw	r24, r22
    10d4:	9e 83       	std	Y+6, r25	; 0x06
    10d6:	8d 83       	std	Y+5, r24	; 0x05
    10d8:	0f c0       	rjmp	.+30     	; 0x10f8 <SmartLock_Init+0x1da>
    10da:	88 ec       	ldi	r24, 0xC8	; 200
    10dc:	90 e0       	ldi	r25, 0x00	; 0
    10de:	9c 83       	std	Y+4, r25	; 0x04
    10e0:	8b 83       	std	Y+3, r24	; 0x03
    10e2:	8b 81       	ldd	r24, Y+3	; 0x03
    10e4:	9c 81       	ldd	r25, Y+4	; 0x04
    10e6:	01 97       	sbiw	r24, 0x01	; 1
    10e8:	f1 f7       	brne	.-4      	; 0x10e6 <SmartLock_Init+0x1c8>
    10ea:	9c 83       	std	Y+4, r25	; 0x04
    10ec:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    10ee:	8d 81       	ldd	r24, Y+5	; 0x05
    10f0:	9e 81       	ldd	r25, Y+6	; 0x06
    10f2:	01 97       	sbiw	r24, 0x01	; 1
    10f4:	9e 83       	std	Y+6, r25	; 0x06
    10f6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    10f8:	8d 81       	ldd	r24, Y+5	; 0x05
    10fa:	9e 81       	ldd	r25, Y+6	; 0x06
    10fc:	00 97       	sbiw	r24, 0x00	; 0
    10fe:	69 f7       	brne	.-38     	; 0x10da <SmartLock_Init+0x1bc>
    1100:	14 c0       	rjmp	.+40     	; 0x112a <SmartLock_Init+0x20c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1102:	6f 81       	ldd	r22, Y+7	; 0x07
    1104:	78 85       	ldd	r23, Y+8	; 0x08
    1106:	89 85       	ldd	r24, Y+9	; 0x09
    1108:	9a 85       	ldd	r25, Y+10	; 0x0a
    110a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    110e:	dc 01       	movw	r26, r24
    1110:	cb 01       	movw	r24, r22
    1112:	9e 83       	std	Y+6, r25	; 0x06
    1114:	8d 83       	std	Y+5, r24	; 0x05
    1116:	8d 81       	ldd	r24, Y+5	; 0x05
    1118:	9e 81       	ldd	r25, Y+6	; 0x06
    111a:	9a 83       	std	Y+2, r25	; 0x02
    111c:	89 83       	std	Y+1, r24	; 0x01
    111e:	89 81       	ldd	r24, Y+1	; 0x01
    1120:	9a 81       	ldd	r25, Y+2	; 0x02
    1122:	01 97       	sbiw	r24, 0x01	; 1
    1124:	f1 f7       	brne	.-4      	; 0x1122 <SmartLock_Init+0x204>
    1126:	9a 83       	std	Y+2, r25	; 0x02
    1128:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(500);
}
    112a:	6c 96       	adiw	r28, 0x1c	; 28
    112c:	0f b6       	in	r0, 0x3f	; 63
    112e:	f8 94       	cli
    1130:	de bf       	out	0x3e, r29	; 62
    1132:	0f be       	out	0x3f, r0	; 63
    1134:	cd bf       	out	0x3d, r28	; 61
    1136:	cf 91       	pop	r28
    1138:	df 91       	pop	r29
    113a:	08 95       	ret

0000113c <CheckLogin>:
char CheckLogin(void) {
    113c:	df 93       	push	r29
    113e:	cf 93       	push	r28
    1140:	cd b7       	in	r28, 0x3d	; 61
    1142:	de b7       	in	r29, 0x3e	; 62
    1144:	c3 5e       	subi	r28, 0xE3	; 227
    1146:	d1 40       	sbci	r29, 0x01	; 1
    1148:	0f b6       	in	r0, 0x3f	; 63
    114a:	f8 94       	cli
    114c:	de bf       	out	0x3e, r29	; 62
    114e:	0f be       	out	0x3f, r0	; 63
    1150:	cd bf       	out	0x3d, r28	; 61
	char i = 0;
    1152:	1b 82       	std	Y+3, r1	; 0x03
	char state = 0;
    1154:	1a 82       	std	Y+2, r1	; 0x02
	char username[10][8] = { "test1\r", "test2\r", "test3\r", "test4\r",
			"test5\r", "test6\r", "test7\r", "test8\r", "test9\r", "test10\r" };
    1156:	80 e5       	ldi	r24, 0x50	; 80
    1158:	fe 01       	movw	r30, r28
    115a:	34 96       	adiw	r30, 0x04	; 4
    115c:	df 01       	movw	r26, r30
    115e:	98 2f       	mov	r25, r24
    1160:	1d 92       	st	X+, r1
    1162:	9a 95       	dec	r25
    1164:	e9 f7       	brne	.-6      	; 0x1160 <CheckLogin+0x24>
    1166:	de 01       	movw	r26, r28
    1168:	14 96       	adiw	r26, 0x04	; 4
    116a:	c4 59       	subi	r28, 0x94	; 148
    116c:	de 4f       	sbci	r29, 0xFE	; 254
    116e:	b9 83       	std	Y+1, r27	; 0x01
    1170:	a8 83       	st	Y, r26
    1172:	cc 56       	subi	r28, 0x6C	; 108
    1174:	d1 40       	sbci	r29, 0x01	; 1
    1176:	e9 e9       	ldi	r30, 0x99	; 153
    1178:	f0 e0       	ldi	r31, 0x00	; 0
    117a:	c2 59       	subi	r28, 0x92	; 146
    117c:	de 4f       	sbci	r29, 0xFE	; 254
    117e:	f9 83       	std	Y+1, r31	; 0x01
    1180:	e8 83       	st	Y, r30
    1182:	ce 56       	subi	r28, 0x6E	; 110
    1184:	d1 40       	sbci	r29, 0x01	; 1
    1186:	f7 e0       	ldi	r31, 0x07	; 7
    1188:	c0 59       	subi	r28, 0x90	; 144
    118a:	de 4f       	sbci	r29, 0xFE	; 254
    118c:	f8 83       	st	Y, r31
    118e:	c0 57       	subi	r28, 0x70	; 112
    1190:	d1 40       	sbci	r29, 0x01	; 1
    1192:	c2 59       	subi	r28, 0x92	; 146
    1194:	de 4f       	sbci	r29, 0xFE	; 254
    1196:	a8 81       	ld	r26, Y
    1198:	b9 81       	ldd	r27, Y+1	; 0x01
    119a:	ce 56       	subi	r28, 0x6E	; 110
    119c:	d1 40       	sbci	r29, 0x01	; 1
    119e:	0c 90       	ld	r0, X
    11a0:	c2 59       	subi	r28, 0x92	; 146
    11a2:	de 4f       	sbci	r29, 0xFE	; 254
    11a4:	e8 81       	ld	r30, Y
    11a6:	f9 81       	ldd	r31, Y+1	; 0x01
    11a8:	ce 56       	subi	r28, 0x6E	; 110
    11aa:	d1 40       	sbci	r29, 0x01	; 1
    11ac:	31 96       	adiw	r30, 0x01	; 1
    11ae:	c2 59       	subi	r28, 0x92	; 146
    11b0:	de 4f       	sbci	r29, 0xFE	; 254
    11b2:	f9 83       	std	Y+1, r31	; 0x01
    11b4:	e8 83       	st	Y, r30
    11b6:	ce 56       	subi	r28, 0x6E	; 110
    11b8:	d1 40       	sbci	r29, 0x01	; 1
    11ba:	c4 59       	subi	r28, 0x94	; 148
    11bc:	de 4f       	sbci	r29, 0xFE	; 254
    11be:	a8 81       	ld	r26, Y
    11c0:	b9 81       	ldd	r27, Y+1	; 0x01
    11c2:	cc 56       	subi	r28, 0x6C	; 108
    11c4:	d1 40       	sbci	r29, 0x01	; 1
    11c6:	0c 92       	st	X, r0
    11c8:	c4 59       	subi	r28, 0x94	; 148
    11ca:	de 4f       	sbci	r29, 0xFE	; 254
    11cc:	e8 81       	ld	r30, Y
    11ce:	f9 81       	ldd	r31, Y+1	; 0x01
    11d0:	cc 56       	subi	r28, 0x6C	; 108
    11d2:	d1 40       	sbci	r29, 0x01	; 1
    11d4:	31 96       	adiw	r30, 0x01	; 1
    11d6:	c4 59       	subi	r28, 0x94	; 148
    11d8:	de 4f       	sbci	r29, 0xFE	; 254
    11da:	f9 83       	std	Y+1, r31	; 0x01
    11dc:	e8 83       	st	Y, r30
    11de:	cc 56       	subi	r28, 0x6C	; 108
    11e0:	d1 40       	sbci	r29, 0x01	; 1
    11e2:	c0 59       	subi	r28, 0x90	; 144
    11e4:	de 4f       	sbci	r29, 0xFE	; 254
    11e6:	f8 81       	ld	r31, Y
    11e8:	c0 57       	subi	r28, 0x70	; 112
    11ea:	d1 40       	sbci	r29, 0x01	; 1
    11ec:	f1 50       	subi	r31, 0x01	; 1
    11ee:	c0 59       	subi	r28, 0x90	; 144
    11f0:	de 4f       	sbci	r29, 0xFE	; 254
    11f2:	f8 83       	st	Y, r31
    11f4:	c0 57       	subi	r28, 0x70	; 112
    11f6:	d1 40       	sbci	r29, 0x01	; 1
    11f8:	c0 59       	subi	r28, 0x90	; 144
    11fa:	de 4f       	sbci	r29, 0xFE	; 254
    11fc:	88 81       	ld	r24, Y
    11fe:	c0 57       	subi	r28, 0x70	; 112
    1200:	d1 40       	sbci	r29, 0x01	; 1
    1202:	88 23       	and	r24, r24
    1204:	31 f6       	brne	.-116    	; 0x1192 <CheckLogin+0x56>
    1206:	1b 86       	std	Y+11, r1	; 0x0b
    1208:	de 01       	movw	r26, r28
    120a:	1c 96       	adiw	r26, 0x0c	; 12
    120c:	cf 58       	subi	r28, 0x8F	; 143
    120e:	de 4f       	sbci	r29, 0xFE	; 254
    1210:	b9 83       	std	Y+1, r27	; 0x01
    1212:	a8 83       	st	Y, r26
    1214:	c1 57       	subi	r28, 0x71	; 113
    1216:	d1 40       	sbci	r29, 0x01	; 1
    1218:	e1 ea       	ldi	r30, 0xA1	; 161
    121a:	f0 e0       	ldi	r31, 0x00	; 0
    121c:	cd 58       	subi	r28, 0x8D	; 141
    121e:	de 4f       	sbci	r29, 0xFE	; 254
    1220:	f9 83       	std	Y+1, r31	; 0x01
    1222:	e8 83       	st	Y, r30
    1224:	c3 57       	subi	r28, 0x73	; 115
    1226:	d1 40       	sbci	r29, 0x01	; 1
    1228:	f7 e0       	ldi	r31, 0x07	; 7
    122a:	cb 58       	subi	r28, 0x8B	; 139
    122c:	de 4f       	sbci	r29, 0xFE	; 254
    122e:	f8 83       	st	Y, r31
    1230:	c5 57       	subi	r28, 0x75	; 117
    1232:	d1 40       	sbci	r29, 0x01	; 1
    1234:	cd 58       	subi	r28, 0x8D	; 141
    1236:	de 4f       	sbci	r29, 0xFE	; 254
    1238:	a8 81       	ld	r26, Y
    123a:	b9 81       	ldd	r27, Y+1	; 0x01
    123c:	c3 57       	subi	r28, 0x73	; 115
    123e:	d1 40       	sbci	r29, 0x01	; 1
    1240:	0c 90       	ld	r0, X
    1242:	cd 58       	subi	r28, 0x8D	; 141
    1244:	de 4f       	sbci	r29, 0xFE	; 254
    1246:	e8 81       	ld	r30, Y
    1248:	f9 81       	ldd	r31, Y+1	; 0x01
    124a:	c3 57       	subi	r28, 0x73	; 115
    124c:	d1 40       	sbci	r29, 0x01	; 1
    124e:	31 96       	adiw	r30, 0x01	; 1
    1250:	cd 58       	subi	r28, 0x8D	; 141
    1252:	de 4f       	sbci	r29, 0xFE	; 254
    1254:	f9 83       	std	Y+1, r31	; 0x01
    1256:	e8 83       	st	Y, r30
    1258:	c3 57       	subi	r28, 0x73	; 115
    125a:	d1 40       	sbci	r29, 0x01	; 1
    125c:	cf 58       	subi	r28, 0x8F	; 143
    125e:	de 4f       	sbci	r29, 0xFE	; 254
    1260:	a8 81       	ld	r26, Y
    1262:	b9 81       	ldd	r27, Y+1	; 0x01
    1264:	c1 57       	subi	r28, 0x71	; 113
    1266:	d1 40       	sbci	r29, 0x01	; 1
    1268:	0c 92       	st	X, r0
    126a:	cf 58       	subi	r28, 0x8F	; 143
    126c:	de 4f       	sbci	r29, 0xFE	; 254
    126e:	e8 81       	ld	r30, Y
    1270:	f9 81       	ldd	r31, Y+1	; 0x01
    1272:	c1 57       	subi	r28, 0x71	; 113
    1274:	d1 40       	sbci	r29, 0x01	; 1
    1276:	31 96       	adiw	r30, 0x01	; 1
    1278:	cf 58       	subi	r28, 0x8F	; 143
    127a:	de 4f       	sbci	r29, 0xFE	; 254
    127c:	f9 83       	std	Y+1, r31	; 0x01
    127e:	e8 83       	st	Y, r30
    1280:	c1 57       	subi	r28, 0x71	; 113
    1282:	d1 40       	sbci	r29, 0x01	; 1
    1284:	cb 58       	subi	r28, 0x8B	; 139
    1286:	de 4f       	sbci	r29, 0xFE	; 254
    1288:	f8 81       	ld	r31, Y
    128a:	c5 57       	subi	r28, 0x75	; 117
    128c:	d1 40       	sbci	r29, 0x01	; 1
    128e:	f1 50       	subi	r31, 0x01	; 1
    1290:	cb 58       	subi	r28, 0x8B	; 139
    1292:	de 4f       	sbci	r29, 0xFE	; 254
    1294:	f8 83       	st	Y, r31
    1296:	c5 57       	subi	r28, 0x75	; 117
    1298:	d1 40       	sbci	r29, 0x01	; 1
    129a:	cb 58       	subi	r28, 0x8B	; 139
    129c:	de 4f       	sbci	r29, 0xFE	; 254
    129e:	88 81       	ld	r24, Y
    12a0:	c5 57       	subi	r28, 0x75	; 117
    12a2:	d1 40       	sbci	r29, 0x01	; 1
    12a4:	88 23       	and	r24, r24
    12a6:	31 f6       	brne	.-116    	; 0x1234 <CheckLogin+0xf8>
    12a8:	1b 8a       	std	Y+19, r1	; 0x13
    12aa:	de 01       	movw	r26, r28
    12ac:	54 96       	adiw	r26, 0x14	; 20
    12ae:	ca 58       	subi	r28, 0x8A	; 138
    12b0:	de 4f       	sbci	r29, 0xFE	; 254
    12b2:	b9 83       	std	Y+1, r27	; 0x01
    12b4:	a8 83       	st	Y, r26
    12b6:	c6 57       	subi	r28, 0x76	; 118
    12b8:	d1 40       	sbci	r29, 0x01	; 1
    12ba:	e9 ea       	ldi	r30, 0xA9	; 169
    12bc:	f0 e0       	ldi	r31, 0x00	; 0
    12be:	c8 58       	subi	r28, 0x88	; 136
    12c0:	de 4f       	sbci	r29, 0xFE	; 254
    12c2:	f9 83       	std	Y+1, r31	; 0x01
    12c4:	e8 83       	st	Y, r30
    12c6:	c8 57       	subi	r28, 0x78	; 120
    12c8:	d1 40       	sbci	r29, 0x01	; 1
    12ca:	f7 e0       	ldi	r31, 0x07	; 7
    12cc:	c6 58       	subi	r28, 0x86	; 134
    12ce:	de 4f       	sbci	r29, 0xFE	; 254
    12d0:	f8 83       	st	Y, r31
    12d2:	ca 57       	subi	r28, 0x7A	; 122
    12d4:	d1 40       	sbci	r29, 0x01	; 1
    12d6:	c8 58       	subi	r28, 0x88	; 136
    12d8:	de 4f       	sbci	r29, 0xFE	; 254
    12da:	a8 81       	ld	r26, Y
    12dc:	b9 81       	ldd	r27, Y+1	; 0x01
    12de:	c8 57       	subi	r28, 0x78	; 120
    12e0:	d1 40       	sbci	r29, 0x01	; 1
    12e2:	0c 90       	ld	r0, X
    12e4:	c8 58       	subi	r28, 0x88	; 136
    12e6:	de 4f       	sbci	r29, 0xFE	; 254
    12e8:	e8 81       	ld	r30, Y
    12ea:	f9 81       	ldd	r31, Y+1	; 0x01
    12ec:	c8 57       	subi	r28, 0x78	; 120
    12ee:	d1 40       	sbci	r29, 0x01	; 1
    12f0:	31 96       	adiw	r30, 0x01	; 1
    12f2:	c8 58       	subi	r28, 0x88	; 136
    12f4:	de 4f       	sbci	r29, 0xFE	; 254
    12f6:	f9 83       	std	Y+1, r31	; 0x01
    12f8:	e8 83       	st	Y, r30
    12fa:	c8 57       	subi	r28, 0x78	; 120
    12fc:	d1 40       	sbci	r29, 0x01	; 1
    12fe:	ca 58       	subi	r28, 0x8A	; 138
    1300:	de 4f       	sbci	r29, 0xFE	; 254
    1302:	a8 81       	ld	r26, Y
    1304:	b9 81       	ldd	r27, Y+1	; 0x01
    1306:	c6 57       	subi	r28, 0x76	; 118
    1308:	d1 40       	sbci	r29, 0x01	; 1
    130a:	0c 92       	st	X, r0
    130c:	ca 58       	subi	r28, 0x8A	; 138
    130e:	de 4f       	sbci	r29, 0xFE	; 254
    1310:	e8 81       	ld	r30, Y
    1312:	f9 81       	ldd	r31, Y+1	; 0x01
    1314:	c6 57       	subi	r28, 0x76	; 118
    1316:	d1 40       	sbci	r29, 0x01	; 1
    1318:	31 96       	adiw	r30, 0x01	; 1
    131a:	ca 58       	subi	r28, 0x8A	; 138
    131c:	de 4f       	sbci	r29, 0xFE	; 254
    131e:	f9 83       	std	Y+1, r31	; 0x01
    1320:	e8 83       	st	Y, r30
    1322:	c6 57       	subi	r28, 0x76	; 118
    1324:	d1 40       	sbci	r29, 0x01	; 1
    1326:	c6 58       	subi	r28, 0x86	; 134
    1328:	de 4f       	sbci	r29, 0xFE	; 254
    132a:	f8 81       	ld	r31, Y
    132c:	ca 57       	subi	r28, 0x7A	; 122
    132e:	d1 40       	sbci	r29, 0x01	; 1
    1330:	f1 50       	subi	r31, 0x01	; 1
    1332:	c6 58       	subi	r28, 0x86	; 134
    1334:	de 4f       	sbci	r29, 0xFE	; 254
    1336:	f8 83       	st	Y, r31
    1338:	ca 57       	subi	r28, 0x7A	; 122
    133a:	d1 40       	sbci	r29, 0x01	; 1
    133c:	c6 58       	subi	r28, 0x86	; 134
    133e:	de 4f       	sbci	r29, 0xFE	; 254
    1340:	88 81       	ld	r24, Y
    1342:	ca 57       	subi	r28, 0x7A	; 122
    1344:	d1 40       	sbci	r29, 0x01	; 1
    1346:	88 23       	and	r24, r24
    1348:	31 f6       	brne	.-116    	; 0x12d6 <CheckLogin+0x19a>
    134a:	1b 8e       	std	Y+27, r1	; 0x1b
    134c:	de 01       	movw	r26, r28
    134e:	5c 96       	adiw	r26, 0x1c	; 28
    1350:	c5 58       	subi	r28, 0x85	; 133
    1352:	de 4f       	sbci	r29, 0xFE	; 254
    1354:	b9 83       	std	Y+1, r27	; 0x01
    1356:	a8 83       	st	Y, r26
    1358:	cb 57       	subi	r28, 0x7B	; 123
    135a:	d1 40       	sbci	r29, 0x01	; 1
    135c:	e1 eb       	ldi	r30, 0xB1	; 177
    135e:	f0 e0       	ldi	r31, 0x00	; 0
    1360:	c3 58       	subi	r28, 0x83	; 131
    1362:	de 4f       	sbci	r29, 0xFE	; 254
    1364:	f9 83       	std	Y+1, r31	; 0x01
    1366:	e8 83       	st	Y, r30
    1368:	cd 57       	subi	r28, 0x7D	; 125
    136a:	d1 40       	sbci	r29, 0x01	; 1
    136c:	f7 e0       	ldi	r31, 0x07	; 7
    136e:	c1 58       	subi	r28, 0x81	; 129
    1370:	de 4f       	sbci	r29, 0xFE	; 254
    1372:	f8 83       	st	Y, r31
    1374:	cf 57       	subi	r28, 0x7F	; 127
    1376:	d1 40       	sbci	r29, 0x01	; 1
    1378:	c3 58       	subi	r28, 0x83	; 131
    137a:	de 4f       	sbci	r29, 0xFE	; 254
    137c:	a8 81       	ld	r26, Y
    137e:	b9 81       	ldd	r27, Y+1	; 0x01
    1380:	cd 57       	subi	r28, 0x7D	; 125
    1382:	d1 40       	sbci	r29, 0x01	; 1
    1384:	0c 90       	ld	r0, X
    1386:	c3 58       	subi	r28, 0x83	; 131
    1388:	de 4f       	sbci	r29, 0xFE	; 254
    138a:	e8 81       	ld	r30, Y
    138c:	f9 81       	ldd	r31, Y+1	; 0x01
    138e:	cd 57       	subi	r28, 0x7D	; 125
    1390:	d1 40       	sbci	r29, 0x01	; 1
    1392:	31 96       	adiw	r30, 0x01	; 1
    1394:	c3 58       	subi	r28, 0x83	; 131
    1396:	de 4f       	sbci	r29, 0xFE	; 254
    1398:	f9 83       	std	Y+1, r31	; 0x01
    139a:	e8 83       	st	Y, r30
    139c:	cd 57       	subi	r28, 0x7D	; 125
    139e:	d1 40       	sbci	r29, 0x01	; 1
    13a0:	c5 58       	subi	r28, 0x85	; 133
    13a2:	de 4f       	sbci	r29, 0xFE	; 254
    13a4:	a8 81       	ld	r26, Y
    13a6:	b9 81       	ldd	r27, Y+1	; 0x01
    13a8:	cb 57       	subi	r28, 0x7B	; 123
    13aa:	d1 40       	sbci	r29, 0x01	; 1
    13ac:	0c 92       	st	X, r0
    13ae:	c5 58       	subi	r28, 0x85	; 133
    13b0:	de 4f       	sbci	r29, 0xFE	; 254
    13b2:	e8 81       	ld	r30, Y
    13b4:	f9 81       	ldd	r31, Y+1	; 0x01
    13b6:	cb 57       	subi	r28, 0x7B	; 123
    13b8:	d1 40       	sbci	r29, 0x01	; 1
    13ba:	31 96       	adiw	r30, 0x01	; 1
    13bc:	c5 58       	subi	r28, 0x85	; 133
    13be:	de 4f       	sbci	r29, 0xFE	; 254
    13c0:	f9 83       	std	Y+1, r31	; 0x01
    13c2:	e8 83       	st	Y, r30
    13c4:	cb 57       	subi	r28, 0x7B	; 123
    13c6:	d1 40       	sbci	r29, 0x01	; 1
    13c8:	c1 58       	subi	r28, 0x81	; 129
    13ca:	de 4f       	sbci	r29, 0xFE	; 254
    13cc:	f8 81       	ld	r31, Y
    13ce:	cf 57       	subi	r28, 0x7F	; 127
    13d0:	d1 40       	sbci	r29, 0x01	; 1
    13d2:	f1 50       	subi	r31, 0x01	; 1
    13d4:	c1 58       	subi	r28, 0x81	; 129
    13d6:	de 4f       	sbci	r29, 0xFE	; 254
    13d8:	f8 83       	st	Y, r31
    13da:	cf 57       	subi	r28, 0x7F	; 127
    13dc:	d1 40       	sbci	r29, 0x01	; 1
    13de:	c1 58       	subi	r28, 0x81	; 129
    13e0:	de 4f       	sbci	r29, 0xFE	; 254
    13e2:	88 81       	ld	r24, Y
    13e4:	cf 57       	subi	r28, 0x7F	; 127
    13e6:	d1 40       	sbci	r29, 0x01	; 1
    13e8:	88 23       	and	r24, r24
    13ea:	31 f6       	brne	.-116    	; 0x1378 <CheckLogin+0x23c>
    13ec:	1b a2       	std	Y+35, r1	; 0x23
    13ee:	de 01       	movw	r26, r28
    13f0:	94 96       	adiw	r26, 0x24	; 36
    13f2:	c0 58       	subi	r28, 0x80	; 128
    13f4:	de 4f       	sbci	r29, 0xFE	; 254
    13f6:	b9 83       	std	Y+1, r27	; 0x01
    13f8:	a8 83       	st	Y, r26
    13fa:	c0 58       	subi	r28, 0x80	; 128
    13fc:	d1 40       	sbci	r29, 0x01	; 1
    13fe:	e9 eb       	ldi	r30, 0xB9	; 185
    1400:	f0 e0       	ldi	r31, 0x00	; 0
    1402:	ce 57       	subi	r28, 0x7E	; 126
    1404:	de 4f       	sbci	r29, 0xFE	; 254
    1406:	f9 83       	std	Y+1, r31	; 0x01
    1408:	e8 83       	st	Y, r30
    140a:	c2 58       	subi	r28, 0x82	; 130
    140c:	d1 40       	sbci	r29, 0x01	; 1
    140e:	f7 e0       	ldi	r31, 0x07	; 7
    1410:	cc 57       	subi	r28, 0x7C	; 124
    1412:	de 4f       	sbci	r29, 0xFE	; 254
    1414:	f8 83       	st	Y, r31
    1416:	c4 58       	subi	r28, 0x84	; 132
    1418:	d1 40       	sbci	r29, 0x01	; 1
    141a:	ce 57       	subi	r28, 0x7E	; 126
    141c:	de 4f       	sbci	r29, 0xFE	; 254
    141e:	a8 81       	ld	r26, Y
    1420:	b9 81       	ldd	r27, Y+1	; 0x01
    1422:	c2 58       	subi	r28, 0x82	; 130
    1424:	d1 40       	sbci	r29, 0x01	; 1
    1426:	0c 90       	ld	r0, X
    1428:	ce 57       	subi	r28, 0x7E	; 126
    142a:	de 4f       	sbci	r29, 0xFE	; 254
    142c:	e8 81       	ld	r30, Y
    142e:	f9 81       	ldd	r31, Y+1	; 0x01
    1430:	c2 58       	subi	r28, 0x82	; 130
    1432:	d1 40       	sbci	r29, 0x01	; 1
    1434:	31 96       	adiw	r30, 0x01	; 1
    1436:	ce 57       	subi	r28, 0x7E	; 126
    1438:	de 4f       	sbci	r29, 0xFE	; 254
    143a:	f9 83       	std	Y+1, r31	; 0x01
    143c:	e8 83       	st	Y, r30
    143e:	c2 58       	subi	r28, 0x82	; 130
    1440:	d1 40       	sbci	r29, 0x01	; 1
    1442:	c0 58       	subi	r28, 0x80	; 128
    1444:	de 4f       	sbci	r29, 0xFE	; 254
    1446:	a8 81       	ld	r26, Y
    1448:	b9 81       	ldd	r27, Y+1	; 0x01
    144a:	c0 58       	subi	r28, 0x80	; 128
    144c:	d1 40       	sbci	r29, 0x01	; 1
    144e:	0c 92       	st	X, r0
    1450:	c0 58       	subi	r28, 0x80	; 128
    1452:	de 4f       	sbci	r29, 0xFE	; 254
    1454:	e8 81       	ld	r30, Y
    1456:	f9 81       	ldd	r31, Y+1	; 0x01
    1458:	c0 58       	subi	r28, 0x80	; 128
    145a:	d1 40       	sbci	r29, 0x01	; 1
    145c:	31 96       	adiw	r30, 0x01	; 1
    145e:	c0 58       	subi	r28, 0x80	; 128
    1460:	de 4f       	sbci	r29, 0xFE	; 254
    1462:	f9 83       	std	Y+1, r31	; 0x01
    1464:	e8 83       	st	Y, r30
    1466:	c0 58       	subi	r28, 0x80	; 128
    1468:	d1 40       	sbci	r29, 0x01	; 1
    146a:	cc 57       	subi	r28, 0x7C	; 124
    146c:	de 4f       	sbci	r29, 0xFE	; 254
    146e:	f8 81       	ld	r31, Y
    1470:	c4 58       	subi	r28, 0x84	; 132
    1472:	d1 40       	sbci	r29, 0x01	; 1
    1474:	f1 50       	subi	r31, 0x01	; 1
    1476:	cc 57       	subi	r28, 0x7C	; 124
    1478:	de 4f       	sbci	r29, 0xFE	; 254
    147a:	f8 83       	st	Y, r31
    147c:	c4 58       	subi	r28, 0x84	; 132
    147e:	d1 40       	sbci	r29, 0x01	; 1
    1480:	cc 57       	subi	r28, 0x7C	; 124
    1482:	de 4f       	sbci	r29, 0xFE	; 254
    1484:	88 81       	ld	r24, Y
    1486:	c4 58       	subi	r28, 0x84	; 132
    1488:	d1 40       	sbci	r29, 0x01	; 1
    148a:	88 23       	and	r24, r24
    148c:	31 f6       	brne	.-116    	; 0x141a <CheckLogin+0x2de>
    148e:	1b a6       	std	Y+43, r1	; 0x2b
    1490:	de 01       	movw	r26, r28
    1492:	9c 96       	adiw	r26, 0x2c	; 44
    1494:	cb 57       	subi	r28, 0x7B	; 123
    1496:	de 4f       	sbci	r29, 0xFE	; 254
    1498:	b9 83       	std	Y+1, r27	; 0x01
    149a:	a8 83       	st	Y, r26
    149c:	c5 58       	subi	r28, 0x85	; 133
    149e:	d1 40       	sbci	r29, 0x01	; 1
    14a0:	e1 ec       	ldi	r30, 0xC1	; 193
    14a2:	f0 e0       	ldi	r31, 0x00	; 0
    14a4:	c9 57       	subi	r28, 0x79	; 121
    14a6:	de 4f       	sbci	r29, 0xFE	; 254
    14a8:	f9 83       	std	Y+1, r31	; 0x01
    14aa:	e8 83       	st	Y, r30
    14ac:	c7 58       	subi	r28, 0x87	; 135
    14ae:	d1 40       	sbci	r29, 0x01	; 1
    14b0:	f7 e0       	ldi	r31, 0x07	; 7
    14b2:	c7 57       	subi	r28, 0x77	; 119
    14b4:	de 4f       	sbci	r29, 0xFE	; 254
    14b6:	f8 83       	st	Y, r31
    14b8:	c9 58       	subi	r28, 0x89	; 137
    14ba:	d1 40       	sbci	r29, 0x01	; 1
    14bc:	c9 57       	subi	r28, 0x79	; 121
    14be:	de 4f       	sbci	r29, 0xFE	; 254
    14c0:	a8 81       	ld	r26, Y
    14c2:	b9 81       	ldd	r27, Y+1	; 0x01
    14c4:	c7 58       	subi	r28, 0x87	; 135
    14c6:	d1 40       	sbci	r29, 0x01	; 1
    14c8:	0c 90       	ld	r0, X
    14ca:	c9 57       	subi	r28, 0x79	; 121
    14cc:	de 4f       	sbci	r29, 0xFE	; 254
    14ce:	e8 81       	ld	r30, Y
    14d0:	f9 81       	ldd	r31, Y+1	; 0x01
    14d2:	c7 58       	subi	r28, 0x87	; 135
    14d4:	d1 40       	sbci	r29, 0x01	; 1
    14d6:	31 96       	adiw	r30, 0x01	; 1
    14d8:	c9 57       	subi	r28, 0x79	; 121
    14da:	de 4f       	sbci	r29, 0xFE	; 254
    14dc:	f9 83       	std	Y+1, r31	; 0x01
    14de:	e8 83       	st	Y, r30
    14e0:	c7 58       	subi	r28, 0x87	; 135
    14e2:	d1 40       	sbci	r29, 0x01	; 1
    14e4:	cb 57       	subi	r28, 0x7B	; 123
    14e6:	de 4f       	sbci	r29, 0xFE	; 254
    14e8:	a8 81       	ld	r26, Y
    14ea:	b9 81       	ldd	r27, Y+1	; 0x01
    14ec:	c5 58       	subi	r28, 0x85	; 133
    14ee:	d1 40       	sbci	r29, 0x01	; 1
    14f0:	0c 92       	st	X, r0
    14f2:	cb 57       	subi	r28, 0x7B	; 123
    14f4:	de 4f       	sbci	r29, 0xFE	; 254
    14f6:	e8 81       	ld	r30, Y
    14f8:	f9 81       	ldd	r31, Y+1	; 0x01
    14fa:	c5 58       	subi	r28, 0x85	; 133
    14fc:	d1 40       	sbci	r29, 0x01	; 1
    14fe:	31 96       	adiw	r30, 0x01	; 1
    1500:	cb 57       	subi	r28, 0x7B	; 123
    1502:	de 4f       	sbci	r29, 0xFE	; 254
    1504:	f9 83       	std	Y+1, r31	; 0x01
    1506:	e8 83       	st	Y, r30
    1508:	c5 58       	subi	r28, 0x85	; 133
    150a:	d1 40       	sbci	r29, 0x01	; 1
    150c:	c7 57       	subi	r28, 0x77	; 119
    150e:	de 4f       	sbci	r29, 0xFE	; 254
    1510:	f8 81       	ld	r31, Y
    1512:	c9 58       	subi	r28, 0x89	; 137
    1514:	d1 40       	sbci	r29, 0x01	; 1
    1516:	f1 50       	subi	r31, 0x01	; 1
    1518:	c7 57       	subi	r28, 0x77	; 119
    151a:	de 4f       	sbci	r29, 0xFE	; 254
    151c:	f8 83       	st	Y, r31
    151e:	c9 58       	subi	r28, 0x89	; 137
    1520:	d1 40       	sbci	r29, 0x01	; 1
    1522:	c7 57       	subi	r28, 0x77	; 119
    1524:	de 4f       	sbci	r29, 0xFE	; 254
    1526:	88 81       	ld	r24, Y
    1528:	c9 58       	subi	r28, 0x89	; 137
    152a:	d1 40       	sbci	r29, 0x01	; 1
    152c:	88 23       	and	r24, r24
    152e:	31 f6       	brne	.-116    	; 0x14bc <CheckLogin+0x380>
    1530:	1b aa       	std	Y+51, r1	; 0x33
    1532:	de 01       	movw	r26, r28
    1534:	d4 96       	adiw	r26, 0x34	; 52
    1536:	c6 57       	subi	r28, 0x76	; 118
    1538:	de 4f       	sbci	r29, 0xFE	; 254
    153a:	b9 83       	std	Y+1, r27	; 0x01
    153c:	a8 83       	st	Y, r26
    153e:	ca 58       	subi	r28, 0x8A	; 138
    1540:	d1 40       	sbci	r29, 0x01	; 1
    1542:	e9 ec       	ldi	r30, 0xC9	; 201
    1544:	f0 e0       	ldi	r31, 0x00	; 0
    1546:	c4 57       	subi	r28, 0x74	; 116
    1548:	de 4f       	sbci	r29, 0xFE	; 254
    154a:	f9 83       	std	Y+1, r31	; 0x01
    154c:	e8 83       	st	Y, r30
    154e:	cc 58       	subi	r28, 0x8C	; 140
    1550:	d1 40       	sbci	r29, 0x01	; 1
    1552:	f7 e0       	ldi	r31, 0x07	; 7
    1554:	c2 57       	subi	r28, 0x72	; 114
    1556:	de 4f       	sbci	r29, 0xFE	; 254
    1558:	f8 83       	st	Y, r31
    155a:	ce 58       	subi	r28, 0x8E	; 142
    155c:	d1 40       	sbci	r29, 0x01	; 1
    155e:	c4 57       	subi	r28, 0x74	; 116
    1560:	de 4f       	sbci	r29, 0xFE	; 254
    1562:	a8 81       	ld	r26, Y
    1564:	b9 81       	ldd	r27, Y+1	; 0x01
    1566:	cc 58       	subi	r28, 0x8C	; 140
    1568:	d1 40       	sbci	r29, 0x01	; 1
    156a:	0c 90       	ld	r0, X
    156c:	c4 57       	subi	r28, 0x74	; 116
    156e:	de 4f       	sbci	r29, 0xFE	; 254
    1570:	e8 81       	ld	r30, Y
    1572:	f9 81       	ldd	r31, Y+1	; 0x01
    1574:	cc 58       	subi	r28, 0x8C	; 140
    1576:	d1 40       	sbci	r29, 0x01	; 1
    1578:	31 96       	adiw	r30, 0x01	; 1
    157a:	c4 57       	subi	r28, 0x74	; 116
    157c:	de 4f       	sbci	r29, 0xFE	; 254
    157e:	f9 83       	std	Y+1, r31	; 0x01
    1580:	e8 83       	st	Y, r30
    1582:	cc 58       	subi	r28, 0x8C	; 140
    1584:	d1 40       	sbci	r29, 0x01	; 1
    1586:	c6 57       	subi	r28, 0x76	; 118
    1588:	de 4f       	sbci	r29, 0xFE	; 254
    158a:	a8 81       	ld	r26, Y
    158c:	b9 81       	ldd	r27, Y+1	; 0x01
    158e:	ca 58       	subi	r28, 0x8A	; 138
    1590:	d1 40       	sbci	r29, 0x01	; 1
    1592:	0c 92       	st	X, r0
    1594:	c6 57       	subi	r28, 0x76	; 118
    1596:	de 4f       	sbci	r29, 0xFE	; 254
    1598:	e8 81       	ld	r30, Y
    159a:	f9 81       	ldd	r31, Y+1	; 0x01
    159c:	ca 58       	subi	r28, 0x8A	; 138
    159e:	d1 40       	sbci	r29, 0x01	; 1
    15a0:	31 96       	adiw	r30, 0x01	; 1
    15a2:	c6 57       	subi	r28, 0x76	; 118
    15a4:	de 4f       	sbci	r29, 0xFE	; 254
    15a6:	f9 83       	std	Y+1, r31	; 0x01
    15a8:	e8 83       	st	Y, r30
    15aa:	ca 58       	subi	r28, 0x8A	; 138
    15ac:	d1 40       	sbci	r29, 0x01	; 1
    15ae:	c2 57       	subi	r28, 0x72	; 114
    15b0:	de 4f       	sbci	r29, 0xFE	; 254
    15b2:	f8 81       	ld	r31, Y
    15b4:	ce 58       	subi	r28, 0x8E	; 142
    15b6:	d1 40       	sbci	r29, 0x01	; 1
    15b8:	f1 50       	subi	r31, 0x01	; 1
    15ba:	c2 57       	subi	r28, 0x72	; 114
    15bc:	de 4f       	sbci	r29, 0xFE	; 254
    15be:	f8 83       	st	Y, r31
    15c0:	ce 58       	subi	r28, 0x8E	; 142
    15c2:	d1 40       	sbci	r29, 0x01	; 1
    15c4:	c2 57       	subi	r28, 0x72	; 114
    15c6:	de 4f       	sbci	r29, 0xFE	; 254
    15c8:	88 81       	ld	r24, Y
    15ca:	ce 58       	subi	r28, 0x8E	; 142
    15cc:	d1 40       	sbci	r29, 0x01	; 1
    15ce:	88 23       	and	r24, r24
    15d0:	31 f6       	brne	.-116    	; 0x155e <CheckLogin+0x422>
    15d2:	1b ae       	std	Y+59, r1	; 0x3b
    15d4:	de 01       	movw	r26, r28
    15d6:	dc 96       	adiw	r26, 0x3c	; 60
    15d8:	c1 57       	subi	r28, 0x71	; 113
    15da:	de 4f       	sbci	r29, 0xFE	; 254
    15dc:	b9 83       	std	Y+1, r27	; 0x01
    15de:	a8 83       	st	Y, r26
    15e0:	cf 58       	subi	r28, 0x8F	; 143
    15e2:	d1 40       	sbci	r29, 0x01	; 1
    15e4:	e1 ed       	ldi	r30, 0xD1	; 209
    15e6:	f0 e0       	ldi	r31, 0x00	; 0
    15e8:	cf 56       	subi	r28, 0x6F	; 111
    15ea:	de 4f       	sbci	r29, 0xFE	; 254
    15ec:	f9 83       	std	Y+1, r31	; 0x01
    15ee:	e8 83       	st	Y, r30
    15f0:	c1 59       	subi	r28, 0x91	; 145
    15f2:	d1 40       	sbci	r29, 0x01	; 1
    15f4:	f7 e0       	ldi	r31, 0x07	; 7
    15f6:	cd 56       	subi	r28, 0x6D	; 109
    15f8:	de 4f       	sbci	r29, 0xFE	; 254
    15fa:	f8 83       	st	Y, r31
    15fc:	c3 59       	subi	r28, 0x93	; 147
    15fe:	d1 40       	sbci	r29, 0x01	; 1
    1600:	cf 56       	subi	r28, 0x6F	; 111
    1602:	de 4f       	sbci	r29, 0xFE	; 254
    1604:	a8 81       	ld	r26, Y
    1606:	b9 81       	ldd	r27, Y+1	; 0x01
    1608:	c1 59       	subi	r28, 0x91	; 145
    160a:	d1 40       	sbci	r29, 0x01	; 1
    160c:	0c 90       	ld	r0, X
    160e:	cf 56       	subi	r28, 0x6F	; 111
    1610:	de 4f       	sbci	r29, 0xFE	; 254
    1612:	e8 81       	ld	r30, Y
    1614:	f9 81       	ldd	r31, Y+1	; 0x01
    1616:	c1 59       	subi	r28, 0x91	; 145
    1618:	d1 40       	sbci	r29, 0x01	; 1
    161a:	31 96       	adiw	r30, 0x01	; 1
    161c:	cf 56       	subi	r28, 0x6F	; 111
    161e:	de 4f       	sbci	r29, 0xFE	; 254
    1620:	f9 83       	std	Y+1, r31	; 0x01
    1622:	e8 83       	st	Y, r30
    1624:	c1 59       	subi	r28, 0x91	; 145
    1626:	d1 40       	sbci	r29, 0x01	; 1
    1628:	c1 57       	subi	r28, 0x71	; 113
    162a:	de 4f       	sbci	r29, 0xFE	; 254
    162c:	a8 81       	ld	r26, Y
    162e:	b9 81       	ldd	r27, Y+1	; 0x01
    1630:	cf 58       	subi	r28, 0x8F	; 143
    1632:	d1 40       	sbci	r29, 0x01	; 1
    1634:	0c 92       	st	X, r0
    1636:	c1 57       	subi	r28, 0x71	; 113
    1638:	de 4f       	sbci	r29, 0xFE	; 254
    163a:	e8 81       	ld	r30, Y
    163c:	f9 81       	ldd	r31, Y+1	; 0x01
    163e:	cf 58       	subi	r28, 0x8F	; 143
    1640:	d1 40       	sbci	r29, 0x01	; 1
    1642:	31 96       	adiw	r30, 0x01	; 1
    1644:	c1 57       	subi	r28, 0x71	; 113
    1646:	de 4f       	sbci	r29, 0xFE	; 254
    1648:	f9 83       	std	Y+1, r31	; 0x01
    164a:	e8 83       	st	Y, r30
    164c:	cf 58       	subi	r28, 0x8F	; 143
    164e:	d1 40       	sbci	r29, 0x01	; 1
    1650:	cd 56       	subi	r28, 0x6D	; 109
    1652:	de 4f       	sbci	r29, 0xFE	; 254
    1654:	f8 81       	ld	r31, Y
    1656:	c3 59       	subi	r28, 0x93	; 147
    1658:	d1 40       	sbci	r29, 0x01	; 1
    165a:	f1 50       	subi	r31, 0x01	; 1
    165c:	cd 56       	subi	r28, 0x6D	; 109
    165e:	de 4f       	sbci	r29, 0xFE	; 254
    1660:	f8 83       	st	Y, r31
    1662:	c3 59       	subi	r28, 0x93	; 147
    1664:	d1 40       	sbci	r29, 0x01	; 1
    1666:	cd 56       	subi	r28, 0x6D	; 109
    1668:	de 4f       	sbci	r29, 0xFE	; 254
    166a:	88 81       	ld	r24, Y
    166c:	c3 59       	subi	r28, 0x93	; 147
    166e:	d1 40       	sbci	r29, 0x01	; 1
    1670:	88 23       	and	r24, r24
    1672:	31 f6       	brne	.-116    	; 0x1600 <CheckLogin+0x4c4>
    1674:	fe 01       	movw	r30, r28
    1676:	ed 5b       	subi	r30, 0xBD	; 189
    1678:	ff 4f       	sbci	r31, 0xFF	; 255
    167a:	10 82       	st	Z, r1
    167c:	de 01       	movw	r26, r28
    167e:	ac 5b       	subi	r26, 0xBC	; 188
    1680:	bf 4f       	sbci	r27, 0xFF	; 255
    1682:	cc 56       	subi	r28, 0x6C	; 108
    1684:	de 4f       	sbci	r29, 0xFE	; 254
    1686:	b9 83       	std	Y+1, r27	; 0x01
    1688:	a8 83       	st	Y, r26
    168a:	c4 59       	subi	r28, 0x94	; 148
    168c:	d1 40       	sbci	r29, 0x01	; 1
    168e:	cc 56       	subi	r28, 0x6C	; 108
    1690:	de 4f       	sbci	r29, 0xFE	; 254
    1692:	e8 81       	ld	r30, Y
    1694:	f9 81       	ldd	r31, Y+1	; 0x01
    1696:	c4 59       	subi	r28, 0x94	; 148
    1698:	d1 40       	sbci	r29, 0x01	; 1
    169a:	ca 56       	subi	r28, 0x6A	; 106
    169c:	de 4f       	sbci	r29, 0xFE	; 254
    169e:	f9 83       	std	Y+1, r31	; 0x01
    16a0:	e8 83       	st	Y, r30
    16a2:	c6 59       	subi	r28, 0x96	; 150
    16a4:	d1 40       	sbci	r29, 0x01	; 1
    16a6:	89 ed       	ldi	r24, 0xD9	; 217
    16a8:	90 e0       	ldi	r25, 0x00	; 0
    16aa:	c8 56       	subi	r28, 0x68	; 104
    16ac:	de 4f       	sbci	r29, 0xFE	; 254
    16ae:	99 83       	std	Y+1, r25	; 0x01
    16b0:	88 83       	st	Y, r24
    16b2:	c8 59       	subi	r28, 0x98	; 152
    16b4:	d1 40       	sbci	r29, 0x01	; 1
    16b6:	97 e0       	ldi	r25, 0x07	; 7
    16b8:	c6 56       	subi	r28, 0x66	; 102
    16ba:	de 4f       	sbci	r29, 0xFE	; 254
    16bc:	98 83       	st	Y, r25
    16be:	ca 59       	subi	r28, 0x9A	; 154
    16c0:	d1 40       	sbci	r29, 0x01	; 1
    16c2:	c8 56       	subi	r28, 0x68	; 104
    16c4:	de 4f       	sbci	r29, 0xFE	; 254
    16c6:	a8 81       	ld	r26, Y
    16c8:	b9 81       	ldd	r27, Y+1	; 0x01
    16ca:	c8 59       	subi	r28, 0x98	; 152
    16cc:	d1 40       	sbci	r29, 0x01	; 1
    16ce:	0c 90       	ld	r0, X
    16d0:	c8 56       	subi	r28, 0x68	; 104
    16d2:	de 4f       	sbci	r29, 0xFE	; 254
    16d4:	e8 81       	ld	r30, Y
    16d6:	f9 81       	ldd	r31, Y+1	; 0x01
    16d8:	c8 59       	subi	r28, 0x98	; 152
    16da:	d1 40       	sbci	r29, 0x01	; 1
    16dc:	31 96       	adiw	r30, 0x01	; 1
    16de:	c8 56       	subi	r28, 0x68	; 104
    16e0:	de 4f       	sbci	r29, 0xFE	; 254
    16e2:	f9 83       	std	Y+1, r31	; 0x01
    16e4:	e8 83       	st	Y, r30
    16e6:	c8 59       	subi	r28, 0x98	; 152
    16e8:	d1 40       	sbci	r29, 0x01	; 1
    16ea:	ca 56       	subi	r28, 0x6A	; 106
    16ec:	de 4f       	sbci	r29, 0xFE	; 254
    16ee:	a8 81       	ld	r26, Y
    16f0:	b9 81       	ldd	r27, Y+1	; 0x01
    16f2:	c6 59       	subi	r28, 0x96	; 150
    16f4:	d1 40       	sbci	r29, 0x01	; 1
    16f6:	0c 92       	st	X, r0
    16f8:	ca 56       	subi	r28, 0x6A	; 106
    16fa:	de 4f       	sbci	r29, 0xFE	; 254
    16fc:	e8 81       	ld	r30, Y
    16fe:	f9 81       	ldd	r31, Y+1	; 0x01
    1700:	c6 59       	subi	r28, 0x96	; 150
    1702:	d1 40       	sbci	r29, 0x01	; 1
    1704:	31 96       	adiw	r30, 0x01	; 1
    1706:	ca 56       	subi	r28, 0x6A	; 106
    1708:	de 4f       	sbci	r29, 0xFE	; 254
    170a:	f9 83       	std	Y+1, r31	; 0x01
    170c:	e8 83       	st	Y, r30
    170e:	c6 59       	subi	r28, 0x96	; 150
    1710:	d1 40       	sbci	r29, 0x01	; 1
    1712:	c6 56       	subi	r28, 0x66	; 102
    1714:	de 4f       	sbci	r29, 0xFE	; 254
    1716:	f8 81       	ld	r31, Y
    1718:	ca 59       	subi	r28, 0x9A	; 154
    171a:	d1 40       	sbci	r29, 0x01	; 1
    171c:	f1 50       	subi	r31, 0x01	; 1
    171e:	c6 56       	subi	r28, 0x66	; 102
    1720:	de 4f       	sbci	r29, 0xFE	; 254
    1722:	f8 83       	st	Y, r31
    1724:	ca 59       	subi	r28, 0x9A	; 154
    1726:	d1 40       	sbci	r29, 0x01	; 1
    1728:	c6 56       	subi	r28, 0x66	; 102
    172a:	de 4f       	sbci	r29, 0xFE	; 254
    172c:	88 81       	ld	r24, Y
    172e:	ca 59       	subi	r28, 0x9A	; 154
    1730:	d1 40       	sbci	r29, 0x01	; 1
    1732:	88 23       	and	r24, r24
    1734:	31 f6       	brne	.-116    	; 0x16c2 <CheckLogin+0x586>
    1736:	cc 56       	subi	r28, 0x6C	; 108
    1738:	de 4f       	sbci	r29, 0xFE	; 254
    173a:	a8 81       	ld	r26, Y
    173c:	b9 81       	ldd	r27, Y+1	; 0x01
    173e:	c4 59       	subi	r28, 0x94	; 148
    1740:	d1 40       	sbci	r29, 0x01	; 1
    1742:	17 96       	adiw	r26, 0x07	; 7
    1744:	1c 92       	st	X, r1
    1746:	ce 01       	movw	r24, r28
    1748:	84 5b       	subi	r24, 0xB4	; 180
    174a:	9f 4f       	sbci	r25, 0xFF	; 255
    174c:	c5 56       	subi	r28, 0x65	; 101
    174e:	de 4f       	sbci	r29, 0xFE	; 254
    1750:	99 83       	std	Y+1, r25	; 0x01
    1752:	88 83       	st	Y, r24
    1754:	cb 59       	subi	r28, 0x9B	; 155
    1756:	d1 40       	sbci	r29, 0x01	; 1
    1758:	e1 ee       	ldi	r30, 0xE1	; 225
    175a:	f0 e0       	ldi	r31, 0x00	; 0
    175c:	c3 56       	subi	r28, 0x63	; 99
    175e:	de 4f       	sbci	r29, 0xFE	; 254
    1760:	f9 83       	std	Y+1, r31	; 0x01
    1762:	e8 83       	st	Y, r30
    1764:	cd 59       	subi	r28, 0x9D	; 157
    1766:	d1 40       	sbci	r29, 0x01	; 1
    1768:	f8 e0       	ldi	r31, 0x08	; 8
    176a:	c1 56       	subi	r28, 0x61	; 97
    176c:	de 4f       	sbci	r29, 0xFE	; 254
    176e:	f8 83       	st	Y, r31
    1770:	cf 59       	subi	r28, 0x9F	; 159
    1772:	d1 40       	sbci	r29, 0x01	; 1
    1774:	c3 56       	subi	r28, 0x63	; 99
    1776:	de 4f       	sbci	r29, 0xFE	; 254
    1778:	a8 81       	ld	r26, Y
    177a:	b9 81       	ldd	r27, Y+1	; 0x01
    177c:	cd 59       	subi	r28, 0x9D	; 157
    177e:	d1 40       	sbci	r29, 0x01	; 1
    1780:	0c 90       	ld	r0, X
    1782:	c3 56       	subi	r28, 0x63	; 99
    1784:	de 4f       	sbci	r29, 0xFE	; 254
    1786:	e8 81       	ld	r30, Y
    1788:	f9 81       	ldd	r31, Y+1	; 0x01
    178a:	cd 59       	subi	r28, 0x9D	; 157
    178c:	d1 40       	sbci	r29, 0x01	; 1
    178e:	31 96       	adiw	r30, 0x01	; 1
    1790:	c3 56       	subi	r28, 0x63	; 99
    1792:	de 4f       	sbci	r29, 0xFE	; 254
    1794:	f9 83       	std	Y+1, r31	; 0x01
    1796:	e8 83       	st	Y, r30
    1798:	cd 59       	subi	r28, 0x9D	; 157
    179a:	d1 40       	sbci	r29, 0x01	; 1
    179c:	c5 56       	subi	r28, 0x65	; 101
    179e:	de 4f       	sbci	r29, 0xFE	; 254
    17a0:	a8 81       	ld	r26, Y
    17a2:	b9 81       	ldd	r27, Y+1	; 0x01
    17a4:	cb 59       	subi	r28, 0x9B	; 155
    17a6:	d1 40       	sbci	r29, 0x01	; 1
    17a8:	0c 92       	st	X, r0
    17aa:	c5 56       	subi	r28, 0x65	; 101
    17ac:	de 4f       	sbci	r29, 0xFE	; 254
    17ae:	e8 81       	ld	r30, Y
    17b0:	f9 81       	ldd	r31, Y+1	; 0x01
    17b2:	cb 59       	subi	r28, 0x9B	; 155
    17b4:	d1 40       	sbci	r29, 0x01	; 1
    17b6:	31 96       	adiw	r30, 0x01	; 1
    17b8:	c5 56       	subi	r28, 0x65	; 101
    17ba:	de 4f       	sbci	r29, 0xFE	; 254
    17bc:	f9 83       	std	Y+1, r31	; 0x01
    17be:	e8 83       	st	Y, r30
    17c0:	cb 59       	subi	r28, 0x9B	; 155
    17c2:	d1 40       	sbci	r29, 0x01	; 1
    17c4:	c1 56       	subi	r28, 0x61	; 97
    17c6:	de 4f       	sbci	r29, 0xFE	; 254
    17c8:	f8 81       	ld	r31, Y
    17ca:	cf 59       	subi	r28, 0x9F	; 159
    17cc:	d1 40       	sbci	r29, 0x01	; 1
    17ce:	f1 50       	subi	r31, 0x01	; 1
    17d0:	c1 56       	subi	r28, 0x61	; 97
    17d2:	de 4f       	sbci	r29, 0xFE	; 254
    17d4:	f8 83       	st	Y, r31
    17d6:	cf 59       	subi	r28, 0x9F	; 159
    17d8:	d1 40       	sbci	r29, 0x01	; 1
    17da:	c1 56       	subi	r28, 0x61	; 97
    17dc:	de 4f       	sbci	r29, 0xFE	; 254
    17de:	88 81       	ld	r24, Y
    17e0:	cf 59       	subi	r28, 0x9F	; 159
    17e2:	d1 40       	sbci	r29, 0x01	; 1
    17e4:	88 23       	and	r24, r24
    17e6:	31 f6       	brne	.-116    	; 0x1774 <CheckLogin+0x638>
     char password[10][8] = { "test1\r", "test2\r", "test3\r", "test4\r",
			"test5\r", "test6\r", "test7\r", "test8\r", "test9\r", "test10\r" };
    17e8:	ce 01       	movw	r24, r28
    17ea:	8c 5a       	subi	r24, 0xAC	; 172
    17ec:	9f 4f       	sbci	r25, 0xFF	; 255
    17ee:	20 e5       	ldi	r18, 0x50	; 80
    17f0:	fc 01       	movw	r30, r24
    17f2:	df 01       	movw	r26, r30
    17f4:	82 2f       	mov	r24, r18
    17f6:	1d 92       	st	X+, r1
    17f8:	8a 95       	dec	r24
    17fa:	e9 f7       	brne	.-6      	; 0x17f6 <CheckLogin+0x6ba>
    17fc:	de 01       	movw	r26, r28
    17fe:	ac 5a       	subi	r26, 0xAC	; 172
    1800:	bf 4f       	sbci	r27, 0xFF	; 255
    1802:	c0 56       	subi	r28, 0x60	; 96
    1804:	de 4f       	sbci	r29, 0xFE	; 254
    1806:	b9 83       	std	Y+1, r27	; 0x01
    1808:	a8 83       	st	Y, r26
    180a:	c0 5a       	subi	r28, 0xA0	; 160
    180c:	d1 40       	sbci	r29, 0x01	; 1
    180e:	c0 56       	subi	r28, 0x60	; 96
    1810:	de 4f       	sbci	r29, 0xFE	; 254
    1812:	e8 81       	ld	r30, Y
    1814:	f9 81       	ldd	r31, Y+1	; 0x01
    1816:	c0 5a       	subi	r28, 0xA0	; 160
    1818:	d1 40       	sbci	r29, 0x01	; 1
    181a:	ce 55       	subi	r28, 0x5E	; 94
    181c:	de 4f       	sbci	r29, 0xFE	; 254
    181e:	f9 83       	std	Y+1, r31	; 0x01
    1820:	e8 83       	st	Y, r30
    1822:	c2 5a       	subi	r28, 0xA2	; 162
    1824:	d1 40       	sbci	r29, 0x01	; 1
    1826:	89 e9       	ldi	r24, 0x99	; 153
    1828:	90 e0       	ldi	r25, 0x00	; 0
    182a:	cc 55       	subi	r28, 0x5C	; 92
    182c:	de 4f       	sbci	r29, 0xFE	; 254
    182e:	99 83       	std	Y+1, r25	; 0x01
    1830:	88 83       	st	Y, r24
    1832:	c4 5a       	subi	r28, 0xA4	; 164
    1834:	d1 40       	sbci	r29, 0x01	; 1
    1836:	97 e0       	ldi	r25, 0x07	; 7
    1838:	ca 55       	subi	r28, 0x5A	; 90
    183a:	de 4f       	sbci	r29, 0xFE	; 254
    183c:	98 83       	st	Y, r25
    183e:	c6 5a       	subi	r28, 0xA6	; 166
    1840:	d1 40       	sbci	r29, 0x01	; 1
    1842:	cc 55       	subi	r28, 0x5C	; 92
    1844:	de 4f       	sbci	r29, 0xFE	; 254
    1846:	a8 81       	ld	r26, Y
    1848:	b9 81       	ldd	r27, Y+1	; 0x01
    184a:	c4 5a       	subi	r28, 0xA4	; 164
    184c:	d1 40       	sbci	r29, 0x01	; 1
    184e:	0c 90       	ld	r0, X
    1850:	cc 55       	subi	r28, 0x5C	; 92
    1852:	de 4f       	sbci	r29, 0xFE	; 254
    1854:	e8 81       	ld	r30, Y
    1856:	f9 81       	ldd	r31, Y+1	; 0x01
    1858:	c4 5a       	subi	r28, 0xA4	; 164
    185a:	d1 40       	sbci	r29, 0x01	; 1
    185c:	31 96       	adiw	r30, 0x01	; 1
    185e:	cc 55       	subi	r28, 0x5C	; 92
    1860:	de 4f       	sbci	r29, 0xFE	; 254
    1862:	f9 83       	std	Y+1, r31	; 0x01
    1864:	e8 83       	st	Y, r30
    1866:	c4 5a       	subi	r28, 0xA4	; 164
    1868:	d1 40       	sbci	r29, 0x01	; 1
    186a:	ce 55       	subi	r28, 0x5E	; 94
    186c:	de 4f       	sbci	r29, 0xFE	; 254
    186e:	a8 81       	ld	r26, Y
    1870:	b9 81       	ldd	r27, Y+1	; 0x01
    1872:	c2 5a       	subi	r28, 0xA2	; 162
    1874:	d1 40       	sbci	r29, 0x01	; 1
    1876:	0c 92       	st	X, r0
    1878:	ce 55       	subi	r28, 0x5E	; 94
    187a:	de 4f       	sbci	r29, 0xFE	; 254
    187c:	e8 81       	ld	r30, Y
    187e:	f9 81       	ldd	r31, Y+1	; 0x01
    1880:	c2 5a       	subi	r28, 0xA2	; 162
    1882:	d1 40       	sbci	r29, 0x01	; 1
    1884:	31 96       	adiw	r30, 0x01	; 1
    1886:	ce 55       	subi	r28, 0x5E	; 94
    1888:	de 4f       	sbci	r29, 0xFE	; 254
    188a:	f9 83       	std	Y+1, r31	; 0x01
    188c:	e8 83       	st	Y, r30
    188e:	c2 5a       	subi	r28, 0xA2	; 162
    1890:	d1 40       	sbci	r29, 0x01	; 1
    1892:	ca 55       	subi	r28, 0x5A	; 90
    1894:	de 4f       	sbci	r29, 0xFE	; 254
    1896:	f8 81       	ld	r31, Y
    1898:	c6 5a       	subi	r28, 0xA6	; 166
    189a:	d1 40       	sbci	r29, 0x01	; 1
    189c:	f1 50       	subi	r31, 0x01	; 1
    189e:	ca 55       	subi	r28, 0x5A	; 90
    18a0:	de 4f       	sbci	r29, 0xFE	; 254
    18a2:	f8 83       	st	Y, r31
    18a4:	c6 5a       	subi	r28, 0xA6	; 166
    18a6:	d1 40       	sbci	r29, 0x01	; 1
    18a8:	ca 55       	subi	r28, 0x5A	; 90
    18aa:	de 4f       	sbci	r29, 0xFE	; 254
    18ac:	88 81       	ld	r24, Y
    18ae:	c6 5a       	subi	r28, 0xA6	; 166
    18b0:	d1 40       	sbci	r29, 0x01	; 1
    18b2:	88 23       	and	r24, r24
    18b4:	31 f6       	brne	.-116    	; 0x1842 <CheckLogin+0x706>
    18b6:	c0 56       	subi	r28, 0x60	; 96
    18b8:	de 4f       	sbci	r29, 0xFE	; 254
    18ba:	a8 81       	ld	r26, Y
    18bc:	b9 81       	ldd	r27, Y+1	; 0x01
    18be:	c0 5a       	subi	r28, 0xA0	; 160
    18c0:	d1 40       	sbci	r29, 0x01	; 1
    18c2:	17 96       	adiw	r26, 0x07	; 7
    18c4:	1c 92       	st	X, r1
    18c6:	fe 01       	movw	r30, r28
    18c8:	ec 5a       	subi	r30, 0xAC	; 172
    18ca:	ff 4f       	sbci	r31, 0xFF	; 255
    18cc:	c9 55       	subi	r28, 0x59	; 89
    18ce:	de 4f       	sbci	r29, 0xFE	; 254
    18d0:	f9 83       	std	Y+1, r31	; 0x01
    18d2:	e8 83       	st	Y, r30
    18d4:	c7 5a       	subi	r28, 0xA7	; 167
    18d6:	d1 40       	sbci	r29, 0x01	; 1
    18d8:	c9 55       	subi	r28, 0x59	; 89
    18da:	de 4f       	sbci	r29, 0xFE	; 254
    18dc:	88 81       	ld	r24, Y
    18de:	99 81       	ldd	r25, Y+1	; 0x01
    18e0:	c7 5a       	subi	r28, 0xA7	; 167
    18e2:	d1 40       	sbci	r29, 0x01	; 1
    18e4:	08 96       	adiw	r24, 0x08	; 8
    18e6:	c7 55       	subi	r28, 0x57	; 87
    18e8:	de 4f       	sbci	r29, 0xFE	; 254
    18ea:	99 83       	std	Y+1, r25	; 0x01
    18ec:	88 83       	st	Y, r24
    18ee:	c9 5a       	subi	r28, 0xA9	; 169
    18f0:	d1 40       	sbci	r29, 0x01	; 1
    18f2:	a1 ea       	ldi	r26, 0xA1	; 161
    18f4:	b0 e0       	ldi	r27, 0x00	; 0
    18f6:	c5 55       	subi	r28, 0x55	; 85
    18f8:	de 4f       	sbci	r29, 0xFE	; 254
    18fa:	b9 83       	std	Y+1, r27	; 0x01
    18fc:	a8 83       	st	Y, r26
    18fe:	cb 5a       	subi	r28, 0xAB	; 171
    1900:	d1 40       	sbci	r29, 0x01	; 1
    1902:	b7 e0       	ldi	r27, 0x07	; 7
    1904:	c3 55       	subi	r28, 0x53	; 83
    1906:	de 4f       	sbci	r29, 0xFE	; 254
    1908:	b8 83       	st	Y, r27
    190a:	cd 5a       	subi	r28, 0xAD	; 173
    190c:	d1 40       	sbci	r29, 0x01	; 1
    190e:	c5 55       	subi	r28, 0x55	; 85
    1910:	de 4f       	sbci	r29, 0xFE	; 254
    1912:	e8 81       	ld	r30, Y
    1914:	f9 81       	ldd	r31, Y+1	; 0x01
    1916:	cb 5a       	subi	r28, 0xAB	; 171
    1918:	d1 40       	sbci	r29, 0x01	; 1
    191a:	00 80       	ld	r0, Z
    191c:	c5 55       	subi	r28, 0x55	; 85
    191e:	de 4f       	sbci	r29, 0xFE	; 254
    1920:	88 81       	ld	r24, Y
    1922:	99 81       	ldd	r25, Y+1	; 0x01
    1924:	cb 5a       	subi	r28, 0xAB	; 171
    1926:	d1 40       	sbci	r29, 0x01	; 1
    1928:	01 96       	adiw	r24, 0x01	; 1
    192a:	c5 55       	subi	r28, 0x55	; 85
    192c:	de 4f       	sbci	r29, 0xFE	; 254
    192e:	99 83       	std	Y+1, r25	; 0x01
    1930:	88 83       	st	Y, r24
    1932:	cb 5a       	subi	r28, 0xAB	; 171
    1934:	d1 40       	sbci	r29, 0x01	; 1
    1936:	c7 55       	subi	r28, 0x57	; 87
    1938:	de 4f       	sbci	r29, 0xFE	; 254
    193a:	a8 81       	ld	r26, Y
    193c:	b9 81       	ldd	r27, Y+1	; 0x01
    193e:	c9 5a       	subi	r28, 0xA9	; 169
    1940:	d1 40       	sbci	r29, 0x01	; 1
    1942:	0c 92       	st	X, r0
    1944:	c7 55       	subi	r28, 0x57	; 87
    1946:	de 4f       	sbci	r29, 0xFE	; 254
    1948:	e8 81       	ld	r30, Y
    194a:	f9 81       	ldd	r31, Y+1	; 0x01
    194c:	c9 5a       	subi	r28, 0xA9	; 169
    194e:	d1 40       	sbci	r29, 0x01	; 1
    1950:	31 96       	adiw	r30, 0x01	; 1
    1952:	c7 55       	subi	r28, 0x57	; 87
    1954:	de 4f       	sbci	r29, 0xFE	; 254
    1956:	f9 83       	std	Y+1, r31	; 0x01
    1958:	e8 83       	st	Y, r30
    195a:	c9 5a       	subi	r28, 0xA9	; 169
    195c:	d1 40       	sbci	r29, 0x01	; 1
    195e:	c3 55       	subi	r28, 0x53	; 83
    1960:	de 4f       	sbci	r29, 0xFE	; 254
    1962:	f8 81       	ld	r31, Y
    1964:	cd 5a       	subi	r28, 0xAD	; 173
    1966:	d1 40       	sbci	r29, 0x01	; 1
    1968:	f1 50       	subi	r31, 0x01	; 1
    196a:	c3 55       	subi	r28, 0x53	; 83
    196c:	de 4f       	sbci	r29, 0xFE	; 254
    196e:	f8 83       	st	Y, r31
    1970:	cd 5a       	subi	r28, 0xAD	; 173
    1972:	d1 40       	sbci	r29, 0x01	; 1
    1974:	c3 55       	subi	r28, 0x53	; 83
    1976:	de 4f       	sbci	r29, 0xFE	; 254
    1978:	88 81       	ld	r24, Y
    197a:	cd 5a       	subi	r28, 0xAD	; 173
    197c:	d1 40       	sbci	r29, 0x01	; 1
    197e:	88 23       	and	r24, r24
    1980:	31 f6       	brne	.-116    	; 0x190e <CheckLogin+0x7d2>
    1982:	c9 55       	subi	r28, 0x59	; 89
    1984:	de 4f       	sbci	r29, 0xFE	; 254
    1986:	a8 81       	ld	r26, Y
    1988:	b9 81       	ldd	r27, Y+1	; 0x01
    198a:	c7 5a       	subi	r28, 0xA7	; 167
    198c:	d1 40       	sbci	r29, 0x01	; 1
    198e:	1f 96       	adiw	r26, 0x0f	; 15
    1990:	1c 92       	st	X, r1
    1992:	fe 01       	movw	r30, r28
    1994:	ec 5a       	subi	r30, 0xAC	; 172
    1996:	ff 4f       	sbci	r31, 0xFF	; 255
    1998:	c2 55       	subi	r28, 0x52	; 82
    199a:	de 4f       	sbci	r29, 0xFE	; 254
    199c:	f9 83       	std	Y+1, r31	; 0x01
    199e:	e8 83       	st	Y, r30
    19a0:	ce 5a       	subi	r28, 0xAE	; 174
    19a2:	d1 40       	sbci	r29, 0x01	; 1
    19a4:	c2 55       	subi	r28, 0x52	; 82
    19a6:	de 4f       	sbci	r29, 0xFE	; 254
    19a8:	88 81       	ld	r24, Y
    19aa:	99 81       	ldd	r25, Y+1	; 0x01
    19ac:	ce 5a       	subi	r28, 0xAE	; 174
    19ae:	d1 40       	sbci	r29, 0x01	; 1
    19b0:	40 96       	adiw	r24, 0x10	; 16
    19b2:	c0 55       	subi	r28, 0x50	; 80
    19b4:	de 4f       	sbci	r29, 0xFE	; 254
    19b6:	99 83       	std	Y+1, r25	; 0x01
    19b8:	88 83       	st	Y, r24
    19ba:	c0 5b       	subi	r28, 0xB0	; 176
    19bc:	d1 40       	sbci	r29, 0x01	; 1
    19be:	a9 ea       	ldi	r26, 0xA9	; 169
    19c0:	b0 e0       	ldi	r27, 0x00	; 0
    19c2:	ce 54       	subi	r28, 0x4E	; 78
    19c4:	de 4f       	sbci	r29, 0xFE	; 254
    19c6:	b9 83       	std	Y+1, r27	; 0x01
    19c8:	a8 83       	st	Y, r26
    19ca:	c2 5b       	subi	r28, 0xB2	; 178
    19cc:	d1 40       	sbci	r29, 0x01	; 1
    19ce:	b7 e0       	ldi	r27, 0x07	; 7
    19d0:	cc 54       	subi	r28, 0x4C	; 76
    19d2:	de 4f       	sbci	r29, 0xFE	; 254
    19d4:	b8 83       	st	Y, r27
    19d6:	c4 5b       	subi	r28, 0xB4	; 180
    19d8:	d1 40       	sbci	r29, 0x01	; 1
    19da:	ce 54       	subi	r28, 0x4E	; 78
    19dc:	de 4f       	sbci	r29, 0xFE	; 254
    19de:	e8 81       	ld	r30, Y
    19e0:	f9 81       	ldd	r31, Y+1	; 0x01
    19e2:	c2 5b       	subi	r28, 0xB2	; 178
    19e4:	d1 40       	sbci	r29, 0x01	; 1
    19e6:	00 80       	ld	r0, Z
    19e8:	ce 54       	subi	r28, 0x4E	; 78
    19ea:	de 4f       	sbci	r29, 0xFE	; 254
    19ec:	88 81       	ld	r24, Y
    19ee:	99 81       	ldd	r25, Y+1	; 0x01
    19f0:	c2 5b       	subi	r28, 0xB2	; 178
    19f2:	d1 40       	sbci	r29, 0x01	; 1
    19f4:	01 96       	adiw	r24, 0x01	; 1
    19f6:	ce 54       	subi	r28, 0x4E	; 78
    19f8:	de 4f       	sbci	r29, 0xFE	; 254
    19fa:	99 83       	std	Y+1, r25	; 0x01
    19fc:	88 83       	st	Y, r24
    19fe:	c2 5b       	subi	r28, 0xB2	; 178
    1a00:	d1 40       	sbci	r29, 0x01	; 1
    1a02:	c0 55       	subi	r28, 0x50	; 80
    1a04:	de 4f       	sbci	r29, 0xFE	; 254
    1a06:	a8 81       	ld	r26, Y
    1a08:	b9 81       	ldd	r27, Y+1	; 0x01
    1a0a:	c0 5b       	subi	r28, 0xB0	; 176
    1a0c:	d1 40       	sbci	r29, 0x01	; 1
    1a0e:	0c 92       	st	X, r0
    1a10:	c0 55       	subi	r28, 0x50	; 80
    1a12:	de 4f       	sbci	r29, 0xFE	; 254
    1a14:	e8 81       	ld	r30, Y
    1a16:	f9 81       	ldd	r31, Y+1	; 0x01
    1a18:	c0 5b       	subi	r28, 0xB0	; 176
    1a1a:	d1 40       	sbci	r29, 0x01	; 1
    1a1c:	31 96       	adiw	r30, 0x01	; 1
    1a1e:	c0 55       	subi	r28, 0x50	; 80
    1a20:	de 4f       	sbci	r29, 0xFE	; 254
    1a22:	f9 83       	std	Y+1, r31	; 0x01
    1a24:	e8 83       	st	Y, r30
    1a26:	c0 5b       	subi	r28, 0xB0	; 176
    1a28:	d1 40       	sbci	r29, 0x01	; 1
    1a2a:	cc 54       	subi	r28, 0x4C	; 76
    1a2c:	de 4f       	sbci	r29, 0xFE	; 254
    1a2e:	f8 81       	ld	r31, Y
    1a30:	c4 5b       	subi	r28, 0xB4	; 180
    1a32:	d1 40       	sbci	r29, 0x01	; 1
    1a34:	f1 50       	subi	r31, 0x01	; 1
    1a36:	cc 54       	subi	r28, 0x4C	; 76
    1a38:	de 4f       	sbci	r29, 0xFE	; 254
    1a3a:	f8 83       	st	Y, r31
    1a3c:	c4 5b       	subi	r28, 0xB4	; 180
    1a3e:	d1 40       	sbci	r29, 0x01	; 1
    1a40:	cc 54       	subi	r28, 0x4C	; 76
    1a42:	de 4f       	sbci	r29, 0xFE	; 254
    1a44:	88 81       	ld	r24, Y
    1a46:	c4 5b       	subi	r28, 0xB4	; 180
    1a48:	d1 40       	sbci	r29, 0x01	; 1
    1a4a:	88 23       	and	r24, r24
    1a4c:	31 f6       	brne	.-116    	; 0x19da <CheckLogin+0x89e>
    1a4e:	c2 55       	subi	r28, 0x52	; 82
    1a50:	de 4f       	sbci	r29, 0xFE	; 254
    1a52:	a8 81       	ld	r26, Y
    1a54:	b9 81       	ldd	r27, Y+1	; 0x01
    1a56:	ce 5a       	subi	r28, 0xAE	; 174
    1a58:	d1 40       	sbci	r29, 0x01	; 1
    1a5a:	57 96       	adiw	r26, 0x17	; 23
    1a5c:	1c 92       	st	X, r1
    1a5e:	fe 01       	movw	r30, r28
    1a60:	ec 5a       	subi	r30, 0xAC	; 172
    1a62:	ff 4f       	sbci	r31, 0xFF	; 255
    1a64:	cb 54       	subi	r28, 0x4B	; 75
    1a66:	de 4f       	sbci	r29, 0xFE	; 254
    1a68:	f9 83       	std	Y+1, r31	; 0x01
    1a6a:	e8 83       	st	Y, r30
    1a6c:	c5 5b       	subi	r28, 0xB5	; 181
    1a6e:	d1 40       	sbci	r29, 0x01	; 1
    1a70:	cb 54       	subi	r28, 0x4B	; 75
    1a72:	de 4f       	sbci	r29, 0xFE	; 254
    1a74:	88 81       	ld	r24, Y
    1a76:	99 81       	ldd	r25, Y+1	; 0x01
    1a78:	c5 5b       	subi	r28, 0xB5	; 181
    1a7a:	d1 40       	sbci	r29, 0x01	; 1
    1a7c:	48 96       	adiw	r24, 0x18	; 24
    1a7e:	c9 54       	subi	r28, 0x49	; 73
    1a80:	de 4f       	sbci	r29, 0xFE	; 254
    1a82:	99 83       	std	Y+1, r25	; 0x01
    1a84:	88 83       	st	Y, r24
    1a86:	c7 5b       	subi	r28, 0xB7	; 183
    1a88:	d1 40       	sbci	r29, 0x01	; 1
    1a8a:	a1 eb       	ldi	r26, 0xB1	; 177
    1a8c:	b0 e0       	ldi	r27, 0x00	; 0
    1a8e:	c7 54       	subi	r28, 0x47	; 71
    1a90:	de 4f       	sbci	r29, 0xFE	; 254
    1a92:	b9 83       	std	Y+1, r27	; 0x01
    1a94:	a8 83       	st	Y, r26
    1a96:	c9 5b       	subi	r28, 0xB9	; 185
    1a98:	d1 40       	sbci	r29, 0x01	; 1
    1a9a:	b7 e0       	ldi	r27, 0x07	; 7
    1a9c:	c5 54       	subi	r28, 0x45	; 69
    1a9e:	de 4f       	sbci	r29, 0xFE	; 254
    1aa0:	b8 83       	st	Y, r27
    1aa2:	cb 5b       	subi	r28, 0xBB	; 187
    1aa4:	d1 40       	sbci	r29, 0x01	; 1
    1aa6:	c7 54       	subi	r28, 0x47	; 71
    1aa8:	de 4f       	sbci	r29, 0xFE	; 254
    1aaa:	e8 81       	ld	r30, Y
    1aac:	f9 81       	ldd	r31, Y+1	; 0x01
    1aae:	c9 5b       	subi	r28, 0xB9	; 185
    1ab0:	d1 40       	sbci	r29, 0x01	; 1
    1ab2:	00 80       	ld	r0, Z
    1ab4:	c7 54       	subi	r28, 0x47	; 71
    1ab6:	de 4f       	sbci	r29, 0xFE	; 254
    1ab8:	88 81       	ld	r24, Y
    1aba:	99 81       	ldd	r25, Y+1	; 0x01
    1abc:	c9 5b       	subi	r28, 0xB9	; 185
    1abe:	d1 40       	sbci	r29, 0x01	; 1
    1ac0:	01 96       	adiw	r24, 0x01	; 1
    1ac2:	c7 54       	subi	r28, 0x47	; 71
    1ac4:	de 4f       	sbci	r29, 0xFE	; 254
    1ac6:	99 83       	std	Y+1, r25	; 0x01
    1ac8:	88 83       	st	Y, r24
    1aca:	c9 5b       	subi	r28, 0xB9	; 185
    1acc:	d1 40       	sbci	r29, 0x01	; 1
    1ace:	c9 54       	subi	r28, 0x49	; 73
    1ad0:	de 4f       	sbci	r29, 0xFE	; 254
    1ad2:	a8 81       	ld	r26, Y
    1ad4:	b9 81       	ldd	r27, Y+1	; 0x01
    1ad6:	c7 5b       	subi	r28, 0xB7	; 183
    1ad8:	d1 40       	sbci	r29, 0x01	; 1
    1ada:	0c 92       	st	X, r0
    1adc:	c9 54       	subi	r28, 0x49	; 73
    1ade:	de 4f       	sbci	r29, 0xFE	; 254
    1ae0:	e8 81       	ld	r30, Y
    1ae2:	f9 81       	ldd	r31, Y+1	; 0x01
    1ae4:	c7 5b       	subi	r28, 0xB7	; 183
    1ae6:	d1 40       	sbci	r29, 0x01	; 1
    1ae8:	31 96       	adiw	r30, 0x01	; 1
    1aea:	c9 54       	subi	r28, 0x49	; 73
    1aec:	de 4f       	sbci	r29, 0xFE	; 254
    1aee:	f9 83       	std	Y+1, r31	; 0x01
    1af0:	e8 83       	st	Y, r30
    1af2:	c7 5b       	subi	r28, 0xB7	; 183
    1af4:	d1 40       	sbci	r29, 0x01	; 1
    1af6:	c5 54       	subi	r28, 0x45	; 69
    1af8:	de 4f       	sbci	r29, 0xFE	; 254
    1afa:	f8 81       	ld	r31, Y
    1afc:	cb 5b       	subi	r28, 0xBB	; 187
    1afe:	d1 40       	sbci	r29, 0x01	; 1
    1b00:	f1 50       	subi	r31, 0x01	; 1
    1b02:	c5 54       	subi	r28, 0x45	; 69
    1b04:	de 4f       	sbci	r29, 0xFE	; 254
    1b06:	f8 83       	st	Y, r31
    1b08:	cb 5b       	subi	r28, 0xBB	; 187
    1b0a:	d1 40       	sbci	r29, 0x01	; 1
    1b0c:	c5 54       	subi	r28, 0x45	; 69
    1b0e:	de 4f       	sbci	r29, 0xFE	; 254
    1b10:	88 81       	ld	r24, Y
    1b12:	cb 5b       	subi	r28, 0xBB	; 187
    1b14:	d1 40       	sbci	r29, 0x01	; 1
    1b16:	88 23       	and	r24, r24
    1b18:	31 f6       	brne	.-116    	; 0x1aa6 <CheckLogin+0x96a>
    1b1a:	cb 54       	subi	r28, 0x4B	; 75
    1b1c:	de 4f       	sbci	r29, 0xFE	; 254
    1b1e:	a8 81       	ld	r26, Y
    1b20:	b9 81       	ldd	r27, Y+1	; 0x01
    1b22:	c5 5b       	subi	r28, 0xB5	; 181
    1b24:	d1 40       	sbci	r29, 0x01	; 1
    1b26:	5f 96       	adiw	r26, 0x1f	; 31
    1b28:	1c 92       	st	X, r1
    1b2a:	fe 01       	movw	r30, r28
    1b2c:	ec 5a       	subi	r30, 0xAC	; 172
    1b2e:	ff 4f       	sbci	r31, 0xFF	; 255
    1b30:	c4 54       	subi	r28, 0x44	; 68
    1b32:	de 4f       	sbci	r29, 0xFE	; 254
    1b34:	f9 83       	std	Y+1, r31	; 0x01
    1b36:	e8 83       	st	Y, r30
    1b38:	cc 5b       	subi	r28, 0xBC	; 188
    1b3a:	d1 40       	sbci	r29, 0x01	; 1
    1b3c:	c4 54       	subi	r28, 0x44	; 68
    1b3e:	de 4f       	sbci	r29, 0xFE	; 254
    1b40:	88 81       	ld	r24, Y
    1b42:	99 81       	ldd	r25, Y+1	; 0x01
    1b44:	cc 5b       	subi	r28, 0xBC	; 188
    1b46:	d1 40       	sbci	r29, 0x01	; 1
    1b48:	80 96       	adiw	r24, 0x20	; 32
    1b4a:	c2 54       	subi	r28, 0x42	; 66
    1b4c:	de 4f       	sbci	r29, 0xFE	; 254
    1b4e:	99 83       	std	Y+1, r25	; 0x01
    1b50:	88 83       	st	Y, r24
    1b52:	ce 5b       	subi	r28, 0xBE	; 190
    1b54:	d1 40       	sbci	r29, 0x01	; 1
    1b56:	a9 eb       	ldi	r26, 0xB9	; 185
    1b58:	b0 e0       	ldi	r27, 0x00	; 0
    1b5a:	c0 54       	subi	r28, 0x40	; 64
    1b5c:	de 4f       	sbci	r29, 0xFE	; 254
    1b5e:	b9 83       	std	Y+1, r27	; 0x01
    1b60:	a8 83       	st	Y, r26
    1b62:	c0 5c       	subi	r28, 0xC0	; 192
    1b64:	d1 40       	sbci	r29, 0x01	; 1
    1b66:	b7 e0       	ldi	r27, 0x07	; 7
    1b68:	ce 53       	subi	r28, 0x3E	; 62
    1b6a:	de 4f       	sbci	r29, 0xFE	; 254
    1b6c:	b8 83       	st	Y, r27
    1b6e:	c2 5c       	subi	r28, 0xC2	; 194
    1b70:	d1 40       	sbci	r29, 0x01	; 1
    1b72:	c0 54       	subi	r28, 0x40	; 64
    1b74:	de 4f       	sbci	r29, 0xFE	; 254
    1b76:	e8 81       	ld	r30, Y
    1b78:	f9 81       	ldd	r31, Y+1	; 0x01
    1b7a:	c0 5c       	subi	r28, 0xC0	; 192
    1b7c:	d1 40       	sbci	r29, 0x01	; 1
    1b7e:	00 80       	ld	r0, Z
    1b80:	c0 54       	subi	r28, 0x40	; 64
    1b82:	de 4f       	sbci	r29, 0xFE	; 254
    1b84:	88 81       	ld	r24, Y
    1b86:	99 81       	ldd	r25, Y+1	; 0x01
    1b88:	c0 5c       	subi	r28, 0xC0	; 192
    1b8a:	d1 40       	sbci	r29, 0x01	; 1
    1b8c:	01 96       	adiw	r24, 0x01	; 1
    1b8e:	c0 54       	subi	r28, 0x40	; 64
    1b90:	de 4f       	sbci	r29, 0xFE	; 254
    1b92:	99 83       	std	Y+1, r25	; 0x01
    1b94:	88 83       	st	Y, r24
    1b96:	c0 5c       	subi	r28, 0xC0	; 192
    1b98:	d1 40       	sbci	r29, 0x01	; 1
    1b9a:	c2 54       	subi	r28, 0x42	; 66
    1b9c:	de 4f       	sbci	r29, 0xFE	; 254
    1b9e:	a8 81       	ld	r26, Y
    1ba0:	b9 81       	ldd	r27, Y+1	; 0x01
    1ba2:	ce 5b       	subi	r28, 0xBE	; 190
    1ba4:	d1 40       	sbci	r29, 0x01	; 1
    1ba6:	0c 92       	st	X, r0
    1ba8:	c2 54       	subi	r28, 0x42	; 66
    1baa:	de 4f       	sbci	r29, 0xFE	; 254
    1bac:	e8 81       	ld	r30, Y
    1bae:	f9 81       	ldd	r31, Y+1	; 0x01
    1bb0:	ce 5b       	subi	r28, 0xBE	; 190
    1bb2:	d1 40       	sbci	r29, 0x01	; 1
    1bb4:	31 96       	adiw	r30, 0x01	; 1
    1bb6:	c2 54       	subi	r28, 0x42	; 66
    1bb8:	de 4f       	sbci	r29, 0xFE	; 254
    1bba:	f9 83       	std	Y+1, r31	; 0x01
    1bbc:	e8 83       	st	Y, r30
    1bbe:	ce 5b       	subi	r28, 0xBE	; 190
    1bc0:	d1 40       	sbci	r29, 0x01	; 1
    1bc2:	ce 53       	subi	r28, 0x3E	; 62
    1bc4:	de 4f       	sbci	r29, 0xFE	; 254
    1bc6:	f8 81       	ld	r31, Y
    1bc8:	c2 5c       	subi	r28, 0xC2	; 194
    1bca:	d1 40       	sbci	r29, 0x01	; 1
    1bcc:	f1 50       	subi	r31, 0x01	; 1
    1bce:	ce 53       	subi	r28, 0x3E	; 62
    1bd0:	de 4f       	sbci	r29, 0xFE	; 254
    1bd2:	f8 83       	st	Y, r31
    1bd4:	c2 5c       	subi	r28, 0xC2	; 194
    1bd6:	d1 40       	sbci	r29, 0x01	; 1
    1bd8:	ce 53       	subi	r28, 0x3E	; 62
    1bda:	de 4f       	sbci	r29, 0xFE	; 254
    1bdc:	88 81       	ld	r24, Y
    1bde:	c2 5c       	subi	r28, 0xC2	; 194
    1be0:	d1 40       	sbci	r29, 0x01	; 1
    1be2:	88 23       	and	r24, r24
    1be4:	31 f6       	brne	.-116    	; 0x1b72 <CheckLogin+0xa36>
    1be6:	c4 54       	subi	r28, 0x44	; 68
    1be8:	de 4f       	sbci	r29, 0xFE	; 254
    1bea:	a8 81       	ld	r26, Y
    1bec:	b9 81       	ldd	r27, Y+1	; 0x01
    1bee:	cc 5b       	subi	r28, 0xBC	; 188
    1bf0:	d1 40       	sbci	r29, 0x01	; 1
    1bf2:	97 96       	adiw	r26, 0x27	; 39
    1bf4:	1c 92       	st	X, r1
    1bf6:	fe 01       	movw	r30, r28
    1bf8:	ec 5a       	subi	r30, 0xAC	; 172
    1bfa:	ff 4f       	sbci	r31, 0xFF	; 255
    1bfc:	cd 53       	subi	r28, 0x3D	; 61
    1bfe:	de 4f       	sbci	r29, 0xFE	; 254
    1c00:	f9 83       	std	Y+1, r31	; 0x01
    1c02:	e8 83       	st	Y, r30
    1c04:	c3 5c       	subi	r28, 0xC3	; 195
    1c06:	d1 40       	sbci	r29, 0x01	; 1
    1c08:	cd 53       	subi	r28, 0x3D	; 61
    1c0a:	de 4f       	sbci	r29, 0xFE	; 254
    1c0c:	88 81       	ld	r24, Y
    1c0e:	99 81       	ldd	r25, Y+1	; 0x01
    1c10:	c3 5c       	subi	r28, 0xC3	; 195
    1c12:	d1 40       	sbci	r29, 0x01	; 1
    1c14:	88 96       	adiw	r24, 0x28	; 40
    1c16:	cb 53       	subi	r28, 0x3B	; 59
    1c18:	de 4f       	sbci	r29, 0xFE	; 254
    1c1a:	99 83       	std	Y+1, r25	; 0x01
    1c1c:	88 83       	st	Y, r24
    1c1e:	c5 5c       	subi	r28, 0xC5	; 197
    1c20:	d1 40       	sbci	r29, 0x01	; 1
    1c22:	a1 ec       	ldi	r26, 0xC1	; 193
    1c24:	b0 e0       	ldi	r27, 0x00	; 0
    1c26:	c9 53       	subi	r28, 0x39	; 57
    1c28:	de 4f       	sbci	r29, 0xFE	; 254
    1c2a:	b9 83       	std	Y+1, r27	; 0x01
    1c2c:	a8 83       	st	Y, r26
    1c2e:	c7 5c       	subi	r28, 0xC7	; 199
    1c30:	d1 40       	sbci	r29, 0x01	; 1
    1c32:	b7 e0       	ldi	r27, 0x07	; 7
    1c34:	c7 53       	subi	r28, 0x37	; 55
    1c36:	de 4f       	sbci	r29, 0xFE	; 254
    1c38:	b8 83       	st	Y, r27
    1c3a:	c9 5c       	subi	r28, 0xC9	; 201
    1c3c:	d1 40       	sbci	r29, 0x01	; 1
    1c3e:	c9 53       	subi	r28, 0x39	; 57
    1c40:	de 4f       	sbci	r29, 0xFE	; 254
    1c42:	e8 81       	ld	r30, Y
    1c44:	f9 81       	ldd	r31, Y+1	; 0x01
    1c46:	c7 5c       	subi	r28, 0xC7	; 199
    1c48:	d1 40       	sbci	r29, 0x01	; 1
    1c4a:	00 80       	ld	r0, Z
    1c4c:	c9 53       	subi	r28, 0x39	; 57
    1c4e:	de 4f       	sbci	r29, 0xFE	; 254
    1c50:	88 81       	ld	r24, Y
    1c52:	99 81       	ldd	r25, Y+1	; 0x01
    1c54:	c7 5c       	subi	r28, 0xC7	; 199
    1c56:	d1 40       	sbci	r29, 0x01	; 1
    1c58:	01 96       	adiw	r24, 0x01	; 1
    1c5a:	c9 53       	subi	r28, 0x39	; 57
    1c5c:	de 4f       	sbci	r29, 0xFE	; 254
    1c5e:	99 83       	std	Y+1, r25	; 0x01
    1c60:	88 83       	st	Y, r24
    1c62:	c7 5c       	subi	r28, 0xC7	; 199
    1c64:	d1 40       	sbci	r29, 0x01	; 1
    1c66:	cb 53       	subi	r28, 0x3B	; 59
    1c68:	de 4f       	sbci	r29, 0xFE	; 254
    1c6a:	a8 81       	ld	r26, Y
    1c6c:	b9 81       	ldd	r27, Y+1	; 0x01
    1c6e:	c5 5c       	subi	r28, 0xC5	; 197
    1c70:	d1 40       	sbci	r29, 0x01	; 1
    1c72:	0c 92       	st	X, r0
    1c74:	cb 53       	subi	r28, 0x3B	; 59
    1c76:	de 4f       	sbci	r29, 0xFE	; 254
    1c78:	e8 81       	ld	r30, Y
    1c7a:	f9 81       	ldd	r31, Y+1	; 0x01
    1c7c:	c5 5c       	subi	r28, 0xC5	; 197
    1c7e:	d1 40       	sbci	r29, 0x01	; 1
    1c80:	31 96       	adiw	r30, 0x01	; 1
    1c82:	cb 53       	subi	r28, 0x3B	; 59
    1c84:	de 4f       	sbci	r29, 0xFE	; 254
    1c86:	f9 83       	std	Y+1, r31	; 0x01
    1c88:	e8 83       	st	Y, r30
    1c8a:	c5 5c       	subi	r28, 0xC5	; 197
    1c8c:	d1 40       	sbci	r29, 0x01	; 1
    1c8e:	c7 53       	subi	r28, 0x37	; 55
    1c90:	de 4f       	sbci	r29, 0xFE	; 254
    1c92:	f8 81       	ld	r31, Y
    1c94:	c9 5c       	subi	r28, 0xC9	; 201
    1c96:	d1 40       	sbci	r29, 0x01	; 1
    1c98:	f1 50       	subi	r31, 0x01	; 1
    1c9a:	c7 53       	subi	r28, 0x37	; 55
    1c9c:	de 4f       	sbci	r29, 0xFE	; 254
    1c9e:	f8 83       	st	Y, r31
    1ca0:	c9 5c       	subi	r28, 0xC9	; 201
    1ca2:	d1 40       	sbci	r29, 0x01	; 1
    1ca4:	c7 53       	subi	r28, 0x37	; 55
    1ca6:	de 4f       	sbci	r29, 0xFE	; 254
    1ca8:	88 81       	ld	r24, Y
    1caa:	c9 5c       	subi	r28, 0xC9	; 201
    1cac:	d1 40       	sbci	r29, 0x01	; 1
    1cae:	88 23       	and	r24, r24
    1cb0:	31 f6       	brne	.-116    	; 0x1c3e <CheckLogin+0xb02>
    1cb2:	cd 53       	subi	r28, 0x3D	; 61
    1cb4:	de 4f       	sbci	r29, 0xFE	; 254
    1cb6:	a8 81       	ld	r26, Y
    1cb8:	b9 81       	ldd	r27, Y+1	; 0x01
    1cba:	c3 5c       	subi	r28, 0xC3	; 195
    1cbc:	d1 40       	sbci	r29, 0x01	; 1
    1cbe:	9f 96       	adiw	r26, 0x2f	; 47
    1cc0:	1c 92       	st	X, r1
    1cc2:	fe 01       	movw	r30, r28
    1cc4:	ec 5a       	subi	r30, 0xAC	; 172
    1cc6:	ff 4f       	sbci	r31, 0xFF	; 255
    1cc8:	c6 53       	subi	r28, 0x36	; 54
    1cca:	de 4f       	sbci	r29, 0xFE	; 254
    1ccc:	f9 83       	std	Y+1, r31	; 0x01
    1cce:	e8 83       	st	Y, r30
    1cd0:	ca 5c       	subi	r28, 0xCA	; 202
    1cd2:	d1 40       	sbci	r29, 0x01	; 1
    1cd4:	c6 53       	subi	r28, 0x36	; 54
    1cd6:	de 4f       	sbci	r29, 0xFE	; 254
    1cd8:	88 81       	ld	r24, Y
    1cda:	99 81       	ldd	r25, Y+1	; 0x01
    1cdc:	ca 5c       	subi	r28, 0xCA	; 202
    1cde:	d1 40       	sbci	r29, 0x01	; 1
    1ce0:	c0 96       	adiw	r24, 0x30	; 48
    1ce2:	c4 53       	subi	r28, 0x34	; 52
    1ce4:	de 4f       	sbci	r29, 0xFE	; 254
    1ce6:	99 83       	std	Y+1, r25	; 0x01
    1ce8:	88 83       	st	Y, r24
    1cea:	cc 5c       	subi	r28, 0xCC	; 204
    1cec:	d1 40       	sbci	r29, 0x01	; 1
    1cee:	a9 ec       	ldi	r26, 0xC9	; 201
    1cf0:	b0 e0       	ldi	r27, 0x00	; 0
    1cf2:	c2 53       	subi	r28, 0x32	; 50
    1cf4:	de 4f       	sbci	r29, 0xFE	; 254
    1cf6:	b9 83       	std	Y+1, r27	; 0x01
    1cf8:	a8 83       	st	Y, r26
    1cfa:	ce 5c       	subi	r28, 0xCE	; 206
    1cfc:	d1 40       	sbci	r29, 0x01	; 1
    1cfe:	b7 e0       	ldi	r27, 0x07	; 7
    1d00:	c0 53       	subi	r28, 0x30	; 48
    1d02:	de 4f       	sbci	r29, 0xFE	; 254
    1d04:	b8 83       	st	Y, r27
    1d06:	c0 5d       	subi	r28, 0xD0	; 208
    1d08:	d1 40       	sbci	r29, 0x01	; 1
    1d0a:	c2 53       	subi	r28, 0x32	; 50
    1d0c:	de 4f       	sbci	r29, 0xFE	; 254
    1d0e:	e8 81       	ld	r30, Y
    1d10:	f9 81       	ldd	r31, Y+1	; 0x01
    1d12:	ce 5c       	subi	r28, 0xCE	; 206
    1d14:	d1 40       	sbci	r29, 0x01	; 1
    1d16:	00 80       	ld	r0, Z
    1d18:	c2 53       	subi	r28, 0x32	; 50
    1d1a:	de 4f       	sbci	r29, 0xFE	; 254
    1d1c:	88 81       	ld	r24, Y
    1d1e:	99 81       	ldd	r25, Y+1	; 0x01
    1d20:	ce 5c       	subi	r28, 0xCE	; 206
    1d22:	d1 40       	sbci	r29, 0x01	; 1
    1d24:	01 96       	adiw	r24, 0x01	; 1
    1d26:	c2 53       	subi	r28, 0x32	; 50
    1d28:	de 4f       	sbci	r29, 0xFE	; 254
    1d2a:	99 83       	std	Y+1, r25	; 0x01
    1d2c:	88 83       	st	Y, r24
    1d2e:	ce 5c       	subi	r28, 0xCE	; 206
    1d30:	d1 40       	sbci	r29, 0x01	; 1
    1d32:	c4 53       	subi	r28, 0x34	; 52
    1d34:	de 4f       	sbci	r29, 0xFE	; 254
    1d36:	a8 81       	ld	r26, Y
    1d38:	b9 81       	ldd	r27, Y+1	; 0x01
    1d3a:	cc 5c       	subi	r28, 0xCC	; 204
    1d3c:	d1 40       	sbci	r29, 0x01	; 1
    1d3e:	0c 92       	st	X, r0
    1d40:	c4 53       	subi	r28, 0x34	; 52
    1d42:	de 4f       	sbci	r29, 0xFE	; 254
    1d44:	e8 81       	ld	r30, Y
    1d46:	f9 81       	ldd	r31, Y+1	; 0x01
    1d48:	cc 5c       	subi	r28, 0xCC	; 204
    1d4a:	d1 40       	sbci	r29, 0x01	; 1
    1d4c:	31 96       	adiw	r30, 0x01	; 1
    1d4e:	c4 53       	subi	r28, 0x34	; 52
    1d50:	de 4f       	sbci	r29, 0xFE	; 254
    1d52:	f9 83       	std	Y+1, r31	; 0x01
    1d54:	e8 83       	st	Y, r30
    1d56:	cc 5c       	subi	r28, 0xCC	; 204
    1d58:	d1 40       	sbci	r29, 0x01	; 1
    1d5a:	c0 53       	subi	r28, 0x30	; 48
    1d5c:	de 4f       	sbci	r29, 0xFE	; 254
    1d5e:	f8 81       	ld	r31, Y
    1d60:	c0 5d       	subi	r28, 0xD0	; 208
    1d62:	d1 40       	sbci	r29, 0x01	; 1
    1d64:	f1 50       	subi	r31, 0x01	; 1
    1d66:	c0 53       	subi	r28, 0x30	; 48
    1d68:	de 4f       	sbci	r29, 0xFE	; 254
    1d6a:	f8 83       	st	Y, r31
    1d6c:	c0 5d       	subi	r28, 0xD0	; 208
    1d6e:	d1 40       	sbci	r29, 0x01	; 1
    1d70:	c0 53       	subi	r28, 0x30	; 48
    1d72:	de 4f       	sbci	r29, 0xFE	; 254
    1d74:	88 81       	ld	r24, Y
    1d76:	c0 5d       	subi	r28, 0xD0	; 208
    1d78:	d1 40       	sbci	r29, 0x01	; 1
    1d7a:	88 23       	and	r24, r24
    1d7c:	31 f6       	brne	.-116    	; 0x1d0a <CheckLogin+0xbce>
    1d7e:	c6 53       	subi	r28, 0x36	; 54
    1d80:	de 4f       	sbci	r29, 0xFE	; 254
    1d82:	a8 81       	ld	r26, Y
    1d84:	b9 81       	ldd	r27, Y+1	; 0x01
    1d86:	ca 5c       	subi	r28, 0xCA	; 202
    1d88:	d1 40       	sbci	r29, 0x01	; 1
    1d8a:	d7 96       	adiw	r26, 0x37	; 55
    1d8c:	1c 92       	st	X, r1
    1d8e:	fe 01       	movw	r30, r28
    1d90:	ec 5a       	subi	r30, 0xAC	; 172
    1d92:	ff 4f       	sbci	r31, 0xFF	; 255
    1d94:	cf 52       	subi	r28, 0x2F	; 47
    1d96:	de 4f       	sbci	r29, 0xFE	; 254
    1d98:	f9 83       	std	Y+1, r31	; 0x01
    1d9a:	e8 83       	st	Y, r30
    1d9c:	c1 5d       	subi	r28, 0xD1	; 209
    1d9e:	d1 40       	sbci	r29, 0x01	; 1
    1da0:	cf 52       	subi	r28, 0x2F	; 47
    1da2:	de 4f       	sbci	r29, 0xFE	; 254
    1da4:	88 81       	ld	r24, Y
    1da6:	99 81       	ldd	r25, Y+1	; 0x01
    1da8:	c1 5d       	subi	r28, 0xD1	; 209
    1daa:	d1 40       	sbci	r29, 0x01	; 1
    1dac:	c8 96       	adiw	r24, 0x38	; 56
    1dae:	cd 52       	subi	r28, 0x2D	; 45
    1db0:	de 4f       	sbci	r29, 0xFE	; 254
    1db2:	99 83       	std	Y+1, r25	; 0x01
    1db4:	88 83       	st	Y, r24
    1db6:	c3 5d       	subi	r28, 0xD3	; 211
    1db8:	d1 40       	sbci	r29, 0x01	; 1
    1dba:	a1 ed       	ldi	r26, 0xD1	; 209
    1dbc:	b0 e0       	ldi	r27, 0x00	; 0
    1dbe:	cb 52       	subi	r28, 0x2B	; 43
    1dc0:	de 4f       	sbci	r29, 0xFE	; 254
    1dc2:	b9 83       	std	Y+1, r27	; 0x01
    1dc4:	a8 83       	st	Y, r26
    1dc6:	c5 5d       	subi	r28, 0xD5	; 213
    1dc8:	d1 40       	sbci	r29, 0x01	; 1
    1dca:	b7 e0       	ldi	r27, 0x07	; 7
    1dcc:	c9 52       	subi	r28, 0x29	; 41
    1dce:	de 4f       	sbci	r29, 0xFE	; 254
    1dd0:	b8 83       	st	Y, r27
    1dd2:	c7 5d       	subi	r28, 0xD7	; 215
    1dd4:	d1 40       	sbci	r29, 0x01	; 1
    1dd6:	cb 52       	subi	r28, 0x2B	; 43
    1dd8:	de 4f       	sbci	r29, 0xFE	; 254
    1dda:	e8 81       	ld	r30, Y
    1ddc:	f9 81       	ldd	r31, Y+1	; 0x01
    1dde:	c5 5d       	subi	r28, 0xD5	; 213
    1de0:	d1 40       	sbci	r29, 0x01	; 1
    1de2:	00 80       	ld	r0, Z
    1de4:	cb 52       	subi	r28, 0x2B	; 43
    1de6:	de 4f       	sbci	r29, 0xFE	; 254
    1de8:	88 81       	ld	r24, Y
    1dea:	99 81       	ldd	r25, Y+1	; 0x01
    1dec:	c5 5d       	subi	r28, 0xD5	; 213
    1dee:	d1 40       	sbci	r29, 0x01	; 1
    1df0:	01 96       	adiw	r24, 0x01	; 1
    1df2:	cb 52       	subi	r28, 0x2B	; 43
    1df4:	de 4f       	sbci	r29, 0xFE	; 254
    1df6:	99 83       	std	Y+1, r25	; 0x01
    1df8:	88 83       	st	Y, r24
    1dfa:	c5 5d       	subi	r28, 0xD5	; 213
    1dfc:	d1 40       	sbci	r29, 0x01	; 1
    1dfe:	cd 52       	subi	r28, 0x2D	; 45
    1e00:	de 4f       	sbci	r29, 0xFE	; 254
    1e02:	a8 81       	ld	r26, Y
    1e04:	b9 81       	ldd	r27, Y+1	; 0x01
    1e06:	c3 5d       	subi	r28, 0xD3	; 211
    1e08:	d1 40       	sbci	r29, 0x01	; 1
    1e0a:	0c 92       	st	X, r0
    1e0c:	cd 52       	subi	r28, 0x2D	; 45
    1e0e:	de 4f       	sbci	r29, 0xFE	; 254
    1e10:	e8 81       	ld	r30, Y
    1e12:	f9 81       	ldd	r31, Y+1	; 0x01
    1e14:	c3 5d       	subi	r28, 0xD3	; 211
    1e16:	d1 40       	sbci	r29, 0x01	; 1
    1e18:	31 96       	adiw	r30, 0x01	; 1
    1e1a:	cd 52       	subi	r28, 0x2D	; 45
    1e1c:	de 4f       	sbci	r29, 0xFE	; 254
    1e1e:	f9 83       	std	Y+1, r31	; 0x01
    1e20:	e8 83       	st	Y, r30
    1e22:	c3 5d       	subi	r28, 0xD3	; 211
    1e24:	d1 40       	sbci	r29, 0x01	; 1
    1e26:	c9 52       	subi	r28, 0x29	; 41
    1e28:	de 4f       	sbci	r29, 0xFE	; 254
    1e2a:	f8 81       	ld	r31, Y
    1e2c:	c7 5d       	subi	r28, 0xD7	; 215
    1e2e:	d1 40       	sbci	r29, 0x01	; 1
    1e30:	f1 50       	subi	r31, 0x01	; 1
    1e32:	c9 52       	subi	r28, 0x29	; 41
    1e34:	de 4f       	sbci	r29, 0xFE	; 254
    1e36:	f8 83       	st	Y, r31
    1e38:	c7 5d       	subi	r28, 0xD7	; 215
    1e3a:	d1 40       	sbci	r29, 0x01	; 1
    1e3c:	c9 52       	subi	r28, 0x29	; 41
    1e3e:	de 4f       	sbci	r29, 0xFE	; 254
    1e40:	88 81       	ld	r24, Y
    1e42:	c7 5d       	subi	r28, 0xD7	; 215
    1e44:	d1 40       	sbci	r29, 0x01	; 1
    1e46:	88 23       	and	r24, r24
    1e48:	31 f6       	brne	.-116    	; 0x1dd6 <CheckLogin+0xc9a>
    1e4a:	cf 52       	subi	r28, 0x2F	; 47
    1e4c:	de 4f       	sbci	r29, 0xFE	; 254
    1e4e:	a8 81       	ld	r26, Y
    1e50:	b9 81       	ldd	r27, Y+1	; 0x01
    1e52:	c1 5d       	subi	r28, 0xD1	; 209
    1e54:	d1 40       	sbci	r29, 0x01	; 1
    1e56:	df 96       	adiw	r26, 0x3f	; 63
    1e58:	1c 92       	st	X, r1
    1e5a:	fe 01       	movw	r30, r28
    1e5c:	ec 5a       	subi	r30, 0xAC	; 172
    1e5e:	ff 4f       	sbci	r31, 0xFF	; 255
    1e60:	c8 52       	subi	r28, 0x28	; 40
    1e62:	de 4f       	sbci	r29, 0xFE	; 254
    1e64:	f9 83       	std	Y+1, r31	; 0x01
    1e66:	e8 83       	st	Y, r30
    1e68:	c8 5d       	subi	r28, 0xD8	; 216
    1e6a:	d1 40       	sbci	r29, 0x01	; 1
    1e6c:	c8 52       	subi	r28, 0x28	; 40
    1e6e:	de 4f       	sbci	r29, 0xFE	; 254
    1e70:	88 81       	ld	r24, Y
    1e72:	99 81       	ldd	r25, Y+1	; 0x01
    1e74:	c8 5d       	subi	r28, 0xD8	; 216
    1e76:	d1 40       	sbci	r29, 0x01	; 1
    1e78:	80 5c       	subi	r24, 0xC0	; 192
    1e7a:	9f 4f       	sbci	r25, 0xFF	; 255
    1e7c:	c6 52       	subi	r28, 0x26	; 38
    1e7e:	de 4f       	sbci	r29, 0xFE	; 254
    1e80:	99 83       	std	Y+1, r25	; 0x01
    1e82:	88 83       	st	Y, r24
    1e84:	ca 5d       	subi	r28, 0xDA	; 218
    1e86:	d1 40       	sbci	r29, 0x01	; 1
    1e88:	a9 ed       	ldi	r26, 0xD9	; 217
    1e8a:	b0 e0       	ldi	r27, 0x00	; 0
    1e8c:	c4 52       	subi	r28, 0x24	; 36
    1e8e:	de 4f       	sbci	r29, 0xFE	; 254
    1e90:	b9 83       	std	Y+1, r27	; 0x01
    1e92:	a8 83       	st	Y, r26
    1e94:	cc 5d       	subi	r28, 0xDC	; 220
    1e96:	d1 40       	sbci	r29, 0x01	; 1
    1e98:	b7 e0       	ldi	r27, 0x07	; 7
    1e9a:	c2 52       	subi	r28, 0x22	; 34
    1e9c:	de 4f       	sbci	r29, 0xFE	; 254
    1e9e:	b8 83       	st	Y, r27
    1ea0:	ce 5d       	subi	r28, 0xDE	; 222
    1ea2:	d1 40       	sbci	r29, 0x01	; 1
    1ea4:	c4 52       	subi	r28, 0x24	; 36
    1ea6:	de 4f       	sbci	r29, 0xFE	; 254
    1ea8:	e8 81       	ld	r30, Y
    1eaa:	f9 81       	ldd	r31, Y+1	; 0x01
    1eac:	cc 5d       	subi	r28, 0xDC	; 220
    1eae:	d1 40       	sbci	r29, 0x01	; 1
    1eb0:	00 80       	ld	r0, Z
    1eb2:	c4 52       	subi	r28, 0x24	; 36
    1eb4:	de 4f       	sbci	r29, 0xFE	; 254
    1eb6:	88 81       	ld	r24, Y
    1eb8:	99 81       	ldd	r25, Y+1	; 0x01
    1eba:	cc 5d       	subi	r28, 0xDC	; 220
    1ebc:	d1 40       	sbci	r29, 0x01	; 1
    1ebe:	01 96       	adiw	r24, 0x01	; 1
    1ec0:	c4 52       	subi	r28, 0x24	; 36
    1ec2:	de 4f       	sbci	r29, 0xFE	; 254
    1ec4:	99 83       	std	Y+1, r25	; 0x01
    1ec6:	88 83       	st	Y, r24
    1ec8:	cc 5d       	subi	r28, 0xDC	; 220
    1eca:	d1 40       	sbci	r29, 0x01	; 1
    1ecc:	c6 52       	subi	r28, 0x26	; 38
    1ece:	de 4f       	sbci	r29, 0xFE	; 254
    1ed0:	a8 81       	ld	r26, Y
    1ed2:	b9 81       	ldd	r27, Y+1	; 0x01
    1ed4:	ca 5d       	subi	r28, 0xDA	; 218
    1ed6:	d1 40       	sbci	r29, 0x01	; 1
    1ed8:	0c 92       	st	X, r0
    1eda:	c6 52       	subi	r28, 0x26	; 38
    1edc:	de 4f       	sbci	r29, 0xFE	; 254
    1ede:	e8 81       	ld	r30, Y
    1ee0:	f9 81       	ldd	r31, Y+1	; 0x01
    1ee2:	ca 5d       	subi	r28, 0xDA	; 218
    1ee4:	d1 40       	sbci	r29, 0x01	; 1
    1ee6:	31 96       	adiw	r30, 0x01	; 1
    1ee8:	c6 52       	subi	r28, 0x26	; 38
    1eea:	de 4f       	sbci	r29, 0xFE	; 254
    1eec:	f9 83       	std	Y+1, r31	; 0x01
    1eee:	e8 83       	st	Y, r30
    1ef0:	ca 5d       	subi	r28, 0xDA	; 218
    1ef2:	d1 40       	sbci	r29, 0x01	; 1
    1ef4:	c2 52       	subi	r28, 0x22	; 34
    1ef6:	de 4f       	sbci	r29, 0xFE	; 254
    1ef8:	f8 81       	ld	r31, Y
    1efa:	ce 5d       	subi	r28, 0xDE	; 222
    1efc:	d1 40       	sbci	r29, 0x01	; 1
    1efe:	f1 50       	subi	r31, 0x01	; 1
    1f00:	c2 52       	subi	r28, 0x22	; 34
    1f02:	de 4f       	sbci	r29, 0xFE	; 254
    1f04:	f8 83       	st	Y, r31
    1f06:	ce 5d       	subi	r28, 0xDE	; 222
    1f08:	d1 40       	sbci	r29, 0x01	; 1
    1f0a:	c2 52       	subi	r28, 0x22	; 34
    1f0c:	de 4f       	sbci	r29, 0xFE	; 254
    1f0e:	88 81       	ld	r24, Y
    1f10:	ce 5d       	subi	r28, 0xDE	; 222
    1f12:	d1 40       	sbci	r29, 0x01	; 1
    1f14:	88 23       	and	r24, r24
    1f16:	31 f6       	brne	.-116    	; 0x1ea4 <CheckLogin+0xd68>
    1f18:	c8 52       	subi	r28, 0x28	; 40
    1f1a:	de 4f       	sbci	r29, 0xFE	; 254
    1f1c:	e8 81       	ld	r30, Y
    1f1e:	f9 81       	ldd	r31, Y+1	; 0x01
    1f20:	c8 5d       	subi	r28, 0xD8	; 216
    1f22:	d1 40       	sbci	r29, 0x01	; 1
    1f24:	e9 5b       	subi	r30, 0xB9	; 185
    1f26:	ff 4f       	sbci	r31, 0xFF	; 255
    1f28:	10 82       	st	Z, r1
    1f2a:	ce 01       	movw	r24, r28
    1f2c:	8c 5a       	subi	r24, 0xAC	; 172
    1f2e:	9f 4f       	sbci	r25, 0xFF	; 255
    1f30:	88 5b       	subi	r24, 0xB8	; 184
    1f32:	9f 4f       	sbci	r25, 0xFF	; 255
    1f34:	c1 52       	subi	r28, 0x21	; 33
    1f36:	de 4f       	sbci	r29, 0xFE	; 254
    1f38:	99 83       	std	Y+1, r25	; 0x01
    1f3a:	88 83       	st	Y, r24
    1f3c:	cf 5d       	subi	r28, 0xDF	; 223
    1f3e:	d1 40       	sbci	r29, 0x01	; 1
    1f40:	a1 ee       	ldi	r26, 0xE1	; 225
    1f42:	b0 e0       	ldi	r27, 0x00	; 0
    1f44:	cf 51       	subi	r28, 0x1F	; 31
    1f46:	de 4f       	sbci	r29, 0xFE	; 254
    1f48:	b9 83       	std	Y+1, r27	; 0x01
    1f4a:	a8 83       	st	Y, r26
    1f4c:	c1 5e       	subi	r28, 0xE1	; 225
    1f4e:	d1 40       	sbci	r29, 0x01	; 1
    1f50:	b8 e0       	ldi	r27, 0x08	; 8
    1f52:	cd 51       	subi	r28, 0x1D	; 29
    1f54:	de 4f       	sbci	r29, 0xFE	; 254
    1f56:	b8 83       	st	Y, r27
    1f58:	c3 5e       	subi	r28, 0xE3	; 227
    1f5a:	d1 40       	sbci	r29, 0x01	; 1
    1f5c:	cf 51       	subi	r28, 0x1F	; 31
    1f5e:	de 4f       	sbci	r29, 0xFE	; 254
    1f60:	e8 81       	ld	r30, Y
    1f62:	f9 81       	ldd	r31, Y+1	; 0x01
    1f64:	c1 5e       	subi	r28, 0xE1	; 225
    1f66:	d1 40       	sbci	r29, 0x01	; 1
    1f68:	00 80       	ld	r0, Z
    1f6a:	cf 51       	subi	r28, 0x1F	; 31
    1f6c:	de 4f       	sbci	r29, 0xFE	; 254
    1f6e:	88 81       	ld	r24, Y
    1f70:	99 81       	ldd	r25, Y+1	; 0x01
    1f72:	c1 5e       	subi	r28, 0xE1	; 225
    1f74:	d1 40       	sbci	r29, 0x01	; 1
    1f76:	01 96       	adiw	r24, 0x01	; 1
    1f78:	cf 51       	subi	r28, 0x1F	; 31
    1f7a:	de 4f       	sbci	r29, 0xFE	; 254
    1f7c:	99 83       	std	Y+1, r25	; 0x01
    1f7e:	88 83       	st	Y, r24
    1f80:	c1 5e       	subi	r28, 0xE1	; 225
    1f82:	d1 40       	sbci	r29, 0x01	; 1
    1f84:	c1 52       	subi	r28, 0x21	; 33
    1f86:	de 4f       	sbci	r29, 0xFE	; 254
    1f88:	a8 81       	ld	r26, Y
    1f8a:	b9 81       	ldd	r27, Y+1	; 0x01
    1f8c:	cf 5d       	subi	r28, 0xDF	; 223
    1f8e:	d1 40       	sbci	r29, 0x01	; 1
    1f90:	0c 92       	st	X, r0
    1f92:	c1 52       	subi	r28, 0x21	; 33
    1f94:	de 4f       	sbci	r29, 0xFE	; 254
    1f96:	e8 81       	ld	r30, Y
    1f98:	f9 81       	ldd	r31, Y+1	; 0x01
    1f9a:	cf 5d       	subi	r28, 0xDF	; 223
    1f9c:	d1 40       	sbci	r29, 0x01	; 1
    1f9e:	31 96       	adiw	r30, 0x01	; 1
    1fa0:	c1 52       	subi	r28, 0x21	; 33
    1fa2:	de 4f       	sbci	r29, 0xFE	; 254
    1fa4:	f9 83       	std	Y+1, r31	; 0x01
    1fa6:	e8 83       	st	Y, r30
    1fa8:	cf 5d       	subi	r28, 0xDF	; 223
    1faa:	d1 40       	sbci	r29, 0x01	; 1
    1fac:	cd 51       	subi	r28, 0x1D	; 29
    1fae:	de 4f       	sbci	r29, 0xFE	; 254
    1fb0:	f8 81       	ld	r31, Y
    1fb2:	c3 5e       	subi	r28, 0xE3	; 227
    1fb4:	d1 40       	sbci	r29, 0x01	; 1
    1fb6:	f1 50       	subi	r31, 0x01	; 1
    1fb8:	cd 51       	subi	r28, 0x1D	; 29
    1fba:	de 4f       	sbci	r29, 0xFE	; 254
    1fbc:	f8 83       	st	Y, r31
    1fbe:	c3 5e       	subi	r28, 0xE3	; 227
    1fc0:	d1 40       	sbci	r29, 0x01	; 1
    1fc2:	cd 51       	subi	r28, 0x1D	; 29
    1fc4:	de 4f       	sbci	r29, 0xFE	; 254
    1fc6:	88 81       	ld	r24, Y
    1fc8:	c3 5e       	subi	r28, 0xE3	; 227
    1fca:	d1 40       	sbci	r29, 0x01	; 1
    1fcc:	88 23       	and	r24, r24
    1fce:	31 f6       	brne	.-116    	; 0x1f5c <CheckLogin+0xe20>
	 char trails = 0, rxusername[100], rxpassword[100];
    1fd0:	19 82       	std	Y+1, r1	; 0x01
	USART_Flush();
    1fd2:	0e 94 3c 06 	call	0xc78	; 0xc78 <USART_Flush>
	USART_SendString("Enter UserName\r");
    1fd6:	89 e7       	ldi	r24, 0x79	; 121
    1fd8:	90 e0       	ldi	r25, 0x00	; 0
    1fda:	0e 94 4f 06 	call	0xc9e	; 0xc9e <USART_SendString>
	while (!Usart_ReceiveString_Del(rxusername,'\r'));
    1fde:	ce 01       	movw	r24, r28
    1fe0:	8c 55       	subi	r24, 0x5C	; 92
    1fe2:	9f 4f       	sbci	r25, 0xFF	; 255
    1fe4:	6d e0       	ldi	r22, 0x0D	; 13
    1fe6:	0e 94 7a 06 	call	0xcf4	; 0xcf4 <Usart_ReceiveString_Del>
    1fea:	88 23       	and	r24, r24
    1fec:	c1 f3       	breq	.-16     	; 0x1fde <CheckLogin+0xea2>
	USART_SendString("Enter Password\r");
    1fee:	89 e8       	ldi	r24, 0x89	; 137
    1ff0:	90 e0       	ldi	r25, 0x00	; 0
    1ff2:	0e 94 4f 06 	call	0xc9e	; 0xc9e <USART_SendString>
	while (!Usart_ReceiveString_Del(rxpassword,'\r'));
    1ff6:	ce 01       	movw	r24, r28
    1ff8:	88 5f       	subi	r24, 0xF8	; 248
    1ffa:	9e 4f       	sbci	r25, 0xFE	; 254
    1ffc:	6d e0       	ldi	r22, 0x0D	; 13
    1ffe:	0e 94 7a 06 	call	0xcf4	; 0xcf4 <Usart_ReceiveString_Del>
    2002:	88 23       	and	r24, r24
    2004:	c1 f3       	breq	.-16     	; 0x1ff6 <CheckLogin+0xeba>

	for (i = 0; i < 10; i++) {
    2006:	1b 82       	std	Y+3, r1	; 0x03
    2008:	31 c0       	rjmp	.+98     	; 0x206c <CheckLogin+0xf30>
		if (!strcmp(username[i], rxusername)
    200a:	9e 01       	movw	r18, r28
    200c:	2c 5f       	subi	r18, 0xFC	; 252
    200e:	3f 4f       	sbci	r19, 0xFF	; 255
    2010:	8b 81       	ldd	r24, Y+3	; 0x03
    2012:	88 2f       	mov	r24, r24
    2014:	90 e0       	ldi	r25, 0x00	; 0
    2016:	88 0f       	add	r24, r24
    2018:	99 1f       	adc	r25, r25
    201a:	88 0f       	add	r24, r24
    201c:	99 1f       	adc	r25, r25
    201e:	88 0f       	add	r24, r24
    2020:	99 1f       	adc	r25, r25
    2022:	82 0f       	add	r24, r18
    2024:	93 1f       	adc	r25, r19
    2026:	9e 01       	movw	r18, r28
    2028:	2c 55       	subi	r18, 0x5C	; 92
    202a:	3f 4f       	sbci	r19, 0xFF	; 255
    202c:	b9 01       	movw	r22, r18
    202e:	0e 94 d3 2e 	call	0x5da6	; 0x5da6 <strcmp>
    2032:	00 97       	sbiw	r24, 0x00	; 0
    2034:	c1 f4       	brne	.+48     	; 0x2066 <CheckLogin+0xf2a>
    2036:	9e 01       	movw	r18, r28
    2038:	2c 5a       	subi	r18, 0xAC	; 172
    203a:	3f 4f       	sbci	r19, 0xFF	; 255
    203c:	8b 81       	ldd	r24, Y+3	; 0x03
    203e:	88 2f       	mov	r24, r24
    2040:	90 e0       	ldi	r25, 0x00	; 0
    2042:	88 0f       	add	r24, r24
    2044:	99 1f       	adc	r25, r25
    2046:	88 0f       	add	r24, r24
    2048:	99 1f       	adc	r25, r25
    204a:	88 0f       	add	r24, r24
    204c:	99 1f       	adc	r25, r25
    204e:	82 0f       	add	r24, r18
    2050:	93 1f       	adc	r25, r19
    2052:	9e 01       	movw	r18, r28
    2054:	28 5f       	subi	r18, 0xF8	; 248
    2056:	3e 4f       	sbci	r19, 0xFE	; 254
    2058:	b9 01       	movw	r22, r18
    205a:	0e 94 d3 2e 	call	0x5da6	; 0x5da6 <strcmp>
    205e:	00 97       	sbiw	r24, 0x00	; 0
    2060:	11 f4       	brne	.+4      	; 0x2066 <CheckLogin+0xf2a>
				&& !strcmp(password[i], rxpassword)) {
			state = 1;
    2062:	81 e0       	ldi	r24, 0x01	; 1
    2064:	8a 83       	std	Y+2, r24	; 0x02
	USART_SendString("Enter UserName\r");
	while (!Usart_ReceiveString_Del(rxusername,'\r'));
	USART_SendString("Enter Password\r");
	while (!Usart_ReceiveString_Del(rxpassword,'\r'));

	for (i = 0; i < 10; i++) {
    2066:	8b 81       	ldd	r24, Y+3	; 0x03
    2068:	8f 5f       	subi	r24, 0xFF	; 255
    206a:	8b 83       	std	Y+3, r24	; 0x03
    206c:	8b 81       	ldd	r24, Y+3	; 0x03
    206e:	8a 30       	cpi	r24, 0x0A	; 10
    2070:	60 f2       	brcs	.-104    	; 0x200a <CheckLogin+0xece>
				&& !strcmp(password[i], rxpassword)) {
			state = 1;
		}
	}

	return state;
    2072:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2074:	cd 51       	subi	r28, 0x1D	; 29
    2076:	de 4f       	sbci	r29, 0xFE	; 254
    2078:	0f b6       	in	r0, 0x3f	; 63
    207a:	f8 94       	cli
    207c:	de bf       	out	0x3e, r29	; 62
    207e:	0f be       	out	0x3f, r0	; 63
    2080:	cd bf       	out	0x3d, r28	; 61
    2082:	cf 91       	pop	r28
    2084:	df 91       	pop	r29
    2086:	08 95       	ret

00002088 <Alarm>:

void Alarm(void) {
    2088:	df 93       	push	r29
    208a:	cf 93       	push	r28
    208c:	cd b7       	in	r28, 0x3d	; 61
    208e:	de b7       	in	r29, 0x3e	; 62
    2090:	2e 97       	sbiw	r28, 0x0e	; 14
    2092:	0f b6       	in	r0, 0x3f	; 63
    2094:	f8 94       	cli
    2096:	de bf       	out	0x3e, r29	; 62
    2098:	0f be       	out	0x3f, r0	; 63
    209a:	cd bf       	out	0x3d, r28	; 61
    209c:	80 e0       	ldi	r24, 0x00	; 0
    209e:	90 e0       	ldi	r25, 0x00	; 0
    20a0:	a8 e4       	ldi	r26, 0x48	; 72
    20a2:	b3 e4       	ldi	r27, 0x43	; 67
    20a4:	8b 87       	std	Y+11, r24	; 0x0b
    20a6:	9c 87       	std	Y+12, r25	; 0x0c
    20a8:	ad 87       	std	Y+13, r26	; 0x0d
    20aa:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    20ac:	6b 85       	ldd	r22, Y+11	; 0x0b
    20ae:	7c 85       	ldd	r23, Y+12	; 0x0c
    20b0:	8d 85       	ldd	r24, Y+13	; 0x0d
    20b2:	9e 85       	ldd	r25, Y+14	; 0x0e
    20b4:	20 e0       	ldi	r18, 0x00	; 0
    20b6:	30 e0       	ldi	r19, 0x00	; 0
    20b8:	4a ef       	ldi	r20, 0xFA	; 250
    20ba:	54 e4       	ldi	r21, 0x44	; 68
    20bc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20c0:	dc 01       	movw	r26, r24
    20c2:	cb 01       	movw	r24, r22
    20c4:	8f 83       	std	Y+7, r24	; 0x07
    20c6:	98 87       	std	Y+8, r25	; 0x08
    20c8:	a9 87       	std	Y+9, r26	; 0x09
    20ca:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    20cc:	6f 81       	ldd	r22, Y+7	; 0x07
    20ce:	78 85       	ldd	r23, Y+8	; 0x08
    20d0:	89 85       	ldd	r24, Y+9	; 0x09
    20d2:	9a 85       	ldd	r25, Y+10	; 0x0a
    20d4:	20 e0       	ldi	r18, 0x00	; 0
    20d6:	30 e0       	ldi	r19, 0x00	; 0
    20d8:	40 e8       	ldi	r20, 0x80	; 128
    20da:	5f e3       	ldi	r21, 0x3F	; 63
    20dc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    20e0:	88 23       	and	r24, r24
    20e2:	2c f4       	brge	.+10     	; 0x20ee <Alarm+0x66>
		__ticks = 1;
    20e4:	81 e0       	ldi	r24, 0x01	; 1
    20e6:	90 e0       	ldi	r25, 0x00	; 0
    20e8:	9e 83       	std	Y+6, r25	; 0x06
    20ea:	8d 83       	std	Y+5, r24	; 0x05
    20ec:	3f c0       	rjmp	.+126    	; 0x216c <Alarm+0xe4>
	else if (__tmp > 65535)
    20ee:	6f 81       	ldd	r22, Y+7	; 0x07
    20f0:	78 85       	ldd	r23, Y+8	; 0x08
    20f2:	89 85       	ldd	r24, Y+9	; 0x09
    20f4:	9a 85       	ldd	r25, Y+10	; 0x0a
    20f6:	20 e0       	ldi	r18, 0x00	; 0
    20f8:	3f ef       	ldi	r19, 0xFF	; 255
    20fa:	4f e7       	ldi	r20, 0x7F	; 127
    20fc:	57 e4       	ldi	r21, 0x47	; 71
    20fe:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2102:	18 16       	cp	r1, r24
    2104:	4c f5       	brge	.+82     	; 0x2158 <Alarm+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2106:	6b 85       	ldd	r22, Y+11	; 0x0b
    2108:	7c 85       	ldd	r23, Y+12	; 0x0c
    210a:	8d 85       	ldd	r24, Y+13	; 0x0d
    210c:	9e 85       	ldd	r25, Y+14	; 0x0e
    210e:	20 e0       	ldi	r18, 0x00	; 0
    2110:	30 e0       	ldi	r19, 0x00	; 0
    2112:	40 e2       	ldi	r20, 0x20	; 32
    2114:	51 e4       	ldi	r21, 0x41	; 65
    2116:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    211a:	dc 01       	movw	r26, r24
    211c:	cb 01       	movw	r24, r22
    211e:	bc 01       	movw	r22, r24
    2120:	cd 01       	movw	r24, r26
    2122:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2126:	dc 01       	movw	r26, r24
    2128:	cb 01       	movw	r24, r22
    212a:	9e 83       	std	Y+6, r25	; 0x06
    212c:	8d 83       	std	Y+5, r24	; 0x05
    212e:	0f c0       	rjmp	.+30     	; 0x214e <Alarm+0xc6>
    2130:	88 ec       	ldi	r24, 0xC8	; 200
    2132:	90 e0       	ldi	r25, 0x00	; 0
    2134:	9c 83       	std	Y+4, r25	; 0x04
    2136:	8b 83       	std	Y+3, r24	; 0x03
    2138:	8b 81       	ldd	r24, Y+3	; 0x03
    213a:	9c 81       	ldd	r25, Y+4	; 0x04
    213c:	01 97       	sbiw	r24, 0x01	; 1
    213e:	f1 f7       	brne	.-4      	; 0x213c <Alarm+0xb4>
    2140:	9c 83       	std	Y+4, r25	; 0x04
    2142:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2144:	8d 81       	ldd	r24, Y+5	; 0x05
    2146:	9e 81       	ldd	r25, Y+6	; 0x06
    2148:	01 97       	sbiw	r24, 0x01	; 1
    214a:	9e 83       	std	Y+6, r25	; 0x06
    214c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    214e:	8d 81       	ldd	r24, Y+5	; 0x05
    2150:	9e 81       	ldd	r25, Y+6	; 0x06
    2152:	00 97       	sbiw	r24, 0x00	; 0
    2154:	69 f7       	brne	.-38     	; 0x2130 <Alarm+0xa8>
    2156:	14 c0       	rjmp	.+40     	; 0x2180 <Alarm+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2158:	6f 81       	ldd	r22, Y+7	; 0x07
    215a:	78 85       	ldd	r23, Y+8	; 0x08
    215c:	89 85       	ldd	r24, Y+9	; 0x09
    215e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2160:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2164:	dc 01       	movw	r26, r24
    2166:	cb 01       	movw	r24, r22
    2168:	9e 83       	std	Y+6, r25	; 0x06
    216a:	8d 83       	std	Y+5, r24	; 0x05
    216c:	8d 81       	ldd	r24, Y+5	; 0x05
    216e:	9e 81       	ldd	r25, Y+6	; 0x06
    2170:	9a 83       	std	Y+2, r25	; 0x02
    2172:	89 83       	std	Y+1, r24	; 0x01
    2174:	89 81       	ldd	r24, Y+1	; 0x01
    2176:	9a 81       	ldd	r25, Y+2	; 0x02
    2178:	01 97       	sbiw	r24, 0x01	; 1
    217a:	f1 f7       	brne	.-4      	; 0x2178 <Alarm+0xf0>
    217c:	9a 83       	std	Y+2, r25	; 0x02
    217e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(200);
	LED1_BUZZER_Light_Lock ^= (1 << BuzzerPin) | (1 << LED1pin);
    2180:	a8 e3       	ldi	r26, 0x38	; 56
    2182:	b0 e0       	ldi	r27, 0x00	; 0
    2184:	e8 e3       	ldi	r30, 0x38	; 56
    2186:	f0 e0       	ldi	r31, 0x00	; 0
    2188:	90 81       	ld	r25, Z
    218a:	83 e0       	ldi	r24, 0x03	; 3
    218c:	89 27       	eor	r24, r25
    218e:	8c 93       	st	X, r24

}
    2190:	2e 96       	adiw	r28, 0x0e	; 14
    2192:	0f b6       	in	r0, 0x3f	; 63
    2194:	f8 94       	cli
    2196:	de bf       	out	0x3e, r29	; 62
    2198:	0f be       	out	0x3f, r0	; 63
    219a:	cd bf       	out	0x3d, r28	; 61
    219c:	cf 91       	pop	r28
    219e:	df 91       	pop	r29
    21a0:	08 95       	ret

000021a2 <SmartLock_Feature>:
void SmartLock_Feature(void) {
    21a2:	df 93       	push	r29
    21a4:	cf 93       	push	r28
    21a6:	cd b7       	in	r28, 0x3d	; 61
    21a8:	de b7       	in	r29, 0x3e	; 62
    21aa:	6f 97       	sbiw	r28, 0x1f	; 31
    21ac:	0f b6       	in	r0, 0x3f	; 63
    21ae:	f8 94       	cli
    21b0:	de bf       	out	0x3e, r29	; 62
    21b2:	0f be       	out	0x3f, r0	; 63
    21b4:	cd bf       	out	0x3d, r28	; 61

	USART_SendString(" Send 1 to turn on/of led\r");
    21b6:	89 ee       	ldi	r24, 0xE9	; 233
    21b8:	90 e0       	ldi	r25, 0x00	; 0
    21ba:	0e 94 4f 06 	call	0xc9e	; 0xc9e <USART_SendString>
    21be:	80 e0       	ldi	r24, 0x00	; 0
    21c0:	90 e0       	ldi	r25, 0x00	; 0
    21c2:	a6 e9       	ldi	r26, 0x96	; 150
    21c4:	b3 e4       	ldi	r27, 0x43	; 67
    21c6:	89 8f       	std	Y+25, r24	; 0x19
    21c8:	9a 8f       	std	Y+26, r25	; 0x1a
    21ca:	ab 8f       	std	Y+27, r26	; 0x1b
    21cc:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    21ce:	69 8d       	ldd	r22, Y+25	; 0x19
    21d0:	7a 8d       	ldd	r23, Y+26	; 0x1a
    21d2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    21d4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    21d6:	20 e0       	ldi	r18, 0x00	; 0
    21d8:	30 e0       	ldi	r19, 0x00	; 0
    21da:	4a ef       	ldi	r20, 0xFA	; 250
    21dc:	54 e4       	ldi	r21, 0x44	; 68
    21de:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21e2:	dc 01       	movw	r26, r24
    21e4:	cb 01       	movw	r24, r22
    21e6:	8d 8b       	std	Y+21, r24	; 0x15
    21e8:	9e 8b       	std	Y+22, r25	; 0x16
    21ea:	af 8b       	std	Y+23, r26	; 0x17
    21ec:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    21ee:	6d 89       	ldd	r22, Y+21	; 0x15
    21f0:	7e 89       	ldd	r23, Y+22	; 0x16
    21f2:	8f 89       	ldd	r24, Y+23	; 0x17
    21f4:	98 8d       	ldd	r25, Y+24	; 0x18
    21f6:	20 e0       	ldi	r18, 0x00	; 0
    21f8:	30 e0       	ldi	r19, 0x00	; 0
    21fa:	40 e8       	ldi	r20, 0x80	; 128
    21fc:	5f e3       	ldi	r21, 0x3F	; 63
    21fe:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2202:	88 23       	and	r24, r24
    2204:	2c f4       	brge	.+10     	; 0x2210 <SmartLock_Feature+0x6e>
		__ticks = 1;
    2206:	81 e0       	ldi	r24, 0x01	; 1
    2208:	90 e0       	ldi	r25, 0x00	; 0
    220a:	9c 8b       	std	Y+20, r25	; 0x14
    220c:	8b 8b       	std	Y+19, r24	; 0x13
    220e:	3f c0       	rjmp	.+126    	; 0x228e <SmartLock_Feature+0xec>
	else if (__tmp > 65535)
    2210:	6d 89       	ldd	r22, Y+21	; 0x15
    2212:	7e 89       	ldd	r23, Y+22	; 0x16
    2214:	8f 89       	ldd	r24, Y+23	; 0x17
    2216:	98 8d       	ldd	r25, Y+24	; 0x18
    2218:	20 e0       	ldi	r18, 0x00	; 0
    221a:	3f ef       	ldi	r19, 0xFF	; 255
    221c:	4f e7       	ldi	r20, 0x7F	; 127
    221e:	57 e4       	ldi	r21, 0x47	; 71
    2220:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2224:	18 16       	cp	r1, r24
    2226:	4c f5       	brge	.+82     	; 0x227a <SmartLock_Feature+0xd8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2228:	69 8d       	ldd	r22, Y+25	; 0x19
    222a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    222c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    222e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2230:	20 e0       	ldi	r18, 0x00	; 0
    2232:	30 e0       	ldi	r19, 0x00	; 0
    2234:	40 e2       	ldi	r20, 0x20	; 32
    2236:	51 e4       	ldi	r21, 0x41	; 65
    2238:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    223c:	dc 01       	movw	r26, r24
    223e:	cb 01       	movw	r24, r22
    2240:	bc 01       	movw	r22, r24
    2242:	cd 01       	movw	r24, r26
    2244:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2248:	dc 01       	movw	r26, r24
    224a:	cb 01       	movw	r24, r22
    224c:	9c 8b       	std	Y+20, r25	; 0x14
    224e:	8b 8b       	std	Y+19, r24	; 0x13
    2250:	0f c0       	rjmp	.+30     	; 0x2270 <SmartLock_Feature+0xce>
    2252:	88 ec       	ldi	r24, 0xC8	; 200
    2254:	90 e0       	ldi	r25, 0x00	; 0
    2256:	9a 8b       	std	Y+18, r25	; 0x12
    2258:	89 8b       	std	Y+17, r24	; 0x11
    225a:	89 89       	ldd	r24, Y+17	; 0x11
    225c:	9a 89       	ldd	r25, Y+18	; 0x12
    225e:	01 97       	sbiw	r24, 0x01	; 1
    2260:	f1 f7       	brne	.-4      	; 0x225e <SmartLock_Feature+0xbc>
    2262:	9a 8b       	std	Y+18, r25	; 0x12
    2264:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2266:	8b 89       	ldd	r24, Y+19	; 0x13
    2268:	9c 89       	ldd	r25, Y+20	; 0x14
    226a:	01 97       	sbiw	r24, 0x01	; 1
    226c:	9c 8b       	std	Y+20, r25	; 0x14
    226e:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2270:	8b 89       	ldd	r24, Y+19	; 0x13
    2272:	9c 89       	ldd	r25, Y+20	; 0x14
    2274:	00 97       	sbiw	r24, 0x00	; 0
    2276:	69 f7       	brne	.-38     	; 0x2252 <SmartLock_Feature+0xb0>
    2278:	14 c0       	rjmp	.+40     	; 0x22a2 <SmartLock_Feature+0x100>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    227a:	6d 89       	ldd	r22, Y+21	; 0x15
    227c:	7e 89       	ldd	r23, Y+22	; 0x16
    227e:	8f 89       	ldd	r24, Y+23	; 0x17
    2280:	98 8d       	ldd	r25, Y+24	; 0x18
    2282:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2286:	dc 01       	movw	r26, r24
    2288:	cb 01       	movw	r24, r22
    228a:	9c 8b       	std	Y+20, r25	; 0x14
    228c:	8b 8b       	std	Y+19, r24	; 0x13
    228e:	8b 89       	ldd	r24, Y+19	; 0x13
    2290:	9c 89       	ldd	r25, Y+20	; 0x14
    2292:	98 8b       	std	Y+16, r25	; 0x10
    2294:	8f 87       	std	Y+15, r24	; 0x0f
    2296:	8f 85       	ldd	r24, Y+15	; 0x0f
    2298:	98 89       	ldd	r25, Y+16	; 0x10
    229a:	01 97       	sbiw	r24, 0x01	; 1
    229c:	f1 f7       	brne	.-4      	; 0x229a <SmartLock_Feature+0xf8>
    229e:	98 8b       	std	Y+16, r25	; 0x10
    22a0:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(300);
	USART_SendString(" 2 to lock/unlock the door\r");
    22a2:	84 e0       	ldi	r24, 0x04	; 4
    22a4:	91 e0       	ldi	r25, 0x01	; 1
    22a6:	0e 94 4f 06 	call	0xc9e	; 0xc9e <USART_SendString>
    22aa:	80 e0       	ldi	r24, 0x00	; 0
    22ac:	90 e0       	ldi	r25, 0x00	; 0
    22ae:	a6 e9       	ldi	r26, 0x96	; 150
    22b0:	b3 e4       	ldi	r27, 0x43	; 67
    22b2:	8b 87       	std	Y+11, r24	; 0x0b
    22b4:	9c 87       	std	Y+12, r25	; 0x0c
    22b6:	ad 87       	std	Y+13, r26	; 0x0d
    22b8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    22ba:	6b 85       	ldd	r22, Y+11	; 0x0b
    22bc:	7c 85       	ldd	r23, Y+12	; 0x0c
    22be:	8d 85       	ldd	r24, Y+13	; 0x0d
    22c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    22c2:	20 e0       	ldi	r18, 0x00	; 0
    22c4:	30 e0       	ldi	r19, 0x00	; 0
    22c6:	4a ef       	ldi	r20, 0xFA	; 250
    22c8:	54 e4       	ldi	r21, 0x44	; 68
    22ca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22ce:	dc 01       	movw	r26, r24
    22d0:	cb 01       	movw	r24, r22
    22d2:	8f 83       	std	Y+7, r24	; 0x07
    22d4:	98 87       	std	Y+8, r25	; 0x08
    22d6:	a9 87       	std	Y+9, r26	; 0x09
    22d8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    22da:	6f 81       	ldd	r22, Y+7	; 0x07
    22dc:	78 85       	ldd	r23, Y+8	; 0x08
    22de:	89 85       	ldd	r24, Y+9	; 0x09
    22e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    22e2:	20 e0       	ldi	r18, 0x00	; 0
    22e4:	30 e0       	ldi	r19, 0x00	; 0
    22e6:	40 e8       	ldi	r20, 0x80	; 128
    22e8:	5f e3       	ldi	r21, 0x3F	; 63
    22ea:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    22ee:	88 23       	and	r24, r24
    22f0:	2c f4       	brge	.+10     	; 0x22fc <SmartLock_Feature+0x15a>
		__ticks = 1;
    22f2:	81 e0       	ldi	r24, 0x01	; 1
    22f4:	90 e0       	ldi	r25, 0x00	; 0
    22f6:	9e 83       	std	Y+6, r25	; 0x06
    22f8:	8d 83       	std	Y+5, r24	; 0x05
    22fa:	3f c0       	rjmp	.+126    	; 0x237a <SmartLock_Feature+0x1d8>
	else if (__tmp > 65535)
    22fc:	6f 81       	ldd	r22, Y+7	; 0x07
    22fe:	78 85       	ldd	r23, Y+8	; 0x08
    2300:	89 85       	ldd	r24, Y+9	; 0x09
    2302:	9a 85       	ldd	r25, Y+10	; 0x0a
    2304:	20 e0       	ldi	r18, 0x00	; 0
    2306:	3f ef       	ldi	r19, 0xFF	; 255
    2308:	4f e7       	ldi	r20, 0x7F	; 127
    230a:	57 e4       	ldi	r21, 0x47	; 71
    230c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2310:	18 16       	cp	r1, r24
    2312:	4c f5       	brge	.+82     	; 0x2366 <SmartLock_Feature+0x1c4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2314:	6b 85       	ldd	r22, Y+11	; 0x0b
    2316:	7c 85       	ldd	r23, Y+12	; 0x0c
    2318:	8d 85       	ldd	r24, Y+13	; 0x0d
    231a:	9e 85       	ldd	r25, Y+14	; 0x0e
    231c:	20 e0       	ldi	r18, 0x00	; 0
    231e:	30 e0       	ldi	r19, 0x00	; 0
    2320:	40 e2       	ldi	r20, 0x20	; 32
    2322:	51 e4       	ldi	r21, 0x41	; 65
    2324:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2328:	dc 01       	movw	r26, r24
    232a:	cb 01       	movw	r24, r22
    232c:	bc 01       	movw	r22, r24
    232e:	cd 01       	movw	r24, r26
    2330:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2334:	dc 01       	movw	r26, r24
    2336:	cb 01       	movw	r24, r22
    2338:	9e 83       	std	Y+6, r25	; 0x06
    233a:	8d 83       	std	Y+5, r24	; 0x05
    233c:	0f c0       	rjmp	.+30     	; 0x235c <SmartLock_Feature+0x1ba>
    233e:	88 ec       	ldi	r24, 0xC8	; 200
    2340:	90 e0       	ldi	r25, 0x00	; 0
    2342:	9c 83       	std	Y+4, r25	; 0x04
    2344:	8b 83       	std	Y+3, r24	; 0x03
    2346:	8b 81       	ldd	r24, Y+3	; 0x03
    2348:	9c 81       	ldd	r25, Y+4	; 0x04
    234a:	01 97       	sbiw	r24, 0x01	; 1
    234c:	f1 f7       	brne	.-4      	; 0x234a <SmartLock_Feature+0x1a8>
    234e:	9c 83       	std	Y+4, r25	; 0x04
    2350:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2352:	8d 81       	ldd	r24, Y+5	; 0x05
    2354:	9e 81       	ldd	r25, Y+6	; 0x06
    2356:	01 97       	sbiw	r24, 0x01	; 1
    2358:	9e 83       	std	Y+6, r25	; 0x06
    235a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    235c:	8d 81       	ldd	r24, Y+5	; 0x05
    235e:	9e 81       	ldd	r25, Y+6	; 0x06
    2360:	00 97       	sbiw	r24, 0x00	; 0
    2362:	69 f7       	brne	.-38     	; 0x233e <SmartLock_Feature+0x19c>
    2364:	14 c0       	rjmp	.+40     	; 0x238e <SmartLock_Feature+0x1ec>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2366:	6f 81       	ldd	r22, Y+7	; 0x07
    2368:	78 85       	ldd	r23, Y+8	; 0x08
    236a:	89 85       	ldd	r24, Y+9	; 0x09
    236c:	9a 85       	ldd	r25, Y+10	; 0x0a
    236e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2372:	dc 01       	movw	r26, r24
    2374:	cb 01       	movw	r24, r22
    2376:	9e 83       	std	Y+6, r25	; 0x06
    2378:	8d 83       	std	Y+5, r24	; 0x05
    237a:	8d 81       	ldd	r24, Y+5	; 0x05
    237c:	9e 81       	ldd	r25, Y+6	; 0x06
    237e:	9a 83       	std	Y+2, r25	; 0x02
    2380:	89 83       	std	Y+1, r24	; 0x01
    2382:	89 81       	ldd	r24, Y+1	; 0x01
    2384:	9a 81       	ldd	r25, Y+2	; 0x02
    2386:	01 97       	sbiw	r24, 0x01	; 1
    2388:	f1 f7       	brne	.-4      	; 0x2386 <SmartLock_Feature+0x1e4>
    238a:	9a 83       	std	Y+2, r25	; 0x02
    238c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(300);
	USART_SendString(" 3 to exit\r");
    238e:	80 e2       	ldi	r24, 0x20	; 32
    2390:	91 e0       	ldi	r25, 0x01	; 1
    2392:	0e 94 4f 06 	call	0xc9e	; 0xc9e <USART_SendString>
	char Feature = 0;
    2396:	1d 8e       	std	Y+29, r1	; 0x1d
    2398:	2b c0       	rjmp	.+86     	; 0x23f0 <SmartLock_Feature+0x24e>
	while (Feature != '3') {
		switch (Feature) {
    239a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    239c:	28 2f       	mov	r18, r24
    239e:	30 e0       	ldi	r19, 0x00	; 0
    23a0:	3f 8f       	std	Y+31, r19	; 0x1f
    23a2:	2e 8f       	std	Y+30, r18	; 0x1e
    23a4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    23a6:	9f 8d       	ldd	r25, Y+31	; 0x1f
    23a8:	81 33       	cpi	r24, 0x31	; 49
    23aa:	91 05       	cpc	r25, r1
    23ac:	31 f0       	breq	.+12     	; 0x23ba <SmartLock_Feature+0x218>
    23ae:	2e 8d       	ldd	r18, Y+30	; 0x1e
    23b0:	3f 8d       	ldd	r19, Y+31	; 0x1f
    23b2:	22 33       	cpi	r18, 0x32	; 50
    23b4:	31 05       	cpc	r19, r1
    23b6:	69 f0       	breq	.+26     	; 0x23d2 <SmartLock_Feature+0x230>
    23b8:	18 c0       	rjmp	.+48     	; 0x23ea <SmartLock_Feature+0x248>
		case LIGHT:
		    LED1_BUZZER_Light_Lock ^= (1 << Light);
    23ba:	a8 e3       	ldi	r26, 0x38	; 56
    23bc:	b0 e0       	ldi	r27, 0x00	; 0
    23be:	e8 e3       	ldi	r30, 0x38	; 56
    23c0:	f0 e0       	ldi	r31, 0x00	; 0
    23c2:	90 81       	ld	r25, Z
    23c4:	84 e0       	ldi	r24, 0x04	; 4
    23c6:	89 27       	eor	r24, r25
    23c8:	8c 93       	st	X, r24
			Feature = USART_RxChar();
    23ca:	0e 94 16 06 	call	0xc2c	; 0xc2c <USART_RxChar>
    23ce:	8d 8f       	std	Y+29, r24	; 0x1d
    23d0:	0f c0       	rjmp	.+30     	; 0x23f0 <SmartLock_Feature+0x24e>
			break;
		case LOCK:
		    LED1_BUZZER_Light_Lock ^= (1 << LockRelay);
    23d2:	a8 e3       	ldi	r26, 0x38	; 56
    23d4:	b0 e0       	ldi	r27, 0x00	; 0
    23d6:	e8 e3       	ldi	r30, 0x38	; 56
    23d8:	f0 e0       	ldi	r31, 0x00	; 0
    23da:	90 81       	ld	r25, Z
    23dc:	88 e0       	ldi	r24, 0x08	; 8
    23de:	89 27       	eor	r24, r25
    23e0:	8c 93       	st	X, r24
			Feature = USART_RxChar();
    23e2:	0e 94 16 06 	call	0xc2c	; 0xc2c <USART_RxChar>
    23e6:	8d 8f       	std	Y+29, r24	; 0x1d
    23e8:	03 c0       	rjmp	.+6      	; 0x23f0 <SmartLock_Feature+0x24e>
			break;
		default:
			Feature = USART_RxChar();
    23ea:	0e 94 16 06 	call	0xc2c	; 0xc2c <USART_RxChar>
    23ee:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(300);
	USART_SendString(" 2 to lock/unlock the door\r");
	_delay_ms(300);
	USART_SendString(" 3 to exit\r");
	char Feature = 0;
	while (Feature != '3') {
    23f0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    23f2:	83 33       	cpi	r24, 0x33	; 51
    23f4:	91 f6       	brne	.-92     	; 0x239a <SmartLock_Feature+0x1f8>
		default:
			Feature = USART_RxChar();
			break;
		}
	}
}
    23f6:	6f 96       	adiw	r28, 0x1f	; 31
    23f8:	0f b6       	in	r0, 0x3f	; 63
    23fa:	f8 94       	cli
    23fc:	de bf       	out	0x3e, r29	; 62
    23fe:	0f be       	out	0x3f, r0	; 63
    2400:	cd bf       	out	0x3d, r28	; 61
    2402:	cf 91       	pop	r28
    2404:	df 91       	pop	r29
    2406:	08 95       	ret

00002408 <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
    2408:	af 92       	push	r10
    240a:	bf 92       	push	r11
    240c:	cf 92       	push	r12
    240e:	df 92       	push	r13
    2410:	ef 92       	push	r14
    2412:	ff 92       	push	r15
    2414:	0f 93       	push	r16
    2416:	df 93       	push	r29
    2418:	cf 93       	push	r28
    241a:	0f 92       	push	r0
    241c:	cd b7       	in	r28, 0x3d	; 61
    241e:	de b7       	in	r29, 0x3e	; 62
    2420:	89 83       	std	Y+1, r24	; 0x01
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
    2422:	8a e0       	ldi	r24, 0x0A	; 10
    2424:	62 e0       	ldi	r22, 0x02	; 2
    2426:	40 e0       	ldi	r20, 0x00	; 0
    2428:	0e 94 e4 1e 	call	0x3dc8	; 0x3dc8 <xQueueGenericCreate>
    242c:	90 93 81 01 	sts	0x0181, r25
    2430:	80 93 80 01 	sts	0x0180, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    2434:	88 e8       	ldi	r24, 0x88	; 136
    2436:	92 e1       	ldi	r25, 0x12	; 18
    2438:	2c e2       	ldi	r18, 0x2C	; 44
    243a:	31 e0       	ldi	r19, 0x01	; 1
    243c:	e0 e8       	ldi	r30, 0x80	; 128
    243e:	f1 e0       	ldi	r31, 0x01	; 1
    2440:	b9 01       	movw	r22, r18
    2442:	45 e5       	ldi	r20, 0x55	; 85
    2444:	50 e0       	ldi	r21, 0x00	; 0
    2446:	9f 01       	movw	r18, r30
    2448:	09 81       	ldd	r16, Y+1	; 0x01
    244a:	ee 24       	eor	r14, r14
    244c:	ff 24       	eor	r15, r15
    244e:	cc 24       	eor	r12, r12
    2450:	dd 24       	eor	r13, r13
    2452:	aa 24       	eor	r10, r10
    2454:	bb 24       	eor	r11, r11
    2456:	0e 94 8d 25 	call	0x4b1a	; 0x4b1a <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    245a:	8b e4       	ldi	r24, 0x4B	; 75
    245c:	92 e1       	ldi	r25, 0x12	; 18
    245e:	24 e3       	ldi	r18, 0x34	; 52
    2460:	31 e0       	ldi	r19, 0x01	; 1
    2462:	e0 e8       	ldi	r30, 0x80	; 128
    2464:	f1 e0       	ldi	r31, 0x01	; 1
    2466:	b9 01       	movw	r22, r18
    2468:	45 e5       	ldi	r20, 0x55	; 85
    246a:	50 e0       	ldi	r21, 0x00	; 0
    246c:	9f 01       	movw	r18, r30
    246e:	09 81       	ldd	r16, Y+1	; 0x01
    2470:	ee 24       	eor	r14, r14
    2472:	ff 24       	eor	r15, r15
    2474:	cc 24       	eor	r12, r12
    2476:	dd 24       	eor	r13, r13
    2478:	aa 24       	eor	r10, r10
    247a:	bb 24       	eor	r11, r11
    247c:	0e 94 8d 25 	call	0x4b1a	; 0x4b1a <xTaskGenericCreate>
}
    2480:	0f 90       	pop	r0
    2482:	cf 91       	pop	r28
    2484:	df 91       	pop	r29
    2486:	0f 91       	pop	r16
    2488:	ff 90       	pop	r15
    248a:	ef 90       	pop	r14
    248c:	df 90       	pop	r13
    248e:	cf 90       	pop	r12
    2490:	bf 90       	pop	r11
    2492:	af 90       	pop	r10
    2494:	08 95       	ret

00002496 <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
    2496:	df 93       	push	r29
    2498:	cf 93       	push	r28
    249a:	00 d0       	rcall	.+0      	; 0x249c <vPolledQueueProducer+0x6>
    249c:	00 d0       	rcall	.+0      	; 0x249e <vPolledQueueProducer+0x8>
    249e:	00 d0       	rcall	.+0      	; 0x24a0 <vPolledQueueProducer+0xa>
    24a0:	cd b7       	in	r28, 0x3d	; 61
    24a2:	de b7       	in	r29, 0x3e	; 62
    24a4:	9e 83       	std	Y+6, r25	; 0x06
    24a6:	8d 83       	std	Y+5, r24	; 0x05
uint16_t usValue = ( uint16_t ) 0;
    24a8:	1c 82       	std	Y+4, r1	; 0x04
    24aa:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xError = pdFALSE, xLoop;
    24ac:	1a 82       	std	Y+2, r1	; 0x02

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    24ae:	19 82       	std	Y+1, r1	; 0x01
    24b0:	27 c0       	rjmp	.+78     	; 0x2500 <vPolledQueueProducer+0x6a>
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
    24b2:	ed 81       	ldd	r30, Y+5	; 0x05
    24b4:	fe 81       	ldd	r31, Y+6	; 0x06
    24b6:	80 81       	ld	r24, Z
    24b8:	91 81       	ldd	r25, Z+1	; 0x01
    24ba:	9e 01       	movw	r18, r28
    24bc:	2d 5f       	subi	r18, 0xFD	; 253
    24be:	3f 4f       	sbci	r19, 0xFF	; 255
    24c0:	b9 01       	movw	r22, r18
    24c2:	40 e0       	ldi	r20, 0x00	; 0
    24c4:	50 e0       	ldi	r21, 0x00	; 0
    24c6:	20 e0       	ldi	r18, 0x00	; 0
    24c8:	0e 94 61 1f 	call	0x3ec2	; 0x3ec2 <xQueueGenericSend>
    24cc:	81 30       	cpi	r24, 0x01	; 1
    24ce:	19 f0       	breq	.+6      	; 0x24d6 <vPolledQueueProducer+0x40>
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
    24d0:	81 e0       	ldi	r24, 0x01	; 1
    24d2:	8a 83       	std	Y+2, r24	; 0x02
    24d4:	12 c0       	rjmp	.+36     	; 0x24fa <vPolledQueueProducer+0x64>
			}
			else
			{
				if( xError == pdFALSE )
    24d6:	8a 81       	ldd	r24, Y+2	; 0x02
    24d8:	88 23       	and	r24, r24
    24da:	51 f4       	brne	.+20     	; 0x24f0 <vPolledQueueProducer+0x5a>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
    24dc:	0f b6       	in	r0, 0x3f	; 63
    24de:	f8 94       	cli
    24e0:	0f 92       	push	r0
						xPollingProducerCount++;
    24e2:	80 91 7f 01 	lds	r24, 0x017F
    24e6:	8f 5f       	subi	r24, 0xFF	; 255
    24e8:	80 93 7f 01 	sts	0x017F, r24
					portEXIT_CRITICAL();
    24ec:	0f 90       	pop	r0
    24ee:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
    24f0:	8b 81       	ldd	r24, Y+3	; 0x03
    24f2:	9c 81       	ldd	r25, Y+4	; 0x04
    24f4:	01 96       	adiw	r24, 0x01	; 1
    24f6:	9c 83       	std	Y+4, r25	; 0x04
    24f8:	8b 83       	std	Y+3, r24	; 0x03
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    24fa:	89 81       	ldd	r24, Y+1	; 0x01
    24fc:	8f 5f       	subi	r24, 0xFF	; 255
    24fe:	89 83       	std	Y+1, r24	; 0x01
    2500:	89 81       	ldd	r24, Y+1	; 0x01
    2502:	83 30       	cpi	r24, 0x03	; 3
    2504:	b4 f2       	brlt	.-84     	; 0x24b2 <vPolledQueueProducer+0x1c>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
    2506:	88 ec       	ldi	r24, 0xC8	; 200
    2508:	90 e0       	ldi	r25, 0x00	; 0
    250a:	0e 94 47 27 	call	0x4e8e	; 0x4e8e <vTaskDelay>
    250e:	cf cf       	rjmp	.-98     	; 0x24ae <vPolledQueueProducer+0x18>

00002510 <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
    2510:	df 93       	push	r29
    2512:	cf 93       	push	r28
    2514:	cd b7       	in	r28, 0x3d	; 61
    2516:	de b7       	in	r29, 0x3e	; 62
    2518:	27 97       	sbiw	r28, 0x07	; 7
    251a:	0f b6       	in	r0, 0x3f	; 63
    251c:	f8 94       	cli
    251e:	de bf       	out	0x3e, r29	; 62
    2520:	0f be       	out	0x3f, r0	; 63
    2522:	cd bf       	out	0x3d, r28	; 61
    2524:	9f 83       	std	Y+7, r25	; 0x07
    2526:	8e 83       	std	Y+6, r24	; 0x06
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
    2528:	1b 82       	std	Y+3, r1	; 0x03
    252a:	1a 82       	std	Y+2, r1	; 0x02
BaseType_t xError = pdFALSE;
    252c:	19 82       	std	Y+1, r1	; 0x01
    252e:	2f c0       	rjmp	.+94     	; 0x258e <vPolledQueueConsumer+0x7e>
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
    2530:	ee 81       	ldd	r30, Y+6	; 0x06
    2532:	ff 81       	ldd	r31, Y+7	; 0x07
    2534:	80 81       	ld	r24, Z
    2536:	91 81       	ldd	r25, Z+1	; 0x01
    2538:	9e 01       	movw	r18, r28
    253a:	2c 5f       	subi	r18, 0xFC	; 252
    253c:	3f 4f       	sbci	r19, 0xFF	; 255
    253e:	b9 01       	movw	r22, r18
    2540:	40 e0       	ldi	r20, 0x00	; 0
    2542:	50 e0       	ldi	r21, 0x00	; 0
    2544:	20 e0       	ldi	r18, 0x00	; 0
    2546:	0e 94 6f 20 	call	0x40de	; 0x40de <xQueueGenericReceive>
    254a:	81 30       	cpi	r24, 0x01	; 1
    254c:	01 f5       	brne	.+64     	; 0x258e <vPolledQueueConsumer+0x7e>
			{
				if( usData != usExpectedValue )
    254e:	2c 81       	ldd	r18, Y+4	; 0x04
    2550:	3d 81       	ldd	r19, Y+5	; 0x05
    2552:	8a 81       	ldd	r24, Y+2	; 0x02
    2554:	9b 81       	ldd	r25, Y+3	; 0x03
    2556:	28 17       	cp	r18, r24
    2558:	39 07       	cpc	r19, r25
    255a:	39 f0       	breq	.+14     	; 0x256a <vPolledQueueConsumer+0x5a>
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
    255c:	81 e0       	ldi	r24, 0x01	; 1
    255e:	89 83       	std	Y+1, r24	; 0x01

					/* Catch-up to the value we received so our next expected
					value should again be correct. */
					usExpectedValue = usData;
    2560:	8c 81       	ldd	r24, Y+4	; 0x04
    2562:	9d 81       	ldd	r25, Y+5	; 0x05
    2564:	9b 83       	std	Y+3, r25	; 0x03
    2566:	8a 83       	std	Y+2, r24	; 0x02
    2568:	0d c0       	rjmp	.+26     	; 0x2584 <vPolledQueueConsumer+0x74>
				}
				else
				{
					if( xError == pdFALSE )
    256a:	89 81       	ldd	r24, Y+1	; 0x01
    256c:	88 23       	and	r24, r24
    256e:	51 f4       	brne	.+20     	; 0x2584 <vPolledQueueConsumer+0x74>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
    2570:	0f b6       	in	r0, 0x3f	; 63
    2572:	f8 94       	cli
    2574:	0f 92       	push	r0
							xPollingConsumerCount++;
    2576:	80 91 7e 01 	lds	r24, 0x017E
    257a:	8f 5f       	subi	r24, 0xFF	; 255
    257c:	80 93 7e 01 	sts	0x017E, r24
						portEXIT_CRITICAL();
    2580:	0f 90       	pop	r0
    2582:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
    2584:	8a 81       	ldd	r24, Y+2	; 0x02
    2586:	9b 81       	ldd	r25, Y+3	; 0x03
    2588:	01 96       	adiw	r24, 0x01	; 1
    258a:	9b 83       	std	Y+3, r25	; 0x03
    258c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
    258e:	ee 81       	ldd	r30, Y+6	; 0x06
    2590:	ff 81       	ldd	r31, Y+7	; 0x07
    2592:	80 81       	ld	r24, Z
    2594:	91 81       	ldd	r25, Z+1	; 0x01
    2596:	0e 94 c3 21 	call	0x4386	; 0x4386 <uxQueueMessagesWaiting>
    259a:	88 23       	and	r24, r24
    259c:	49 f6       	brne	.-110    	; 0x2530 <vPolledQueueConsumer+0x20>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    259e:	84 eb       	ldi	r24, 0xB4	; 180
    25a0:	90 e0       	ldi	r25, 0x00	; 0
    25a2:	0e 94 47 27 	call	0x4e8e	; 0x4e8e <vTaskDelay>
    25a6:	f3 cf       	rjmp	.-26     	; 0x258e <vPolledQueueConsumer+0x7e>

000025a8 <xArePollingQueuesStillRunning>:
} /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running with no errors. */
BaseType_t xArePollingQueuesStillRunning( void )
{
    25a8:	df 93       	push	r29
    25aa:	cf 93       	push	r28
    25ac:	0f 92       	push	r0
    25ae:	cd b7       	in	r28, 0x3d	; 61
    25b0:	de b7       	in	r29, 0x3e	; 62

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    25b2:	80 91 7e 01 	lds	r24, 0x017E
    25b6:	88 23       	and	r24, r24
    25b8:	21 f0       	breq	.+8      	; 0x25c2 <xArePollingQueuesStillRunning+0x1a>
    25ba:	80 91 7f 01 	lds	r24, 0x017F
    25be:	88 23       	and	r24, r24
    25c0:	11 f4       	brne	.+4      	; 0x25c6 <xArePollingQueuesStillRunning+0x1e>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
    25c2:	19 82       	std	Y+1, r1	; 0x01
    25c4:	02 c0       	rjmp	.+4      	; 0x25ca <xArePollingQueuesStillRunning+0x22>
	}
	else
	{
		xReturn = pdTRUE;
    25c6:	81 e0       	ldi	r24, 0x01	; 1
    25c8:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    25ca:	10 92 7e 01 	sts	0x017E, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
    25ce:	10 92 7f 01 	sts	0x017F, r1

	return xReturn;
    25d2:	89 81       	ldd	r24, Y+1	; 0x01
}
    25d4:	0f 90       	pop	r0
    25d6:	cf 91       	pop	r28
    25d8:	df 91       	pop	r29
    25da:	08 95       	ret

000025dc <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    25dc:	df 93       	push	r29
    25de:	cf 93       	push	r28
    25e0:	cd b7       	in	r28, 0x3d	; 61
    25e2:	de b7       	in	r29, 0x3e	; 62
    25e4:	27 97       	sbiw	r28, 0x07	; 7
    25e6:	0f b6       	in	r0, 0x3f	; 63
    25e8:	f8 94       	cli
    25ea:	de bf       	out	0x3e, r29	; 62
    25ec:	0f be       	out	0x3f, r0	; 63
    25ee:	cd bf       	out	0x3d, r28	; 61
    25f0:	9d 83       	std	Y+5, r25	; 0x05
    25f2:	8c 83       	std	Y+4, r24	; 0x04
    25f4:	6e 83       	std	Y+6, r22	; 0x06
    25f6:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    25f8:	8a e1       	ldi	r24, 0x1A	; 26
    25fa:	90 e0       	ldi	r25, 0x00	; 0
    25fc:	0e 94 06 19 	call	0x320c	; 0x320c <pvPortMalloc>
    2600:	9a 83       	std	Y+2, r25	; 0x02
    2602:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    2604:	89 81       	ldd	r24, Y+1	; 0x01
    2606:	9a 81       	ldd	r25, Y+2	; 0x02
    2608:	00 97       	sbiw	r24, 0x00	; 0
    260a:	09 f4       	brne	.+2      	; 0x260e <xCoRoutineCreate+0x32>
    260c:	6f c0       	rjmp	.+222    	; 0x26ec <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    260e:	80 91 82 01 	lds	r24, 0x0182
    2612:	90 91 83 01 	lds	r25, 0x0183
    2616:	00 97       	sbiw	r24, 0x00	; 0
    2618:	41 f4       	brne	.+16     	; 0x262a <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    261a:	89 81       	ldd	r24, Y+1	; 0x01
    261c:	9a 81       	ldd	r25, Y+2	; 0x02
    261e:	90 93 83 01 	sts	0x0183, r25
    2622:	80 93 82 01 	sts	0x0182, r24
			prvInitialiseCoRoutineLists();
    2626:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    262a:	8e 81       	ldd	r24, Y+6	; 0x06
    262c:	82 30       	cpi	r24, 0x02	; 2
    262e:	10 f0       	brcs	.+4      	; 0x2634 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    2630:	81 e0       	ldi	r24, 0x01	; 1
    2632:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    2634:	e9 81       	ldd	r30, Y+1	; 0x01
    2636:	fa 81       	ldd	r31, Y+2	; 0x02
    2638:	11 8e       	std	Z+25, r1	; 0x19
    263a:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    263c:	e9 81       	ldd	r30, Y+1	; 0x01
    263e:	fa 81       	ldd	r31, Y+2	; 0x02
    2640:	8e 81       	ldd	r24, Y+6	; 0x06
    2642:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2644:	e9 81       	ldd	r30, Y+1	; 0x01
    2646:	fa 81       	ldd	r31, Y+2	; 0x02
    2648:	8f 81       	ldd	r24, Y+7	; 0x07
    264a:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    264c:	e9 81       	ldd	r30, Y+1	; 0x01
    264e:	fa 81       	ldd	r31, Y+2	; 0x02
    2650:	8c 81       	ldd	r24, Y+4	; 0x04
    2652:	9d 81       	ldd	r25, Y+5	; 0x05
    2654:	91 83       	std	Z+1, r25	; 0x01
    2656:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    2658:	89 81       	ldd	r24, Y+1	; 0x01
    265a:	9a 81       	ldd	r25, Y+2	; 0x02
    265c:	02 96       	adiw	r24, 0x02	; 2
    265e:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2662:	89 81       	ldd	r24, Y+1	; 0x01
    2664:	9a 81       	ldd	r25, Y+2	; 0x02
    2666:	0c 96       	adiw	r24, 0x0c	; 12
    2668:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    266c:	e9 81       	ldd	r30, Y+1	; 0x01
    266e:	fa 81       	ldd	r31, Y+2	; 0x02
    2670:	89 81       	ldd	r24, Y+1	; 0x01
    2672:	9a 81       	ldd	r25, Y+2	; 0x02
    2674:	91 87       	std	Z+9, r25	; 0x09
    2676:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2678:	e9 81       	ldd	r30, Y+1	; 0x01
    267a:	fa 81       	ldd	r31, Y+2	; 0x02
    267c:	89 81       	ldd	r24, Y+1	; 0x01
    267e:	9a 81       	ldd	r25, Y+2	; 0x02
    2680:	93 8b       	std	Z+19, r25	; 0x13
    2682:	82 8b       	std	Z+18, r24	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    2684:	8e 81       	ldd	r24, Y+6	; 0x06
    2686:	28 2f       	mov	r18, r24
    2688:	30 e0       	ldi	r19, 0x00	; 0
    268a:	82 e0       	ldi	r24, 0x02	; 2
    268c:	90 e0       	ldi	r25, 0x00	; 0
    268e:	82 1b       	sub	r24, r18
    2690:	93 0b       	sbc	r25, r19
    2692:	e9 81       	ldd	r30, Y+1	; 0x01
    2694:	fa 81       	ldd	r31, Y+2	; 0x02
    2696:	95 87       	std	Z+13, r25	; 0x0d
    2698:	84 87       	std	Z+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    269a:	e9 81       	ldd	r30, Y+1	; 0x01
    269c:	fa 81       	ldd	r31, Y+2	; 0x02
    269e:	96 89       	ldd	r25, Z+22	; 0x16
    26a0:	80 91 84 01 	lds	r24, 0x0184
    26a4:	89 17       	cp	r24, r25
    26a6:	28 f4       	brcc	.+10     	; 0x26b2 <xCoRoutineCreate+0xd6>
    26a8:	e9 81       	ldd	r30, Y+1	; 0x01
    26aa:	fa 81       	ldd	r31, Y+2	; 0x02
    26ac:	86 89       	ldd	r24, Z+22	; 0x16
    26ae:	80 93 84 01 	sts	0x0184, r24
    26b2:	e9 81       	ldd	r30, Y+1	; 0x01
    26b4:	fa 81       	ldd	r31, Y+2	; 0x02
    26b6:	86 89       	ldd	r24, Z+22	; 0x16
    26b8:	28 2f       	mov	r18, r24
    26ba:	30 e0       	ldi	r19, 0x00	; 0
    26bc:	c9 01       	movw	r24, r18
    26be:	88 0f       	add	r24, r24
    26c0:	99 1f       	adc	r25, r25
    26c2:	88 0f       	add	r24, r24
    26c4:	99 1f       	adc	r25, r25
    26c6:	88 0f       	add	r24, r24
    26c8:	99 1f       	adc	r25, r25
    26ca:	82 0f       	add	r24, r18
    26cc:	93 1f       	adc	r25, r19
    26ce:	ac 01       	movw	r20, r24
    26d0:	45 57       	subi	r20, 0x75	; 117
    26d2:	5e 4f       	sbci	r21, 0xFE	; 254
    26d4:	89 81       	ldd	r24, Y+1	; 0x01
    26d6:	9a 81       	ldd	r25, Y+2	; 0x02
    26d8:	9c 01       	movw	r18, r24
    26da:	2e 5f       	subi	r18, 0xFE	; 254
    26dc:	3f 4f       	sbci	r19, 0xFF	; 255
    26de:	ca 01       	movw	r24, r20
    26e0:	b9 01       	movw	r22, r18
    26e2:	0e 94 8e 1a 	call	0x351c	; 0x351c <vListInsertEnd>

		xReturn = pdPASS;
    26e6:	81 e0       	ldi	r24, 0x01	; 1
    26e8:	8b 83       	std	Y+3, r24	; 0x03
    26ea:	02 c0       	rjmp	.+4      	; 0x26f0 <xCoRoutineCreate+0x114>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    26ec:	8f ef       	ldi	r24, 0xFF	; 255
    26ee:	8b 83       	std	Y+3, r24	; 0x03
	}

	return xReturn;
    26f0:	8b 81       	ldd	r24, Y+3	; 0x03
}
    26f2:	27 96       	adiw	r28, 0x07	; 7
    26f4:	0f b6       	in	r0, 0x3f	; 63
    26f6:	f8 94       	cli
    26f8:	de bf       	out	0x3e, r29	; 62
    26fa:	0f be       	out	0x3f, r0	; 63
    26fc:	cd bf       	out	0x3d, r28	; 61
    26fe:	cf 91       	pop	r28
    2700:	df 91       	pop	r29
    2702:	08 95       	ret

00002704 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    2704:	df 93       	push	r29
    2706:	cf 93       	push	r28
    2708:	00 d0       	rcall	.+0      	; 0x270a <vCoRoutineAddToDelayedList+0x6>
    270a:	00 d0       	rcall	.+0      	; 0x270c <vCoRoutineAddToDelayedList+0x8>
    270c:	00 d0       	rcall	.+0      	; 0x270e <vCoRoutineAddToDelayedList+0xa>
    270e:	cd b7       	in	r28, 0x3d	; 61
    2710:	de b7       	in	r29, 0x3e	; 62
    2712:	9c 83       	std	Y+4, r25	; 0x04
    2714:	8b 83       	std	Y+3, r24	; 0x03
    2716:	7e 83       	std	Y+6, r23	; 0x06
    2718:	6d 83       	std	Y+5, r22	; 0x05
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    271a:	20 91 85 01 	lds	r18, 0x0185
    271e:	30 91 86 01 	lds	r19, 0x0186
    2722:	8b 81       	ldd	r24, Y+3	; 0x03
    2724:	9c 81       	ldd	r25, Y+4	; 0x04
    2726:	82 0f       	add	r24, r18
    2728:	93 1f       	adc	r25, r19
    272a:	9a 83       	std	Y+2, r25	; 0x02
    272c:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    272e:	80 91 82 01 	lds	r24, 0x0182
    2732:	90 91 83 01 	lds	r25, 0x0183
    2736:	02 96       	adiw	r24, 0x02	; 2
    2738:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    273c:	e0 91 82 01 	lds	r30, 0x0182
    2740:	f0 91 83 01 	lds	r31, 0x0183
    2744:	89 81       	ldd	r24, Y+1	; 0x01
    2746:	9a 81       	ldd	r25, Y+2	; 0x02
    2748:	93 83       	std	Z+3, r25	; 0x03
    274a:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    274c:	20 91 85 01 	lds	r18, 0x0185
    2750:	30 91 86 01 	lds	r19, 0x0186
    2754:	89 81       	ldd	r24, Y+1	; 0x01
    2756:	9a 81       	ldd	r25, Y+2	; 0x02
    2758:	82 17       	cp	r24, r18
    275a:	93 07       	cpc	r25, r19
    275c:	70 f4       	brcc	.+28     	; 0x277a <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    275e:	80 91 b1 01 	lds	r24, 0x01B1
    2762:	90 91 b2 01 	lds	r25, 0x01B2
    2766:	20 91 82 01 	lds	r18, 0x0182
    276a:	30 91 83 01 	lds	r19, 0x0183
    276e:	2e 5f       	subi	r18, 0xFE	; 254
    2770:	3f 4f       	sbci	r19, 0xFF	; 255
    2772:	b9 01       	movw	r22, r18
    2774:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <vListInsert>
    2778:	0d c0       	rjmp	.+26     	; 0x2794 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    277a:	80 91 af 01 	lds	r24, 0x01AF
    277e:	90 91 b0 01 	lds	r25, 0x01B0
    2782:	20 91 82 01 	lds	r18, 0x0182
    2786:	30 91 83 01 	lds	r19, 0x0183
    278a:	2e 5f       	subi	r18, 0xFE	; 254
    278c:	3f 4f       	sbci	r19, 0xFF	; 255
    278e:	b9 01       	movw	r22, r18
    2790:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <vListInsert>
	}

	if( pxEventList )
    2794:	8d 81       	ldd	r24, Y+5	; 0x05
    2796:	9e 81       	ldd	r25, Y+6	; 0x06
    2798:	00 97       	sbiw	r24, 0x00	; 0
    279a:	61 f0       	breq	.+24     	; 0x27b4 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    279c:	80 91 82 01 	lds	r24, 0x0182
    27a0:	90 91 83 01 	lds	r25, 0x0183
    27a4:	9c 01       	movw	r18, r24
    27a6:	24 5f       	subi	r18, 0xF4	; 244
    27a8:	3f 4f       	sbci	r19, 0xFF	; 255
    27aa:	8d 81       	ldd	r24, Y+5	; 0x05
    27ac:	9e 81       	ldd	r25, Y+6	; 0x06
    27ae:	b9 01       	movw	r22, r18
    27b0:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <vListInsert>
	}
}
    27b4:	26 96       	adiw	r28, 0x06	; 6
    27b6:	0f b6       	in	r0, 0x3f	; 63
    27b8:	f8 94       	cli
    27ba:	de bf       	out	0x3e, r29	; 62
    27bc:	0f be       	out	0x3f, r0	; 63
    27be:	cd bf       	out	0x3d, r28	; 61
    27c0:	cf 91       	pop	r28
    27c2:	df 91       	pop	r29
    27c4:	08 95       	ret

000027c6 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    27c6:	df 93       	push	r29
    27c8:	cf 93       	push	r28
    27ca:	00 d0       	rcall	.+0      	; 0x27cc <prvCheckPendingReadyList+0x6>
    27cc:	cd b7       	in	r28, 0x3d	; 61
    27ce:	de b7       	in	r29, 0x3e	; 62
    27d0:	3a c0       	rjmp	.+116    	; 0x2846 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    27d2:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    27d4:	e0 91 b8 01 	lds	r30, 0x01B8
    27d8:	f0 91 b9 01 	lds	r31, 0x01B9
    27dc:	86 81       	ldd	r24, Z+6	; 0x06
    27de:	97 81       	ldd	r25, Z+7	; 0x07
    27e0:	9a 83       	std	Y+2, r25	; 0x02
    27e2:	89 83       	std	Y+1, r24	; 0x01
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    27e4:	89 81       	ldd	r24, Y+1	; 0x01
    27e6:	9a 81       	ldd	r25, Y+2	; 0x02
    27e8:	0c 96       	adiw	r24, 0x0c	; 12
    27ea:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    27ee:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    27f0:	89 81       	ldd	r24, Y+1	; 0x01
    27f2:	9a 81       	ldd	r25, Y+2	; 0x02
    27f4:	02 96       	adiw	r24, 0x02	; 2
    27f6:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    27fa:	e9 81       	ldd	r30, Y+1	; 0x01
    27fc:	fa 81       	ldd	r31, Y+2	; 0x02
    27fe:	96 89       	ldd	r25, Z+22	; 0x16
    2800:	80 91 84 01 	lds	r24, 0x0184
    2804:	89 17       	cp	r24, r25
    2806:	28 f4       	brcc	.+10     	; 0x2812 <prvCheckPendingReadyList+0x4c>
    2808:	e9 81       	ldd	r30, Y+1	; 0x01
    280a:	fa 81       	ldd	r31, Y+2	; 0x02
    280c:	86 89       	ldd	r24, Z+22	; 0x16
    280e:	80 93 84 01 	sts	0x0184, r24
    2812:	e9 81       	ldd	r30, Y+1	; 0x01
    2814:	fa 81       	ldd	r31, Y+2	; 0x02
    2816:	86 89       	ldd	r24, Z+22	; 0x16
    2818:	28 2f       	mov	r18, r24
    281a:	30 e0       	ldi	r19, 0x00	; 0
    281c:	c9 01       	movw	r24, r18
    281e:	88 0f       	add	r24, r24
    2820:	99 1f       	adc	r25, r25
    2822:	88 0f       	add	r24, r24
    2824:	99 1f       	adc	r25, r25
    2826:	88 0f       	add	r24, r24
    2828:	99 1f       	adc	r25, r25
    282a:	82 0f       	add	r24, r18
    282c:	93 1f       	adc	r25, r19
    282e:	ac 01       	movw	r20, r24
    2830:	45 57       	subi	r20, 0x75	; 117
    2832:	5e 4f       	sbci	r21, 0xFE	; 254
    2834:	89 81       	ldd	r24, Y+1	; 0x01
    2836:	9a 81       	ldd	r25, Y+2	; 0x02
    2838:	9c 01       	movw	r18, r24
    283a:	2e 5f       	subi	r18, 0xFE	; 254
    283c:	3f 4f       	sbci	r19, 0xFF	; 255
    283e:	ca 01       	movw	r24, r20
    2840:	b9 01       	movw	r22, r18
    2842:	0e 94 8e 1a 	call	0x351c	; 0x351c <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2846:	80 91 b3 01 	lds	r24, 0x01B3
    284a:	88 23       	and	r24, r24
    284c:	09 f0       	breq	.+2      	; 0x2850 <prvCheckPendingReadyList+0x8a>
    284e:	c1 cf       	rjmp	.-126    	; 0x27d2 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
    2850:	0f 90       	pop	r0
    2852:	0f 90       	pop	r0
    2854:	cf 91       	pop	r28
    2856:	df 91       	pop	r29
    2858:	08 95       	ret

0000285a <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    285a:	df 93       	push	r29
    285c:	cf 93       	push	r28
    285e:	00 d0       	rcall	.+0      	; 0x2860 <prvCheckDelayedList+0x6>
    2860:	00 d0       	rcall	.+0      	; 0x2862 <prvCheckDelayedList+0x8>
    2862:	cd b7       	in	r28, 0x3d	; 61
    2864:	de b7       	in	r29, 0x3e	; 62
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2866:	0e 94 55 28 	call	0x50aa	; 0x50aa <xTaskGetTickCount>
    286a:	20 91 87 01 	lds	r18, 0x0187
    286e:	30 91 88 01 	lds	r19, 0x0188
    2872:	82 1b       	sub	r24, r18
    2874:	93 0b       	sbc	r25, r19
    2876:	90 93 8a 01 	sts	0x018A, r25
    287a:	80 93 89 01 	sts	0x0189, r24
    287e:	85 c0       	rjmp	.+266    	; 0x298a <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2880:	80 91 85 01 	lds	r24, 0x0185
    2884:	90 91 86 01 	lds	r25, 0x0186
    2888:	01 96       	adiw	r24, 0x01	; 1
    288a:	90 93 86 01 	sts	0x0186, r25
    288e:	80 93 85 01 	sts	0x0185, r24
		xPassedTicks--;
    2892:	80 91 89 01 	lds	r24, 0x0189
    2896:	90 91 8a 01 	lds	r25, 0x018A
    289a:	01 97       	sbiw	r24, 0x01	; 1
    289c:	90 93 8a 01 	sts	0x018A, r25
    28a0:	80 93 89 01 	sts	0x0189, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    28a4:	80 91 85 01 	lds	r24, 0x0185
    28a8:	90 91 86 01 	lds	r25, 0x0186
    28ac:	00 97       	sbiw	r24, 0x00	; 0
    28ae:	09 f0       	breq	.+2      	; 0x28b2 <prvCheckDelayedList+0x58>
    28b0:	64 c0       	rjmp	.+200    	; 0x297a <prvCheckDelayedList+0x120>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    28b2:	80 91 af 01 	lds	r24, 0x01AF
    28b6:	90 91 b0 01 	lds	r25, 0x01B0
    28ba:	9a 83       	std	Y+2, r25	; 0x02
    28bc:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    28be:	80 91 b1 01 	lds	r24, 0x01B1
    28c2:	90 91 b2 01 	lds	r25, 0x01B2
    28c6:	90 93 b0 01 	sts	0x01B0, r25
    28ca:	80 93 af 01 	sts	0x01AF, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    28ce:	89 81       	ldd	r24, Y+1	; 0x01
    28d0:	9a 81       	ldd	r25, Y+2	; 0x02
    28d2:	90 93 b2 01 	sts	0x01B2, r25
    28d6:	80 93 b1 01 	sts	0x01B1, r24
    28da:	4f c0       	rjmp	.+158    	; 0x297a <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    28dc:	e0 91 af 01 	lds	r30, 0x01AF
    28e0:	f0 91 b0 01 	lds	r31, 0x01B0
    28e4:	05 80       	ldd	r0, Z+5	; 0x05
    28e6:	f6 81       	ldd	r31, Z+6	; 0x06
    28e8:	e0 2d       	mov	r30, r0
    28ea:	86 81       	ldd	r24, Z+6	; 0x06
    28ec:	97 81       	ldd	r25, Z+7	; 0x07
    28ee:	9c 83       	std	Y+4, r25	; 0x04
    28f0:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    28f2:	eb 81       	ldd	r30, Y+3	; 0x03
    28f4:	fc 81       	ldd	r31, Y+4	; 0x04
    28f6:	22 81       	ldd	r18, Z+2	; 0x02
    28f8:	33 81       	ldd	r19, Z+3	; 0x03
    28fa:	80 91 85 01 	lds	r24, 0x0185
    28fe:	90 91 86 01 	lds	r25, 0x0186
    2902:	82 17       	cp	r24, r18
    2904:	93 07       	cpc	r25, r19
    2906:	08 f4       	brcc	.+2      	; 0x290a <prvCheckDelayedList+0xb0>
    2908:	40 c0       	rjmp	.+128    	; 0x298a <prvCheckDelayedList+0x130>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    290a:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    290c:	8b 81       	ldd	r24, Y+3	; 0x03
    290e:	9c 81       	ldd	r25, Y+4	; 0x04
    2910:	02 96       	adiw	r24, 0x02	; 2
    2912:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    2916:	eb 81       	ldd	r30, Y+3	; 0x03
    2918:	fc 81       	ldd	r31, Y+4	; 0x04
    291a:	84 89       	ldd	r24, Z+20	; 0x14
    291c:	95 89       	ldd	r25, Z+21	; 0x15
    291e:	00 97       	sbiw	r24, 0x00	; 0
    2920:	29 f0       	breq	.+10     	; 0x292c <prvCheckDelayedList+0xd2>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    2922:	8b 81       	ldd	r24, Y+3	; 0x03
    2924:	9c 81       	ldd	r25, Y+4	; 0x04
    2926:	0c 96       	adiw	r24, 0x0c	; 12
    2928:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    292c:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    292e:	eb 81       	ldd	r30, Y+3	; 0x03
    2930:	fc 81       	ldd	r31, Y+4	; 0x04
    2932:	96 89       	ldd	r25, Z+22	; 0x16
    2934:	80 91 84 01 	lds	r24, 0x0184
    2938:	89 17       	cp	r24, r25
    293a:	28 f4       	brcc	.+10     	; 0x2946 <prvCheckDelayedList+0xec>
    293c:	eb 81       	ldd	r30, Y+3	; 0x03
    293e:	fc 81       	ldd	r31, Y+4	; 0x04
    2940:	86 89       	ldd	r24, Z+22	; 0x16
    2942:	80 93 84 01 	sts	0x0184, r24
    2946:	eb 81       	ldd	r30, Y+3	; 0x03
    2948:	fc 81       	ldd	r31, Y+4	; 0x04
    294a:	86 89       	ldd	r24, Z+22	; 0x16
    294c:	28 2f       	mov	r18, r24
    294e:	30 e0       	ldi	r19, 0x00	; 0
    2950:	c9 01       	movw	r24, r18
    2952:	88 0f       	add	r24, r24
    2954:	99 1f       	adc	r25, r25
    2956:	88 0f       	add	r24, r24
    2958:	99 1f       	adc	r25, r25
    295a:	88 0f       	add	r24, r24
    295c:	99 1f       	adc	r25, r25
    295e:	82 0f       	add	r24, r18
    2960:	93 1f       	adc	r25, r19
    2962:	ac 01       	movw	r20, r24
    2964:	45 57       	subi	r20, 0x75	; 117
    2966:	5e 4f       	sbci	r21, 0xFE	; 254
    2968:	8b 81       	ldd	r24, Y+3	; 0x03
    296a:	9c 81       	ldd	r25, Y+4	; 0x04
    296c:	9c 01       	movw	r18, r24
    296e:	2e 5f       	subi	r18, 0xFE	; 254
    2970:	3f 4f       	sbci	r19, 0xFF	; 255
    2972:	ca 01       	movw	r24, r20
    2974:	b9 01       	movw	r22, r18
    2976:	0e 94 8e 1a 	call	0x351c	; 0x351c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    297a:	e0 91 af 01 	lds	r30, 0x01AF
    297e:	f0 91 b0 01 	lds	r31, 0x01B0
    2982:	80 81       	ld	r24, Z
    2984:	88 23       	and	r24, r24
    2986:	09 f0       	breq	.+2      	; 0x298a <prvCheckDelayedList+0x130>
    2988:	a9 cf       	rjmp	.-174    	; 0x28dc <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    298a:	80 91 89 01 	lds	r24, 0x0189
    298e:	90 91 8a 01 	lds	r25, 0x018A
    2992:	00 97       	sbiw	r24, 0x00	; 0
    2994:	09 f0       	breq	.+2      	; 0x2998 <prvCheckDelayedList+0x13e>
    2996:	74 cf       	rjmp	.-280    	; 0x2880 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    2998:	80 91 85 01 	lds	r24, 0x0185
    299c:	90 91 86 01 	lds	r25, 0x0186
    29a0:	90 93 88 01 	sts	0x0188, r25
    29a4:	80 93 87 01 	sts	0x0187, r24
}
    29a8:	0f 90       	pop	r0
    29aa:	0f 90       	pop	r0
    29ac:	0f 90       	pop	r0
    29ae:	0f 90       	pop	r0
    29b0:	cf 91       	pop	r28
    29b2:	df 91       	pop	r29
    29b4:	08 95       	ret

000029b6 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    29b6:	df 93       	push	r29
    29b8:	cf 93       	push	r28
    29ba:	00 d0       	rcall	.+0      	; 0x29bc <vCoRoutineSchedule+0x6>
    29bc:	cd b7       	in	r28, 0x3d	; 61
    29be:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    29c0:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    29c4:	0e 94 2d 14 	call	0x285a	; 0x285a <prvCheckDelayedList>
    29c8:	0a c0       	rjmp	.+20     	; 0x29de <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    29ca:	80 91 84 01 	lds	r24, 0x0184
    29ce:	88 23       	and	r24, r24
    29d0:	09 f4       	brne	.+2      	; 0x29d4 <vCoRoutineSchedule+0x1e>
    29d2:	66 c0       	rjmp	.+204    	; 0x2aa0 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    29d4:	80 91 84 01 	lds	r24, 0x0184
    29d8:	81 50       	subi	r24, 0x01	; 1
    29da:	80 93 84 01 	sts	0x0184, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    29de:	80 91 84 01 	lds	r24, 0x0184
    29e2:	28 2f       	mov	r18, r24
    29e4:	30 e0       	ldi	r19, 0x00	; 0
    29e6:	c9 01       	movw	r24, r18
    29e8:	88 0f       	add	r24, r24
    29ea:	99 1f       	adc	r25, r25
    29ec:	88 0f       	add	r24, r24
    29ee:	99 1f       	adc	r25, r25
    29f0:	88 0f       	add	r24, r24
    29f2:	99 1f       	adc	r25, r25
    29f4:	82 0f       	add	r24, r18
    29f6:	93 1f       	adc	r25, r19
    29f8:	fc 01       	movw	r30, r24
    29fa:	e5 57       	subi	r30, 0x75	; 117
    29fc:	fe 4f       	sbci	r31, 0xFE	; 254
    29fe:	80 81       	ld	r24, Z
    2a00:	88 23       	and	r24, r24
    2a02:	19 f3       	breq	.-58     	; 0x29ca <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2a04:	80 91 84 01 	lds	r24, 0x0184
    2a08:	28 2f       	mov	r18, r24
    2a0a:	30 e0       	ldi	r19, 0x00	; 0
    2a0c:	c9 01       	movw	r24, r18
    2a0e:	88 0f       	add	r24, r24
    2a10:	99 1f       	adc	r25, r25
    2a12:	88 0f       	add	r24, r24
    2a14:	99 1f       	adc	r25, r25
    2a16:	88 0f       	add	r24, r24
    2a18:	99 1f       	adc	r25, r25
    2a1a:	82 0f       	add	r24, r18
    2a1c:	93 1f       	adc	r25, r19
    2a1e:	85 57       	subi	r24, 0x75	; 117
    2a20:	9e 4f       	sbci	r25, 0xFE	; 254
    2a22:	9a 83       	std	Y+2, r25	; 0x02
    2a24:	89 83       	std	Y+1, r24	; 0x01
    2a26:	e9 81       	ldd	r30, Y+1	; 0x01
    2a28:	fa 81       	ldd	r31, Y+2	; 0x02
    2a2a:	01 80       	ldd	r0, Z+1	; 0x01
    2a2c:	f2 81       	ldd	r31, Z+2	; 0x02
    2a2e:	e0 2d       	mov	r30, r0
    2a30:	82 81       	ldd	r24, Z+2	; 0x02
    2a32:	93 81       	ldd	r25, Z+3	; 0x03
    2a34:	e9 81       	ldd	r30, Y+1	; 0x01
    2a36:	fa 81       	ldd	r31, Y+2	; 0x02
    2a38:	92 83       	std	Z+2, r25	; 0x02
    2a3a:	81 83       	std	Z+1, r24	; 0x01
    2a3c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a3e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a40:	21 81       	ldd	r18, Z+1	; 0x01
    2a42:	32 81       	ldd	r19, Z+2	; 0x02
    2a44:	89 81       	ldd	r24, Y+1	; 0x01
    2a46:	9a 81       	ldd	r25, Y+2	; 0x02
    2a48:	03 96       	adiw	r24, 0x03	; 3
    2a4a:	28 17       	cp	r18, r24
    2a4c:	39 07       	cpc	r19, r25
    2a4e:	59 f4       	brne	.+22     	; 0x2a66 <vCoRoutineSchedule+0xb0>
    2a50:	e9 81       	ldd	r30, Y+1	; 0x01
    2a52:	fa 81       	ldd	r31, Y+2	; 0x02
    2a54:	01 80       	ldd	r0, Z+1	; 0x01
    2a56:	f2 81       	ldd	r31, Z+2	; 0x02
    2a58:	e0 2d       	mov	r30, r0
    2a5a:	82 81       	ldd	r24, Z+2	; 0x02
    2a5c:	93 81       	ldd	r25, Z+3	; 0x03
    2a5e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a60:	fa 81       	ldd	r31, Y+2	; 0x02
    2a62:	92 83       	std	Z+2, r25	; 0x02
    2a64:	81 83       	std	Z+1, r24	; 0x01
    2a66:	e9 81       	ldd	r30, Y+1	; 0x01
    2a68:	fa 81       	ldd	r31, Y+2	; 0x02
    2a6a:	01 80       	ldd	r0, Z+1	; 0x01
    2a6c:	f2 81       	ldd	r31, Z+2	; 0x02
    2a6e:	e0 2d       	mov	r30, r0
    2a70:	86 81       	ldd	r24, Z+6	; 0x06
    2a72:	97 81       	ldd	r25, Z+7	; 0x07
    2a74:	90 93 83 01 	sts	0x0183, r25
    2a78:	80 93 82 01 	sts	0x0182, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2a7c:	e0 91 82 01 	lds	r30, 0x0182
    2a80:	f0 91 83 01 	lds	r31, 0x0183
    2a84:	40 81       	ld	r20, Z
    2a86:	51 81       	ldd	r21, Z+1	; 0x01
    2a88:	80 91 82 01 	lds	r24, 0x0182
    2a8c:	90 91 83 01 	lds	r25, 0x0183
    2a90:	e0 91 82 01 	lds	r30, 0x0182
    2a94:	f0 91 83 01 	lds	r31, 0x0183
    2a98:	27 89       	ldd	r18, Z+23	; 0x17
    2a9a:	62 2f       	mov	r22, r18
    2a9c:	fa 01       	movw	r30, r20
    2a9e:	09 95       	icall

	return;
}
    2aa0:	0f 90       	pop	r0
    2aa2:	0f 90       	pop	r0
    2aa4:	cf 91       	pop	r28
    2aa6:	df 91       	pop	r29
    2aa8:	08 95       	ret

00002aaa <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2aaa:	df 93       	push	r29
    2aac:	cf 93       	push	r28
    2aae:	0f 92       	push	r0
    2ab0:	cd b7       	in	r28, 0x3d	; 61
    2ab2:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2ab4:	19 82       	std	Y+1, r1	; 0x01
    2ab6:	13 c0       	rjmp	.+38     	; 0x2ade <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2ab8:	89 81       	ldd	r24, Y+1	; 0x01
    2aba:	28 2f       	mov	r18, r24
    2abc:	30 e0       	ldi	r19, 0x00	; 0
    2abe:	c9 01       	movw	r24, r18
    2ac0:	88 0f       	add	r24, r24
    2ac2:	99 1f       	adc	r25, r25
    2ac4:	88 0f       	add	r24, r24
    2ac6:	99 1f       	adc	r25, r25
    2ac8:	88 0f       	add	r24, r24
    2aca:	99 1f       	adc	r25, r25
    2acc:	82 0f       	add	r24, r18
    2ace:	93 1f       	adc	r25, r19
    2ad0:	85 57       	subi	r24, 0x75	; 117
    2ad2:	9e 4f       	sbci	r25, 0xFE	; 254
    2ad4:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2ad8:	89 81       	ldd	r24, Y+1	; 0x01
    2ada:	8f 5f       	subi	r24, 0xFF	; 255
    2adc:	89 83       	std	Y+1, r24	; 0x01
    2ade:	89 81       	ldd	r24, Y+1	; 0x01
    2ae0:	82 30       	cpi	r24, 0x02	; 2
    2ae2:	50 f3       	brcs	.-44     	; 0x2ab8 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    2ae4:	8d e9       	ldi	r24, 0x9D	; 157
    2ae6:	91 e0       	ldi	r25, 0x01	; 1
    2ae8:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    2aec:	86 ea       	ldi	r24, 0xA6	; 166
    2aee:	91 e0       	ldi	r25, 0x01	; 1
    2af0:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    2af4:	83 eb       	ldi	r24, 0xB3	; 179
    2af6:	91 e0       	ldi	r25, 0x01	; 1
    2af8:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2afc:	8d e9       	ldi	r24, 0x9D	; 157
    2afe:	91 e0       	ldi	r25, 0x01	; 1
    2b00:	90 93 b0 01 	sts	0x01B0, r25
    2b04:	80 93 af 01 	sts	0x01AF, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2b08:	86 ea       	ldi	r24, 0xA6	; 166
    2b0a:	91 e0       	ldi	r25, 0x01	; 1
    2b0c:	90 93 b2 01 	sts	0x01B2, r25
    2b10:	80 93 b1 01 	sts	0x01B1, r24
}
    2b14:	0f 90       	pop	r0
    2b16:	cf 91       	pop	r28
    2b18:	df 91       	pop	r29
    2b1a:	08 95       	ret

00002b1c <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    2b1c:	df 93       	push	r29
    2b1e:	cf 93       	push	r28
    2b20:	00 d0       	rcall	.+0      	; 0x2b22 <xCoRoutineRemoveFromEventList+0x6>
    2b22:	00 d0       	rcall	.+0      	; 0x2b24 <xCoRoutineRemoveFromEventList+0x8>
    2b24:	0f 92       	push	r0
    2b26:	cd b7       	in	r28, 0x3d	; 61
    2b28:	de b7       	in	r29, 0x3e	; 62
    2b2a:	9d 83       	std	Y+5, r25	; 0x05
    2b2c:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2b2e:	ec 81       	ldd	r30, Y+4	; 0x04
    2b30:	fd 81       	ldd	r31, Y+5	; 0x05
    2b32:	05 80       	ldd	r0, Z+5	; 0x05
    2b34:	f6 81       	ldd	r31, Z+6	; 0x06
    2b36:	e0 2d       	mov	r30, r0
    2b38:	86 81       	ldd	r24, Z+6	; 0x06
    2b3a:	97 81       	ldd	r25, Z+7	; 0x07
    2b3c:	9b 83       	std	Y+3, r25	; 0x03
    2b3e:	8a 83       	std	Y+2, r24	; 0x02
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2b40:	8a 81       	ldd	r24, Y+2	; 0x02
    2b42:	9b 81       	ldd	r25, Y+3	; 0x03
    2b44:	0c 96       	adiw	r24, 0x0c	; 12
    2b46:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2b4a:	8a 81       	ldd	r24, Y+2	; 0x02
    2b4c:	9b 81       	ldd	r25, Y+3	; 0x03
    2b4e:	9c 01       	movw	r18, r24
    2b50:	24 5f       	subi	r18, 0xF4	; 244
    2b52:	3f 4f       	sbci	r19, 0xFF	; 255
    2b54:	83 eb       	ldi	r24, 0xB3	; 179
    2b56:	91 e0       	ldi	r25, 0x01	; 1
    2b58:	b9 01       	movw	r22, r18
    2b5a:	0e 94 8e 1a 	call	0x351c	; 0x351c <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2b5e:	ea 81       	ldd	r30, Y+2	; 0x02
    2b60:	fb 81       	ldd	r31, Y+3	; 0x03
    2b62:	96 89       	ldd	r25, Z+22	; 0x16
    2b64:	e0 91 82 01 	lds	r30, 0x0182
    2b68:	f0 91 83 01 	lds	r31, 0x0183
    2b6c:	86 89       	ldd	r24, Z+22	; 0x16
    2b6e:	98 17       	cp	r25, r24
    2b70:	18 f0       	brcs	.+6      	; 0x2b78 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2b72:	81 e0       	ldi	r24, 0x01	; 1
    2b74:	89 83       	std	Y+1, r24	; 0x01
    2b76:	01 c0       	rjmp	.+2      	; 0x2b7a <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    2b78:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2b7a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2b7c:	0f 90       	pop	r0
    2b7e:	0f 90       	pop	r0
    2b80:	0f 90       	pop	r0
    2b82:	0f 90       	pop	r0
    2b84:	0f 90       	pop	r0
    2b86:	cf 91       	pop	r28
    2b88:	df 91       	pop	r29
    2b8a:	08 95       	ret

00002b8c <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
    2b8c:	df 93       	push	r29
    2b8e:	cf 93       	push	r28
    2b90:	00 d0       	rcall	.+0      	; 0x2b92 <xEventGroupCreate+0x6>
    2b92:	cd b7       	in	r28, 0x3d	; 61
    2b94:	de b7       	in	r29, 0x3e	; 62
EventGroup_t *pxEventBits;

	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
    2b96:	8b e0       	ldi	r24, 0x0B	; 11
    2b98:	90 e0       	ldi	r25, 0x00	; 0
    2b9a:	0e 94 06 19 	call	0x320c	; 0x320c <pvPortMalloc>
    2b9e:	9a 83       	std	Y+2, r25	; 0x02
    2ba0:	89 83       	std	Y+1, r24	; 0x01
	if( pxEventBits != NULL )
    2ba2:	89 81       	ldd	r24, Y+1	; 0x01
    2ba4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ba6:	00 97       	sbiw	r24, 0x00	; 0
    2ba8:	49 f0       	breq	.+18     	; 0x2bbc <xEventGroupCreate+0x30>
	{
		pxEventBits->uxEventBits = 0;
    2baa:	e9 81       	ldd	r30, Y+1	; 0x01
    2bac:	fa 81       	ldd	r31, Y+2	; 0x02
    2bae:	11 82       	std	Z+1, r1	; 0x01
    2bb0:	10 82       	st	Z, r1
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    2bb2:	89 81       	ldd	r24, Y+1	; 0x01
    2bb4:	9a 81       	ldd	r25, Y+2	; 0x02
    2bb6:	02 96       	adiw	r24, 0x02	; 2
    2bb8:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <vListInitialise>
	else
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
    2bbc:	89 81       	ldd	r24, Y+1	; 0x01
    2bbe:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2bc0:	0f 90       	pop	r0
    2bc2:	0f 90       	pop	r0
    2bc4:	cf 91       	pop	r28
    2bc6:	df 91       	pop	r29
    2bc8:	08 95       	ret

00002bca <xEventGroupSync>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    2bca:	df 93       	push	r29
    2bcc:	cf 93       	push	r28
    2bce:	cd b7       	in	r28, 0x3d	; 61
    2bd0:	de b7       	in	r29, 0x3e	; 62
    2bd2:	60 97       	sbiw	r28, 0x10	; 16
    2bd4:	0f b6       	in	r0, 0x3f	; 63
    2bd6:	f8 94       	cli
    2bd8:	de bf       	out	0x3e, r29	; 62
    2bda:	0f be       	out	0x3f, r0	; 63
    2bdc:	cd bf       	out	0x3d, r28	; 61
    2bde:	9a 87       	std	Y+10, r25	; 0x0a
    2be0:	89 87       	std	Y+9, r24	; 0x09
    2be2:	7c 87       	std	Y+12, r23	; 0x0c
    2be4:	6b 87       	std	Y+11, r22	; 0x0b
    2be6:	5e 87       	std	Y+14, r21	; 0x0e
    2be8:	4d 87       	std	Y+13, r20	; 0x0d
    2bea:	38 8b       	std	Y+16, r19	; 0x10
    2bec:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    2bee:	89 85       	ldd	r24, Y+9	; 0x09
    2bf0:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bf2:	9c 83       	std	Y+4, r25	; 0x04
    2bf4:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    2bf6:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2bf8:	0e 94 bf 27 	call	0x4f7e	; 0x4f7e <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    2bfc:	eb 81       	ldd	r30, Y+3	; 0x03
    2bfe:	fc 81       	ldd	r31, Y+4	; 0x04
    2c00:	80 81       	ld	r24, Z
    2c02:	91 81       	ldd	r25, Z+1	; 0x01
    2c04:	98 87       	std	Y+8, r25	; 0x08
    2c06:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    2c08:	89 85       	ldd	r24, Y+9	; 0x09
    2c0a:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c0c:	2b 85       	ldd	r18, Y+11	; 0x0b
    2c0e:	3c 85       	ldd	r19, Y+12	; 0x0c
    2c10:	b9 01       	movw	r22, r18
    2c12:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2c16:	2f 81       	ldd	r18, Y+7	; 0x07
    2c18:	38 85       	ldd	r19, Y+8	; 0x08
    2c1a:	8b 85       	ldd	r24, Y+11	; 0x0b
    2c1c:	9c 85       	ldd	r25, Y+12	; 0x0c
    2c1e:	28 2b       	or	r18, r24
    2c20:	39 2b       	or	r19, r25
    2c22:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c24:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c26:	28 23       	and	r18, r24
    2c28:	39 23       	and	r19, r25
    2c2a:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c2c:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c2e:	28 17       	cp	r18, r24
    2c30:	39 07       	cpc	r19, r25
    2c32:	c9 f4       	brne	.+50     	; 0x2c66 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    2c34:	2f 81       	ldd	r18, Y+7	; 0x07
    2c36:	38 85       	ldd	r19, Y+8	; 0x08
    2c38:	8b 85       	ldd	r24, Y+11	; 0x0b
    2c3a:	9c 85       	ldd	r25, Y+12	; 0x0c
    2c3c:	82 2b       	or	r24, r18
    2c3e:	93 2b       	or	r25, r19
    2c40:	9e 83       	std	Y+6, r25	; 0x06
    2c42:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2c44:	eb 81       	ldd	r30, Y+3	; 0x03
    2c46:	fc 81       	ldd	r31, Y+4	; 0x04
    2c48:	20 81       	ld	r18, Z
    2c4a:	31 81       	ldd	r19, Z+1	; 0x01
    2c4c:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c4e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c50:	80 95       	com	r24
    2c52:	90 95       	com	r25
    2c54:	82 23       	and	r24, r18
    2c56:	93 23       	and	r25, r19
    2c58:	eb 81       	ldd	r30, Y+3	; 0x03
    2c5a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c5c:	91 83       	std	Z+1, r25	; 0x01
    2c5e:	80 83       	st	Z, r24

			xTicksToWait = 0;
    2c60:	18 8a       	std	Y+16, r1	; 0x10
    2c62:	1f 86       	std	Y+15, r1	; 0x0f
    2c64:	1c c0       	rjmp	.+56     	; 0x2c9e <xEventGroupSync+0xd4>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    2c66:	8f 85       	ldd	r24, Y+15	; 0x0f
    2c68:	98 89       	ldd	r25, Y+16	; 0x10
    2c6a:	00 97       	sbiw	r24, 0x00	; 0
    2c6c:	91 f0       	breq	.+36     	; 0x2c92 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    2c6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c70:	9c 81       	ldd	r25, Y+4	; 0x04
    2c72:	bc 01       	movw	r22, r24
    2c74:	6e 5f       	subi	r22, 0xFE	; 254
    2c76:	7f 4f       	sbci	r23, 0xFF	; 255
    2c78:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c7a:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c7c:	9c 01       	movw	r18, r24
    2c7e:	35 60       	ori	r19, 0x05	; 5
    2c80:	4f 85       	ldd	r20, Y+15	; 0x0f
    2c82:	58 89       	ldd	r21, Y+16	; 0x10
    2c84:	cb 01       	movw	r24, r22
    2c86:	b9 01       	movw	r22, r18
    2c88:	0e 94 0f 2a 	call	0x541e	; 0x541e <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    2c8c:	1e 82       	std	Y+6, r1	; 0x06
    2c8e:	1d 82       	std	Y+5, r1	; 0x05
    2c90:	06 c0       	rjmp	.+12     	; 0x2c9e <xEventGroupSync+0xd4>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    2c92:	eb 81       	ldd	r30, Y+3	; 0x03
    2c94:	fc 81       	ldd	r31, Y+4	; 0x04
    2c96:	80 81       	ld	r24, Z
    2c98:	91 81       	ldd	r25, Z+1	; 0x01
    2c9a:	9e 83       	std	Y+6, r25	; 0x06
    2c9c:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2c9e:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <xTaskResumeAll>
    2ca2:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    2ca4:	8f 85       	ldd	r24, Y+15	; 0x0f
    2ca6:	98 89       	ldd	r25, Y+16	; 0x10
    2ca8:	00 97       	sbiw	r24, 0x00	; 0
    2caa:	09 f4       	brne	.+2      	; 0x2cae <xEventGroupSync+0xe4>
    2cac:	3a c0       	rjmp	.+116    	; 0x2d22 <xEventGroupSync+0x158>
	{
		if( xAlreadyYielded == pdFALSE )
    2cae:	8a 81       	ldd	r24, Y+2	; 0x02
    2cb0:	88 23       	and	r24, r24
    2cb2:	11 f4       	brne	.+4      	; 0x2cb8 <xEventGroupSync+0xee>
		{
			portYIELD_WITHIN_API();
    2cb4:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2cb8:	0e 94 75 2d 	call	0x5aea	; 0x5aea <uxTaskResetEventItemValue>
    2cbc:	9e 83       	std	Y+6, r25	; 0x06
    2cbe:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2cc0:	8d 81       	ldd	r24, Y+5	; 0x05
    2cc2:	9e 81       	ldd	r25, Y+6	; 0x06
    2cc4:	80 70       	andi	r24, 0x00	; 0
    2cc6:	92 70       	andi	r25, 0x02	; 2
    2cc8:	00 97       	sbiw	r24, 0x00	; 0
    2cca:	31 f5       	brne	.+76     	; 0x2d18 <xEventGroupSync+0x14e>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    2ccc:	0f b6       	in	r0, 0x3f	; 63
    2cce:	f8 94       	cli
    2cd0:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    2cd2:	eb 81       	ldd	r30, Y+3	; 0x03
    2cd4:	fc 81       	ldd	r31, Y+4	; 0x04
    2cd6:	80 81       	ld	r24, Z
    2cd8:	91 81       	ldd	r25, Z+1	; 0x01
    2cda:	9e 83       	std	Y+6, r25	; 0x06
    2cdc:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2cde:	2d 81       	ldd	r18, Y+5	; 0x05
    2ce0:	3e 81       	ldd	r19, Y+6	; 0x06
    2ce2:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ce4:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ce6:	28 23       	and	r18, r24
    2ce8:	39 23       	and	r19, r25
    2cea:	8d 85       	ldd	r24, Y+13	; 0x0d
    2cec:	9e 85       	ldd	r25, Y+14	; 0x0e
    2cee:	28 17       	cp	r18, r24
    2cf0:	39 07       	cpc	r19, r25
    2cf2:	71 f4       	brne	.+28     	; 0x2d10 <xEventGroupSync+0x146>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2cf4:	eb 81       	ldd	r30, Y+3	; 0x03
    2cf6:	fc 81       	ldd	r31, Y+4	; 0x04
    2cf8:	20 81       	ld	r18, Z
    2cfa:	31 81       	ldd	r19, Z+1	; 0x01
    2cfc:	8d 85       	ldd	r24, Y+13	; 0x0d
    2cfe:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d00:	80 95       	com	r24
    2d02:	90 95       	com	r25
    2d04:	82 23       	and	r24, r18
    2d06:	93 23       	and	r25, r19
    2d08:	eb 81       	ldd	r30, Y+3	; 0x03
    2d0a:	fc 81       	ldd	r31, Y+4	; 0x04
    2d0c:	91 83       	std	Z+1, r25	; 0x01
    2d0e:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2d10:	0f 90       	pop	r0
    2d12:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    2d14:	81 e0       	ldi	r24, 0x01	; 1
    2d16:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2d18:	8d 81       	ldd	r24, Y+5	; 0x05
    2d1a:	9e 81       	ldd	r25, Y+6	; 0x06
    2d1c:	90 70       	andi	r25, 0x00	; 0
    2d1e:	9e 83       	std	Y+6, r25	; 0x06
    2d20:	8d 83       	std	Y+5, r24	; 0x05
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    2d22:	8d 81       	ldd	r24, Y+5	; 0x05
    2d24:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2d26:	60 96       	adiw	r28, 0x10	; 16
    2d28:	0f b6       	in	r0, 0x3f	; 63
    2d2a:	f8 94       	cli
    2d2c:	de bf       	out	0x3e, r29	; 62
    2d2e:	0f be       	out	0x3f, r0	; 63
    2d30:	cd bf       	out	0x3d, r28	; 61
    2d32:	cf 91       	pop	r28
    2d34:	df 91       	pop	r29
    2d36:	08 95       	ret

00002d38 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    2d38:	0f 93       	push	r16
    2d3a:	1f 93       	push	r17
    2d3c:	df 93       	push	r29
    2d3e:	cf 93       	push	r28
    2d40:	cd b7       	in	r28, 0x3d	; 61
    2d42:	de b7       	in	r29, 0x3e	; 62
    2d44:	63 97       	sbiw	r28, 0x13	; 19
    2d46:	0f b6       	in	r0, 0x3f	; 63
    2d48:	f8 94       	cli
    2d4a:	de bf       	out	0x3e, r29	; 62
    2d4c:	0f be       	out	0x3f, r0	; 63
    2d4e:	cd bf       	out	0x3d, r28	; 61
    2d50:	9d 87       	std	Y+13, r25	; 0x0d
    2d52:	8c 87       	std	Y+12, r24	; 0x0c
    2d54:	7f 87       	std	Y+15, r23	; 0x0f
    2d56:	6e 87       	std	Y+14, r22	; 0x0e
    2d58:	48 8b       	std	Y+16, r20	; 0x10
    2d5a:	29 8b       	std	Y+17, r18	; 0x11
    2d5c:	1b 8b       	std	Y+19, r17	; 0x13
    2d5e:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    2d60:	8c 85       	ldd	r24, Y+12	; 0x0c
    2d62:	9d 85       	ldd	r25, Y+13	; 0x0d
    2d64:	9b 87       	std	Y+11, r25	; 0x0b
    2d66:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    2d68:	1f 82       	std	Y+7, r1	; 0x07
    2d6a:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    2d6c:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2d6e:	0e 94 bf 27 	call	0x4f7e	; 0x4f7e <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    2d72:	ea 85       	ldd	r30, Y+10	; 0x0a
    2d74:	fb 85       	ldd	r31, Y+11	; 0x0b
    2d76:	80 81       	ld	r24, Z
    2d78:	91 81       	ldd	r25, Z+1	; 0x01
    2d7a:	9a 83       	std	Y+2, r25	; 0x02
    2d7c:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    2d7e:	89 81       	ldd	r24, Y+1	; 0x01
    2d80:	9a 81       	ldd	r25, Y+2	; 0x02
    2d82:	2e 85       	ldd	r18, Y+14	; 0x0e
    2d84:	3f 85       	ldd	r19, Y+15	; 0x0f
    2d86:	b9 01       	movw	r22, r18
    2d88:	49 89       	ldd	r20, Y+17	; 0x11
    2d8a:	0e 94 d4 18 	call	0x31a8	; 0x31a8 <prvTestWaitCondition>
    2d8e:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    2d90:	8d 81       	ldd	r24, Y+5	; 0x05
    2d92:	88 23       	and	r24, r24
    2d94:	c1 f0       	breq	.+48     	; 0x2dc6 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    2d96:	89 81       	ldd	r24, Y+1	; 0x01
    2d98:	9a 81       	ldd	r25, Y+2	; 0x02
    2d9a:	99 87       	std	Y+9, r25	; 0x09
    2d9c:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    2d9e:	1b 8a       	std	Y+19, r1	; 0x13
    2da0:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    2da2:	88 89       	ldd	r24, Y+16	; 0x10
    2da4:	88 23       	and	r24, r24
    2da6:	d9 f1       	breq	.+118    	; 0x2e1e <xEventGroupWaitBits+0xe6>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2da8:	ea 85       	ldd	r30, Y+10	; 0x0a
    2daa:	fb 85       	ldd	r31, Y+11	; 0x0b
    2dac:	20 81       	ld	r18, Z
    2dae:	31 81       	ldd	r19, Z+1	; 0x01
    2db0:	8e 85       	ldd	r24, Y+14	; 0x0e
    2db2:	9f 85       	ldd	r25, Y+15	; 0x0f
    2db4:	80 95       	com	r24
    2db6:	90 95       	com	r25
    2db8:	82 23       	and	r24, r18
    2dba:	93 23       	and	r25, r19
    2dbc:	ea 85       	ldd	r30, Y+10	; 0x0a
    2dbe:	fb 85       	ldd	r31, Y+11	; 0x0b
    2dc0:	91 83       	std	Z+1, r25	; 0x01
    2dc2:	80 83       	st	Z, r24
    2dc4:	2c c0       	rjmp	.+88     	; 0x2e1e <xEventGroupWaitBits+0xe6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    2dc6:	8a 89       	ldd	r24, Y+18	; 0x12
    2dc8:	9b 89       	ldd	r25, Y+19	; 0x13
    2dca:	00 97       	sbiw	r24, 0x00	; 0
    2dcc:	29 f4       	brne	.+10     	; 0x2dd8 <xEventGroupWaitBits+0xa0>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    2dce:	89 81       	ldd	r24, Y+1	; 0x01
    2dd0:	9a 81       	ldd	r25, Y+2	; 0x02
    2dd2:	99 87       	std	Y+9, r25	; 0x09
    2dd4:	88 87       	std	Y+8, r24	; 0x08
    2dd6:	23 c0       	rjmp	.+70     	; 0x2e1e <xEventGroupWaitBits+0xe6>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    2dd8:	88 89       	ldd	r24, Y+16	; 0x10
    2dda:	88 23       	and	r24, r24
    2ddc:	29 f0       	breq	.+10     	; 0x2de8 <xEventGroupWaitBits+0xb0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    2dde:	8e 81       	ldd	r24, Y+6	; 0x06
    2de0:	9f 81       	ldd	r25, Y+7	; 0x07
    2de2:	91 60       	ori	r25, 0x01	; 1
    2de4:	9f 83       	std	Y+7, r25	; 0x07
    2de6:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    2de8:	89 89       	ldd	r24, Y+17	; 0x11
    2dea:	88 23       	and	r24, r24
    2dec:	29 f0       	breq	.+10     	; 0x2df8 <xEventGroupWaitBits+0xc0>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    2dee:	8e 81       	ldd	r24, Y+6	; 0x06
    2df0:	9f 81       	ldd	r25, Y+7	; 0x07
    2df2:	94 60       	ori	r25, 0x04	; 4
    2df4:	9f 83       	std	Y+7, r25	; 0x07
    2df6:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    2df8:	8a 85       	ldd	r24, Y+10	; 0x0a
    2dfa:	9b 85       	ldd	r25, Y+11	; 0x0b
    2dfc:	bc 01       	movw	r22, r24
    2dfe:	6e 5f       	subi	r22, 0xFE	; 254
    2e00:	7f 4f       	sbci	r23, 0xFF	; 255
    2e02:	2e 85       	ldd	r18, Y+14	; 0x0e
    2e04:	3f 85       	ldd	r19, Y+15	; 0x0f
    2e06:	8e 81       	ldd	r24, Y+6	; 0x06
    2e08:	9f 81       	ldd	r25, Y+7	; 0x07
    2e0a:	28 2b       	or	r18, r24
    2e0c:	39 2b       	or	r19, r25
    2e0e:	4a 89       	ldd	r20, Y+18	; 0x12
    2e10:	5b 89       	ldd	r21, Y+19	; 0x13
    2e12:	cb 01       	movw	r24, r22
    2e14:	b9 01       	movw	r22, r18
    2e16:	0e 94 0f 2a 	call	0x541e	; 0x541e <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    2e1a:	19 86       	std	Y+9, r1	; 0x09
    2e1c:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2e1e:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <xTaskResumeAll>
    2e22:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    2e24:	8a 89       	ldd	r24, Y+18	; 0x12
    2e26:	9b 89       	ldd	r25, Y+19	; 0x13
    2e28:	00 97       	sbiw	r24, 0x00	; 0
    2e2a:	09 f4       	brne	.+2      	; 0x2e2e <xEventGroupWaitBits+0xf6>
    2e2c:	3b c0       	rjmp	.+118    	; 0x2ea4 <xEventGroupWaitBits+0x16c>
	{
		if( xAlreadyYielded == pdFALSE )
    2e2e:	8c 81       	ldd	r24, Y+4	; 0x04
    2e30:	88 23       	and	r24, r24
    2e32:	11 f4       	brne	.+4      	; 0x2e38 <xEventGroupWaitBits+0x100>
		{
			portYIELD_WITHIN_API();
    2e34:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2e38:	0e 94 75 2d 	call	0x5aea	; 0x5aea <uxTaskResetEventItemValue>
    2e3c:	99 87       	std	Y+9, r25	; 0x09
    2e3e:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2e40:	88 85       	ldd	r24, Y+8	; 0x08
    2e42:	99 85       	ldd	r25, Y+9	; 0x09
    2e44:	80 70       	andi	r24, 0x00	; 0
    2e46:	92 70       	andi	r25, 0x02	; 2
    2e48:	00 97       	sbiw	r24, 0x00	; 0
    2e4a:	39 f5       	brne	.+78     	; 0x2e9a <xEventGroupWaitBits+0x162>
		{
			taskENTER_CRITICAL();
    2e4c:	0f b6       	in	r0, 0x3f	; 63
    2e4e:	f8 94       	cli
    2e50:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    2e52:	ea 85       	ldd	r30, Y+10	; 0x0a
    2e54:	fb 85       	ldd	r31, Y+11	; 0x0b
    2e56:	80 81       	ld	r24, Z
    2e58:	91 81       	ldd	r25, Z+1	; 0x01
    2e5a:	99 87       	std	Y+9, r25	; 0x09
    2e5c:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    2e5e:	88 85       	ldd	r24, Y+8	; 0x08
    2e60:	99 85       	ldd	r25, Y+9	; 0x09
    2e62:	2e 85       	ldd	r18, Y+14	; 0x0e
    2e64:	3f 85       	ldd	r19, Y+15	; 0x0f
    2e66:	b9 01       	movw	r22, r18
    2e68:	49 89       	ldd	r20, Y+17	; 0x11
    2e6a:	0e 94 d4 18 	call	0x31a8	; 0x31a8 <prvTestWaitCondition>
    2e6e:	88 23       	and	r24, r24
    2e70:	89 f0       	breq	.+34     	; 0x2e94 <xEventGroupWaitBits+0x15c>
				{
					if( xClearOnExit != pdFALSE )
    2e72:	88 89       	ldd	r24, Y+16	; 0x10
    2e74:	88 23       	and	r24, r24
    2e76:	71 f0       	breq	.+28     	; 0x2e94 <xEventGroupWaitBits+0x15c>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2e78:	ea 85       	ldd	r30, Y+10	; 0x0a
    2e7a:	fb 85       	ldd	r31, Y+11	; 0x0b
    2e7c:	20 81       	ld	r18, Z
    2e7e:	31 81       	ldd	r19, Z+1	; 0x01
    2e80:	8e 85       	ldd	r24, Y+14	; 0x0e
    2e82:	9f 85       	ldd	r25, Y+15	; 0x0f
    2e84:	80 95       	com	r24
    2e86:	90 95       	com	r25
    2e88:	82 23       	and	r24, r18
    2e8a:	93 23       	and	r25, r19
    2e8c:	ea 85       	ldd	r30, Y+10	; 0x0a
    2e8e:	fb 85       	ldd	r31, Y+11	; 0x0b
    2e90:	91 83       	std	Z+1, r25	; 0x01
    2e92:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2e94:	0f 90       	pop	r0
    2e96:	0f be       	out	0x3f, r0	; 63

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
    2e98:	1b 82       	std	Y+3, r1	; 0x03
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2e9a:	88 85       	ldd	r24, Y+8	; 0x08
    2e9c:	99 85       	ldd	r25, Y+9	; 0x09
    2e9e:	90 70       	andi	r25, 0x00	; 0
    2ea0:	99 87       	std	Y+9, r25	; 0x09
    2ea2:	88 87       	std	Y+8, r24	; 0x08
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    2ea4:	88 85       	ldd	r24, Y+8	; 0x08
    2ea6:	99 85       	ldd	r25, Y+9	; 0x09
}
    2ea8:	63 96       	adiw	r28, 0x13	; 19
    2eaa:	0f b6       	in	r0, 0x3f	; 63
    2eac:	f8 94       	cli
    2eae:	de bf       	out	0x3e, r29	; 62
    2eb0:	0f be       	out	0x3f, r0	; 63
    2eb2:	cd bf       	out	0x3d, r28	; 61
    2eb4:	cf 91       	pop	r28
    2eb6:	df 91       	pop	r29
    2eb8:	1f 91       	pop	r17
    2eba:	0f 91       	pop	r16
    2ebc:	08 95       	ret

00002ebe <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    2ebe:	df 93       	push	r29
    2ec0:	cf 93       	push	r28
    2ec2:	cd b7       	in	r28, 0x3d	; 61
    2ec4:	de b7       	in	r29, 0x3e	; 62
    2ec6:	28 97       	sbiw	r28, 0x08	; 8
    2ec8:	0f b6       	in	r0, 0x3f	; 63
    2eca:	f8 94       	cli
    2ecc:	de bf       	out	0x3e, r29	; 62
    2ece:	0f be       	out	0x3f, r0	; 63
    2ed0:	cd bf       	out	0x3d, r28	; 61
    2ed2:	9e 83       	std	Y+6, r25	; 0x06
    2ed4:	8d 83       	std	Y+5, r24	; 0x05
    2ed6:	78 87       	std	Y+8, r23	; 0x08
    2ed8:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    2eda:	8d 81       	ldd	r24, Y+5	; 0x05
    2edc:	9e 81       	ldd	r25, Y+6	; 0x06
    2ede:	9c 83       	std	Y+4, r25	; 0x04
    2ee0:	8b 83       	std	Y+3, r24	; 0x03

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    2ee2:	0f b6       	in	r0, 0x3f	; 63
    2ee4:	f8 94       	cli
    2ee6:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    2ee8:	eb 81       	ldd	r30, Y+3	; 0x03
    2eea:	fc 81       	ldd	r31, Y+4	; 0x04
    2eec:	80 81       	ld	r24, Z
    2eee:	91 81       	ldd	r25, Z+1	; 0x01
    2ef0:	9a 83       	std	Y+2, r25	; 0x02
    2ef2:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    2ef4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ef6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ef8:	20 81       	ld	r18, Z
    2efa:	31 81       	ldd	r19, Z+1	; 0x01
    2efc:	8f 81       	ldd	r24, Y+7	; 0x07
    2efe:	98 85       	ldd	r25, Y+8	; 0x08
    2f00:	80 95       	com	r24
    2f02:	90 95       	com	r25
    2f04:	82 23       	and	r24, r18
    2f06:	93 23       	and	r25, r19
    2f08:	eb 81       	ldd	r30, Y+3	; 0x03
    2f0a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f0c:	91 83       	std	Z+1, r25	; 0x01
    2f0e:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    2f10:	0f 90       	pop	r0
    2f12:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2f14:	89 81       	ldd	r24, Y+1	; 0x01
    2f16:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2f18:	28 96       	adiw	r28, 0x08	; 8
    2f1a:	0f b6       	in	r0, 0x3f	; 63
    2f1c:	f8 94       	cli
    2f1e:	de bf       	out	0x3e, r29	; 62
    2f20:	0f be       	out	0x3f, r0	; 63
    2f22:	cd bf       	out	0x3d, r28	; 61
    2f24:	cf 91       	pop	r28
    2f26:	df 91       	pop	r29
    2f28:	08 95       	ret

00002f2a <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    2f2a:	df 93       	push	r29
    2f2c:	cf 93       	push	r28
    2f2e:	cd b7       	in	r28, 0x3d	; 61
    2f30:	de b7       	in	r29, 0x3e	; 62
    2f32:	27 97       	sbiw	r28, 0x07	; 7
    2f34:	0f b6       	in	r0, 0x3f	; 63
    2f36:	f8 94       	cli
    2f38:	de bf       	out	0x3e, r29	; 62
    2f3a:	0f be       	out	0x3f, r0	; 63
    2f3c:	cd bf       	out	0x3d, r28	; 61
    2f3e:	9f 83       	std	Y+7, r25	; 0x07
    2f40:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    2f42:	8e 81       	ldd	r24, Y+6	; 0x06
    2f44:	9f 81       	ldd	r25, Y+7	; 0x07
    2f46:	9c 83       	std	Y+4, r25	; 0x04
    2f48:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2f4a:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    2f4c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f4e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f50:	80 81       	ld	r24, Z
    2f52:	91 81       	ldd	r25, Z+1	; 0x01
    2f54:	9a 83       	std	Y+2, r25	; 0x02
    2f56:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    2f58:	89 81       	ldd	r24, Y+1	; 0x01
    2f5a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2f5c:	27 96       	adiw	r28, 0x07	; 7
    2f5e:	0f b6       	in	r0, 0x3f	; 63
    2f60:	f8 94       	cli
    2f62:	de bf       	out	0x3e, r29	; 62
    2f64:	0f be       	out	0x3f, r0	; 63
    2f66:	cd bf       	out	0x3d, r28	; 61
    2f68:	cf 91       	pop	r28
    2f6a:	df 91       	pop	r29
    2f6c:	08 95       	ret

00002f6e <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    2f6e:	df 93       	push	r29
    2f70:	cf 93       	push	r28
    2f72:	cd b7       	in	r28, 0x3d	; 61
    2f74:	de b7       	in	r29, 0x3e	; 62
    2f76:	65 97       	sbiw	r28, 0x15	; 21
    2f78:	0f b6       	in	r0, 0x3f	; 63
    2f7a:	f8 94       	cli
    2f7c:	de bf       	out	0x3e, r29	; 62
    2f7e:	0f be       	out	0x3f, r0	; 63
    2f80:	cd bf       	out	0x3d, r28	; 61
    2f82:	9b 8b       	std	Y+19, r25	; 0x13
    2f84:	8a 8b       	std	Y+18, r24	; 0x12
    2f86:	7d 8b       	std	Y+21, r23	; 0x15
    2f88:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    2f8a:	19 86       	std	Y+9, r1	; 0x09
    2f8c:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    2f8e:	8a 89       	ldd	r24, Y+18	; 0x12
    2f90:	9b 89       	ldd	r25, Y+19	; 0x13
    2f92:	9b 83       	std	Y+3, r25	; 0x03
    2f94:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    2f96:	19 82       	std	Y+1, r1	; 0x01

	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    2f98:	8a 81       	ldd	r24, Y+2	; 0x02
    2f9a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f9c:	02 96       	adiw	r24, 0x02	; 2
    2f9e:	9b 87       	std	Y+11, r25	; 0x0b
    2fa0:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2fa2:	8a 85       	ldd	r24, Y+10	; 0x0a
    2fa4:	9b 85       	ldd	r25, Y+11	; 0x0b
    2fa6:	03 96       	adiw	r24, 0x03	; 3
    2fa8:	9d 87       	std	Y+13, r25	; 0x0d
    2faa:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    2fac:	0e 94 bf 27 	call	0x4f7e	; 0x4f7e <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    2fb0:	ea 85       	ldd	r30, Y+10	; 0x0a
    2fb2:	fb 85       	ldd	r31, Y+11	; 0x0b
    2fb4:	85 81       	ldd	r24, Z+5	; 0x05
    2fb6:	96 81       	ldd	r25, Z+6	; 0x06
    2fb8:	99 8b       	std	Y+17, r25	; 0x11
    2fba:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    2fbc:	ea 81       	ldd	r30, Y+2	; 0x02
    2fbe:	fb 81       	ldd	r31, Y+3	; 0x03
    2fc0:	20 81       	ld	r18, Z
    2fc2:	31 81       	ldd	r19, Z+1	; 0x01
    2fc4:	8c 89       	ldd	r24, Y+20	; 0x14
    2fc6:	9d 89       	ldd	r25, Y+21	; 0x15
    2fc8:	82 2b       	or	r24, r18
    2fca:	93 2b       	or	r25, r19
    2fcc:	ea 81       	ldd	r30, Y+2	; 0x02
    2fce:	fb 81       	ldd	r31, Y+3	; 0x03
    2fd0:	91 83       	std	Z+1, r25	; 0x01
    2fd2:	80 83       	st	Z, r24
    2fd4:	59 c0       	rjmp	.+178    	; 0x3088 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    2fd6:	e8 89       	ldd	r30, Y+16	; 0x10
    2fd8:	f9 89       	ldd	r31, Y+17	; 0x11
    2fda:	82 81       	ldd	r24, Z+2	; 0x02
    2fdc:	93 81       	ldd	r25, Z+3	; 0x03
    2fde:	9f 87       	std	Y+15, r25	; 0x0f
    2fe0:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2fe2:	e8 89       	ldd	r30, Y+16	; 0x10
    2fe4:	f9 89       	ldd	r31, Y+17	; 0x11
    2fe6:	80 81       	ld	r24, Z
    2fe8:	91 81       	ldd	r25, Z+1	; 0x01
    2fea:	9f 83       	std	Y+7, r25	; 0x07
    2fec:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    2fee:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    2ff0:	8e 81       	ldd	r24, Y+6	; 0x06
    2ff2:	9f 81       	ldd	r25, Y+7	; 0x07
    2ff4:	80 70       	andi	r24, 0x00	; 0
    2ff6:	9d 83       	std	Y+5, r25	; 0x05
    2ff8:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    2ffa:	8e 81       	ldd	r24, Y+6	; 0x06
    2ffc:	9f 81       	ldd	r25, Y+7	; 0x07
    2ffe:	90 70       	andi	r25, 0x00	; 0
    3000:	9f 83       	std	Y+7, r25	; 0x07
    3002:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    3004:	8c 81       	ldd	r24, Y+4	; 0x04
    3006:	9d 81       	ldd	r25, Y+5	; 0x05
    3008:	80 70       	andi	r24, 0x00	; 0
    300a:	94 70       	andi	r25, 0x04	; 4
    300c:	00 97       	sbiw	r24, 0x00	; 0
    300e:	69 f4       	brne	.+26     	; 0x302a <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    3010:	ea 81       	ldd	r30, Y+2	; 0x02
    3012:	fb 81       	ldd	r31, Y+3	; 0x03
    3014:	20 81       	ld	r18, Z
    3016:	31 81       	ldd	r19, Z+1	; 0x01
    3018:	8e 81       	ldd	r24, Y+6	; 0x06
    301a:	9f 81       	ldd	r25, Y+7	; 0x07
    301c:	82 23       	and	r24, r18
    301e:	93 23       	and	r25, r19
    3020:	00 97       	sbiw	r24, 0x00	; 0
    3022:	91 f0       	breq	.+36     	; 0x3048 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    3024:	81 e0       	ldi	r24, 0x01	; 1
    3026:	89 83       	std	Y+1, r24	; 0x01
    3028:	0f c0       	rjmp	.+30     	; 0x3048 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    302a:	ea 81       	ldd	r30, Y+2	; 0x02
    302c:	fb 81       	ldd	r31, Y+3	; 0x03
    302e:	20 81       	ld	r18, Z
    3030:	31 81       	ldd	r19, Z+1	; 0x01
    3032:	8e 81       	ldd	r24, Y+6	; 0x06
    3034:	9f 81       	ldd	r25, Y+7	; 0x07
    3036:	28 23       	and	r18, r24
    3038:	39 23       	and	r19, r25
    303a:	8e 81       	ldd	r24, Y+6	; 0x06
    303c:	9f 81       	ldd	r25, Y+7	; 0x07
    303e:	28 17       	cp	r18, r24
    3040:	39 07       	cpc	r19, r25
    3042:	11 f4       	brne	.+4      	; 0x3048 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    3044:	81 e0       	ldi	r24, 0x01	; 1
    3046:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    3048:	89 81       	ldd	r24, Y+1	; 0x01
    304a:	88 23       	and	r24, r24
    304c:	c9 f0       	breq	.+50     	; 0x3080 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    304e:	8c 81       	ldd	r24, Y+4	; 0x04
    3050:	9d 81       	ldd	r25, Y+5	; 0x05
    3052:	80 70       	andi	r24, 0x00	; 0
    3054:	91 70       	andi	r25, 0x01	; 1
    3056:	00 97       	sbiw	r24, 0x00	; 0
    3058:	41 f0       	breq	.+16     	; 0x306a <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    305a:	88 85       	ldd	r24, Y+8	; 0x08
    305c:	99 85       	ldd	r25, Y+9	; 0x09
    305e:	2e 81       	ldd	r18, Y+6	; 0x06
    3060:	3f 81       	ldd	r19, Y+7	; 0x07
    3062:	82 2b       	or	r24, r18
    3064:	93 2b       	or	r25, r19
    3066:	99 87       	std	Y+9, r25	; 0x09
    3068:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    306a:	ea 81       	ldd	r30, Y+2	; 0x02
    306c:	fb 81       	ldd	r31, Y+3	; 0x03
    306e:	80 81       	ld	r24, Z
    3070:	91 81       	ldd	r25, Z+1	; 0x01
    3072:	9c 01       	movw	r18, r24
    3074:	32 60       	ori	r19, 0x02	; 2
    3076:	88 89       	ldd	r24, Y+16	; 0x10
    3078:	99 89       	ldd	r25, Y+17	; 0x11
    307a:	b9 01       	movw	r22, r18
    307c:	0e 94 bd 2a 	call	0x557a	; 0x557a <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    3080:	8e 85       	ldd	r24, Y+14	; 0x0e
    3082:	9f 85       	ldd	r25, Y+15	; 0x0f
    3084:	99 8b       	std	Y+17, r25	; 0x11
    3086:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    3088:	28 89       	ldd	r18, Y+16	; 0x10
    308a:	39 89       	ldd	r19, Y+17	; 0x11
    308c:	8c 85       	ldd	r24, Y+12	; 0x0c
    308e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3090:	28 17       	cp	r18, r24
    3092:	39 07       	cpc	r19, r25
    3094:	09 f0       	breq	.+2      	; 0x3098 <xEventGroupSetBits+0x12a>
    3096:	9f cf       	rjmp	.-194    	; 0x2fd6 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    3098:	ea 81       	ldd	r30, Y+2	; 0x02
    309a:	fb 81       	ldd	r31, Y+3	; 0x03
    309c:	20 81       	ld	r18, Z
    309e:	31 81       	ldd	r19, Z+1	; 0x01
    30a0:	88 85       	ldd	r24, Y+8	; 0x08
    30a2:	99 85       	ldd	r25, Y+9	; 0x09
    30a4:	80 95       	com	r24
    30a6:	90 95       	com	r25
    30a8:	82 23       	and	r24, r18
    30aa:	93 23       	and	r25, r19
    30ac:	ea 81       	ldd	r30, Y+2	; 0x02
    30ae:	fb 81       	ldd	r31, Y+3	; 0x03
    30b0:	91 83       	std	Z+1, r25	; 0x01
    30b2:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    30b4:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    30b8:	ea 81       	ldd	r30, Y+2	; 0x02
    30ba:	fb 81       	ldd	r31, Y+3	; 0x03
    30bc:	80 81       	ld	r24, Z
    30be:	91 81       	ldd	r25, Z+1	; 0x01
}
    30c0:	65 96       	adiw	r28, 0x15	; 21
    30c2:	0f b6       	in	r0, 0x3f	; 63
    30c4:	f8 94       	cli
    30c6:	de bf       	out	0x3e, r29	; 62
    30c8:	0f be       	out	0x3f, r0	; 63
    30ca:	cd bf       	out	0x3d, r28	; 61
    30cc:	cf 91       	pop	r28
    30ce:	df 91       	pop	r29
    30d0:	08 95       	ret

000030d2 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    30d2:	df 93       	push	r29
    30d4:	cf 93       	push	r28
    30d6:	00 d0       	rcall	.+0      	; 0x30d8 <vEventGroupDelete+0x6>
    30d8:	00 d0       	rcall	.+0      	; 0x30da <vEventGroupDelete+0x8>
    30da:	00 d0       	rcall	.+0      	; 0x30dc <vEventGroupDelete+0xa>
    30dc:	cd b7       	in	r28, 0x3d	; 61
    30de:	de b7       	in	r29, 0x3e	; 62
    30e0:	9e 83       	std	Y+6, r25	; 0x06
    30e2:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    30e4:	8d 81       	ldd	r24, Y+5	; 0x05
    30e6:	9e 81       	ldd	r25, Y+6	; 0x06
    30e8:	9c 83       	std	Y+4, r25	; 0x04
    30ea:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    30ec:	8b 81       	ldd	r24, Y+3	; 0x03
    30ee:	9c 81       	ldd	r25, Y+4	; 0x04
    30f0:	02 96       	adiw	r24, 0x02	; 2
    30f2:	9a 83       	std	Y+2, r25	; 0x02
    30f4:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    30f6:	0e 94 bf 27 	call	0x4f7e	; 0x4f7e <vTaskSuspendAll>
    30fa:	08 c0       	rjmp	.+16     	; 0x310c <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    30fc:	e9 81       	ldd	r30, Y+1	; 0x01
    30fe:	fa 81       	ldd	r31, Y+2	; 0x02
    3100:	85 81       	ldd	r24, Z+5	; 0x05
    3102:	96 81       	ldd	r25, Z+6	; 0x06
    3104:	60 e0       	ldi	r22, 0x00	; 0
    3106:	72 e0       	ldi	r23, 0x02	; 2
    3108:	0e 94 bd 2a 	call	0x557a	; 0x557a <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    310c:	e9 81       	ldd	r30, Y+1	; 0x01
    310e:	fa 81       	ldd	r31, Y+2	; 0x02
    3110:	80 81       	ld	r24, Z
    3112:	88 23       	and	r24, r24
    3114:	99 f7       	brne	.-26     	; 0x30fc <vEventGroupDelete+0x2a>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
    3116:	8b 81       	ldd	r24, Y+3	; 0x03
    3118:	9c 81       	ldd	r25, Y+4	; 0x04
    311a:	0e 94 5c 19 	call	0x32b8	; 0x32b8 <vPortFree>
	}
	( void ) xTaskResumeAll();
    311e:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <xTaskResumeAll>
}
    3122:	26 96       	adiw	r28, 0x06	; 6
    3124:	0f b6       	in	r0, 0x3f	; 63
    3126:	f8 94       	cli
    3128:	de bf       	out	0x3e, r29	; 62
    312a:	0f be       	out	0x3f, r0	; 63
    312c:	cd bf       	out	0x3d, r28	; 61
    312e:	cf 91       	pop	r28
    3130:	df 91       	pop	r29
    3132:	08 95       	ret

00003134 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    3134:	df 93       	push	r29
    3136:	cf 93       	push	r28
    3138:	00 d0       	rcall	.+0      	; 0x313a <vEventGroupSetBitsCallback+0x6>
    313a:	00 d0       	rcall	.+0      	; 0x313c <vEventGroupSetBitsCallback+0x8>
    313c:	00 d0       	rcall	.+0      	; 0x313e <vEventGroupSetBitsCallback+0xa>
    313e:	cd b7       	in	r28, 0x3d	; 61
    3140:	de b7       	in	r29, 0x3e	; 62
    3142:	9a 83       	std	Y+2, r25	; 0x02
    3144:	89 83       	std	Y+1, r24	; 0x01
    3146:	4b 83       	std	Y+3, r20	; 0x03
    3148:	5c 83       	std	Y+4, r21	; 0x04
    314a:	6d 83       	std	Y+5, r22	; 0x05
    314c:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
    314e:	2b 81       	ldd	r18, Y+3	; 0x03
    3150:	3c 81       	ldd	r19, Y+4	; 0x04
    3152:	89 81       	ldd	r24, Y+1	; 0x01
    3154:	9a 81       	ldd	r25, Y+2	; 0x02
    3156:	b9 01       	movw	r22, r18
    3158:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <xEventGroupSetBits>
}
    315c:	26 96       	adiw	r28, 0x06	; 6
    315e:	0f b6       	in	r0, 0x3f	; 63
    3160:	f8 94       	cli
    3162:	de bf       	out	0x3e, r29	; 62
    3164:	0f be       	out	0x3f, r0	; 63
    3166:	cd bf       	out	0x3d, r28	; 61
    3168:	cf 91       	pop	r28
    316a:	df 91       	pop	r29
    316c:	08 95       	ret

0000316e <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    316e:	df 93       	push	r29
    3170:	cf 93       	push	r28
    3172:	00 d0       	rcall	.+0      	; 0x3174 <vEventGroupClearBitsCallback+0x6>
    3174:	00 d0       	rcall	.+0      	; 0x3176 <vEventGroupClearBitsCallback+0x8>
    3176:	00 d0       	rcall	.+0      	; 0x3178 <vEventGroupClearBitsCallback+0xa>
    3178:	cd b7       	in	r28, 0x3d	; 61
    317a:	de b7       	in	r29, 0x3e	; 62
    317c:	9a 83       	std	Y+2, r25	; 0x02
    317e:	89 83       	std	Y+1, r24	; 0x01
    3180:	4b 83       	std	Y+3, r20	; 0x03
    3182:	5c 83       	std	Y+4, r21	; 0x04
    3184:	6d 83       	std	Y+5, r22	; 0x05
    3186:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
    3188:	2b 81       	ldd	r18, Y+3	; 0x03
    318a:	3c 81       	ldd	r19, Y+4	; 0x04
    318c:	89 81       	ldd	r24, Y+1	; 0x01
    318e:	9a 81       	ldd	r25, Y+2	; 0x02
    3190:	b9 01       	movw	r22, r18
    3192:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <xEventGroupClearBits>
}
    3196:	26 96       	adiw	r28, 0x06	; 6
    3198:	0f b6       	in	r0, 0x3f	; 63
    319a:	f8 94       	cli
    319c:	de bf       	out	0x3e, r29	; 62
    319e:	0f be       	out	0x3f, r0	; 63
    31a0:	cd bf       	out	0x3d, r28	; 61
    31a2:	cf 91       	pop	r28
    31a4:	df 91       	pop	r29
    31a6:	08 95       	ret

000031a8 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    31a8:	df 93       	push	r29
    31aa:	cf 93       	push	r28
    31ac:	00 d0       	rcall	.+0      	; 0x31ae <prvTestWaitCondition+0x6>
    31ae:	00 d0       	rcall	.+0      	; 0x31b0 <prvTestWaitCondition+0x8>
    31b0:	00 d0       	rcall	.+0      	; 0x31b2 <prvTestWaitCondition+0xa>
    31b2:	cd b7       	in	r28, 0x3d	; 61
    31b4:	de b7       	in	r29, 0x3e	; 62
    31b6:	9b 83       	std	Y+3, r25	; 0x03
    31b8:	8a 83       	std	Y+2, r24	; 0x02
    31ba:	7d 83       	std	Y+5, r23	; 0x05
    31bc:	6c 83       	std	Y+4, r22	; 0x04
    31be:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    31c0:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    31c2:	8e 81       	ldd	r24, Y+6	; 0x06
    31c4:	88 23       	and	r24, r24
    31c6:	59 f4       	brne	.+22     	; 0x31de <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    31c8:	8a 81       	ldd	r24, Y+2	; 0x02
    31ca:	9b 81       	ldd	r25, Y+3	; 0x03
    31cc:	2c 81       	ldd	r18, Y+4	; 0x04
    31ce:	3d 81       	ldd	r19, Y+5	; 0x05
    31d0:	82 23       	and	r24, r18
    31d2:	93 23       	and	r25, r19
    31d4:	00 97       	sbiw	r24, 0x00	; 0
    31d6:	81 f0       	breq	.+32     	; 0x31f8 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    31d8:	81 e0       	ldi	r24, 0x01	; 1
    31da:	89 83       	std	Y+1, r24	; 0x01
    31dc:	0d c0       	rjmp	.+26     	; 0x31f8 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    31de:	2a 81       	ldd	r18, Y+2	; 0x02
    31e0:	3b 81       	ldd	r19, Y+3	; 0x03
    31e2:	8c 81       	ldd	r24, Y+4	; 0x04
    31e4:	9d 81       	ldd	r25, Y+5	; 0x05
    31e6:	28 23       	and	r18, r24
    31e8:	39 23       	and	r19, r25
    31ea:	8c 81       	ldd	r24, Y+4	; 0x04
    31ec:	9d 81       	ldd	r25, Y+5	; 0x05
    31ee:	28 17       	cp	r18, r24
    31f0:	39 07       	cpc	r19, r25
    31f2:	11 f4       	brne	.+4      	; 0x31f8 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    31f4:	81 e0       	ldi	r24, 0x01	; 1
    31f6:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    31f8:	89 81       	ldd	r24, Y+1	; 0x01
}
    31fa:	26 96       	adiw	r28, 0x06	; 6
    31fc:	0f b6       	in	r0, 0x3f	; 63
    31fe:	f8 94       	cli
    3200:	de bf       	out	0x3e, r29	; 62
    3202:	0f be       	out	0x3f, r0	; 63
    3204:	cd bf       	out	0x3d, r28	; 61
    3206:	cf 91       	pop	r28
    3208:	df 91       	pop	r29
    320a:	08 95       	ret

0000320c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    320c:	df 93       	push	r29
    320e:	cf 93       	push	r28
    3210:	00 d0       	rcall	.+0      	; 0x3212 <pvPortMalloc+0x6>
    3212:	00 d0       	rcall	.+0      	; 0x3214 <pvPortMalloc+0x8>
    3214:	cd b7       	in	r28, 0x3d	; 61
    3216:	de b7       	in	r29, 0x3e	; 62
    3218:	9c 83       	std	Y+4, r25	; 0x04
    321a:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    321c:	1a 82       	std	Y+2, r1	; 0x02
    321e:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    3220:	0e 94 bf 27 	call	0x4f7e	; 0x4f7e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    3224:	80 91 be 01 	lds	r24, 0x01BE
    3228:	90 91 bf 01 	lds	r25, 0x01BF
    322c:	00 97       	sbiw	r24, 0x00	; 0
    322e:	31 f4       	brne	.+12     	; 0x323c <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    3230:	81 ec       	ldi	r24, 0xC1	; 193
    3232:	91 e0       	ldi	r25, 0x01	; 1
    3234:	90 93 bf 01 	sts	0x01BF, r25
    3238:	80 93 be 01 	sts	0x01BE, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    323c:	80 91 bc 01 	lds	r24, 0x01BC
    3240:	90 91 bd 01 	lds	r25, 0x01BD
    3244:	2b 81       	ldd	r18, Y+3	; 0x03
    3246:	3c 81       	ldd	r19, Y+4	; 0x04
    3248:	82 0f       	add	r24, r18
    324a:	93 1f       	adc	r25, r19
    324c:	25 e0       	ldi	r18, 0x05	; 5
    324e:	8b 3d       	cpi	r24, 0xDB	; 219
    3250:	92 07       	cpc	r25, r18
    3252:	38 f5       	brcc	.+78     	; 0x32a2 <pvPortMalloc+0x96>
    3254:	20 91 bc 01 	lds	r18, 0x01BC
    3258:	30 91 bd 01 	lds	r19, 0x01BD
    325c:	8b 81       	ldd	r24, Y+3	; 0x03
    325e:	9c 81       	ldd	r25, Y+4	; 0x04
    3260:	28 0f       	add	r18, r24
    3262:	39 1f       	adc	r19, r25
    3264:	80 91 bc 01 	lds	r24, 0x01BC
    3268:	90 91 bd 01 	lds	r25, 0x01BD
    326c:	82 17       	cp	r24, r18
    326e:	93 07       	cpc	r25, r19
    3270:	c0 f4       	brcc	.+48     	; 0x32a2 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    3272:	20 91 be 01 	lds	r18, 0x01BE
    3276:	30 91 bf 01 	lds	r19, 0x01BF
    327a:	80 91 bc 01 	lds	r24, 0x01BC
    327e:	90 91 bd 01 	lds	r25, 0x01BD
    3282:	82 0f       	add	r24, r18
    3284:	93 1f       	adc	r25, r19
    3286:	9a 83       	std	Y+2, r25	; 0x02
    3288:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    328a:	20 91 bc 01 	lds	r18, 0x01BC
    328e:	30 91 bd 01 	lds	r19, 0x01BD
    3292:	8b 81       	ldd	r24, Y+3	; 0x03
    3294:	9c 81       	ldd	r25, Y+4	; 0x04
    3296:	82 0f       	add	r24, r18
    3298:	93 1f       	adc	r25, r19
    329a:	90 93 bd 01 	sts	0x01BD, r25
    329e:	80 93 bc 01 	sts	0x01BC, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    32a2:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    32a6:	89 81       	ldd	r24, Y+1	; 0x01
    32a8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    32aa:	0f 90       	pop	r0
    32ac:	0f 90       	pop	r0
    32ae:	0f 90       	pop	r0
    32b0:	0f 90       	pop	r0
    32b2:	cf 91       	pop	r28
    32b4:	df 91       	pop	r29
    32b6:	08 95       	ret

000032b8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    32b8:	df 93       	push	r29
    32ba:	cf 93       	push	r28
    32bc:	00 d0       	rcall	.+0      	; 0x32be <vPortFree+0x6>
    32be:	cd b7       	in	r28, 0x3d	; 61
    32c0:	de b7       	in	r29, 0x3e	; 62
    32c2:	9a 83       	std	Y+2, r25	; 0x02
    32c4:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    32c6:	0f 90       	pop	r0
    32c8:	0f 90       	pop	r0
    32ca:	cf 91       	pop	r28
    32cc:	df 91       	pop	r29
    32ce:	08 95       	ret

000032d0 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    32d0:	df 93       	push	r29
    32d2:	cf 93       	push	r28
    32d4:	cd b7       	in	r28, 0x3d	; 61
    32d6:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    32d8:	10 92 bd 01 	sts	0x01BD, r1
    32dc:	10 92 bc 01 	sts	0x01BC, r1
}
    32e0:	cf 91       	pop	r28
    32e2:	df 91       	pop	r29
    32e4:	08 95       	ret

000032e6 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    32e6:	df 93       	push	r29
    32e8:	cf 93       	push	r28
    32ea:	cd b7       	in	r28, 0x3d	; 61
    32ec:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    32ee:	20 91 bc 01 	lds	r18, 0x01BC
    32f2:	30 91 bd 01 	lds	r19, 0x01BD
    32f6:	8b ed       	ldi	r24, 0xDB	; 219
    32f8:	95 e0       	ldi	r25, 0x05	; 5
    32fa:	82 1b       	sub	r24, r18
    32fc:	93 0b       	sbc	r25, r19
}
    32fe:	cf 91       	pop	r28
    3300:	df 91       	pop	r29
    3302:	08 95       	ret

00003304 <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    3304:	af 92       	push	r10
    3306:	bf 92       	push	r11
    3308:	cf 92       	push	r12
    330a:	df 92       	push	r13
    330c:	ef 92       	push	r14
    330e:	ff 92       	push	r15
    3310:	0f 93       	push	r16
    3312:	df 93       	push	r29
    3314:	cf 93       	push	r28
    3316:	00 d0       	rcall	.+0      	; 0x3318 <vStartIntegerMathTasks+0x14>
    3318:	0f 92       	push	r0
    331a:	cd b7       	in	r28, 0x3d	; 61
    331c:	de b7       	in	r29, 0x3e	; 62
    331e:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    3320:	1a 82       	std	Y+2, r1	; 0x02
    3322:	19 82       	std	Y+1, r1	; 0x01
    3324:	1b c0       	rjmp	.+54     	; 0x335c <vStartIntegerMathTasks+0x58>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    3326:	89 81       	ldd	r24, Y+1	; 0x01
    3328:	9a 81       	ldd	r25, Y+2	; 0x02
    332a:	fc 01       	movw	r30, r24
    332c:	e4 56       	subi	r30, 0x64	; 100
    332e:	f8 4f       	sbci	r31, 0xF8	; 248
    3330:	80 ec       	ldi	r24, 0xC0	; 192
    3332:	99 e1       	ldi	r25, 0x19	; 25
    3334:	2c e3       	ldi	r18, 0x3C	; 60
    3336:	31 e0       	ldi	r19, 0x01	; 1
    3338:	b9 01       	movw	r22, r18
    333a:	45 e5       	ldi	r20, 0x55	; 85
    333c:	50 e0       	ldi	r21, 0x00	; 0
    333e:	9f 01       	movw	r18, r30
    3340:	0b 81       	ldd	r16, Y+3	; 0x03
    3342:	ee 24       	eor	r14, r14
    3344:	ff 24       	eor	r15, r15
    3346:	cc 24       	eor	r12, r12
    3348:	dd 24       	eor	r13, r13
    334a:	aa 24       	eor	r10, r10
    334c:	bb 24       	eor	r11, r11
    334e:	0e 94 8d 25 	call	0x4b1a	; 0x4b1a <xTaskGenericCreate>

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    3352:	89 81       	ldd	r24, Y+1	; 0x01
    3354:	9a 81       	ldd	r25, Y+2	; 0x02
    3356:	01 96       	adiw	r24, 0x01	; 1
    3358:	9a 83       	std	Y+2, r25	; 0x02
    335a:	89 83       	std	Y+1, r24	; 0x01
    335c:	89 81       	ldd	r24, Y+1	; 0x01
    335e:	9a 81       	ldd	r25, Y+2	; 0x02
    3360:	18 16       	cp	r1, r24
    3362:	19 06       	cpc	r1, r25
    3364:	04 f7       	brge	.-64     	; 0x3326 <vStartIntegerMathTasks+0x22>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
	}
}
    3366:	0f 90       	pop	r0
    3368:	0f 90       	pop	r0
    336a:	0f 90       	pop	r0
    336c:	cf 91       	pop	r28
    336e:	df 91       	pop	r29
    3370:	0f 91       	pop	r16
    3372:	ff 90       	pop	r15
    3374:	ef 90       	pop	r14
    3376:	df 90       	pop	r13
    3378:	cf 90       	pop	r12
    337a:	bf 90       	pop	r11
    337c:	af 90       	pop	r10
    337e:	08 95       	ret

00003380 <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    3380:	df 93       	push	r29
    3382:	cf 93       	push	r28
    3384:	cd b7       	in	r28, 0x3d	; 61
    3386:	de b7       	in	r29, 0x3e	; 62
    3388:	2a 97       	sbiw	r28, 0x0a	; 10
    338a:	0f b6       	in	r0, 0x3f	; 63
    338c:	f8 94       	cli
    338e:	de bf       	out	0x3e, r29	; 62
    3390:	0f be       	out	0x3f, r0	; 63
    3392:	cd bf       	out	0x3d, r28	; 61
    3394:	9a 87       	std	Y+10, r25	; 0x0a
    3396:	89 87       	std	Y+9, r24	; 0x09
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    3398:	1c 82       	std	Y+4, r1	; 0x04
    339a:	1b 82       	std	Y+3, r1	; 0x03
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    339c:	89 85       	ldd	r24, Y+9	; 0x09
    339e:	9a 85       	ldd	r25, Y+10	; 0x0a
    33a0:	9a 83       	std	Y+2, r25	; 0x02
    33a2:	89 83       	std	Y+1, r24	; 0x01
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    33a4:	8b e7       	ldi	r24, 0x7B	; 123
    33a6:	90 e0       	ldi	r25, 0x00	; 0
    33a8:	a0 e0       	ldi	r26, 0x00	; 0
    33aa:	b0 e0       	ldi	r27, 0x00	; 0
    33ac:	8d 83       	std	Y+5, r24	; 0x05
    33ae:	9e 83       	std	Y+6, r25	; 0x06
    33b0:	af 83       	std	Y+7, r26	; 0x07
    33b2:	b8 87       	std	Y+8, r27	; 0x08
		lValue += intgCONST2;
    33b4:	8d 81       	ldd	r24, Y+5	; 0x05
    33b6:	9e 81       	ldd	r25, Y+6	; 0x06
    33b8:	af 81       	ldd	r26, Y+7	; 0x07
    33ba:	b8 85       	ldd	r27, Y+8	; 0x08
    33bc:	89 5b       	subi	r24, 0xB9	; 185
    33be:	9b 46       	sbci	r25, 0x6B	; 107
    33c0:	ac 4f       	sbci	r26, 0xFC	; 252
    33c2:	bf 4f       	sbci	r27, 0xFF	; 255
    33c4:	8d 83       	std	Y+5, r24	; 0x05
    33c6:	9e 83       	std	Y+6, r25	; 0x06
    33c8:	af 83       	std	Y+7, r26	; 0x07
    33ca:	b8 87       	std	Y+8, r27	; 0x08
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    33cc:	8d 81       	ldd	r24, Y+5	; 0x05
    33ce:	9e 81       	ldd	r25, Y+6	; 0x06
    33d0:	af 81       	ldd	r26, Y+7	; 0x07
    33d2:	b8 85       	ldd	r27, Y+8	; 0x08
    33d4:	2d ef       	ldi	r18, 0xFD	; 253
    33d6:	3f ef       	ldi	r19, 0xFF	; 255
    33d8:	4f ef       	ldi	r20, 0xFF	; 255
    33da:	5f ef       	ldi	r21, 0xFF	; 255
    33dc:	bc 01       	movw	r22, r24
    33de:	cd 01       	movw	r24, r26
    33e0:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsi3>
    33e4:	dc 01       	movw	r26, r24
    33e6:	cb 01       	movw	r24, r22
    33e8:	8d 83       	std	Y+5, r24	; 0x05
    33ea:	9e 83       	std	Y+6, r25	; 0x06
    33ec:	af 83       	std	Y+7, r26	; 0x07
    33ee:	b8 87       	std	Y+8, r27	; 0x08
		lValue /= intgCONST4;
    33f0:	8d 81       	ldd	r24, Y+5	; 0x05
    33f2:	9e 81       	ldd	r25, Y+6	; 0x06
    33f4:	af 81       	ldd	r26, Y+7	; 0x07
    33f6:	b8 85       	ldd	r27, Y+8	; 0x08
    33f8:	27 e0       	ldi	r18, 0x07	; 7
    33fa:	30 e0       	ldi	r19, 0x00	; 0
    33fc:	40 e0       	ldi	r20, 0x00	; 0
    33fe:	50 e0       	ldi	r21, 0x00	; 0
    3400:	bc 01       	movw	r22, r24
    3402:	cd 01       	movw	r24, r26
    3404:	0e 94 78 2e 	call	0x5cf0	; 0x5cf0 <__divmodsi4>
    3408:	da 01       	movw	r26, r20
    340a:	c9 01       	movw	r24, r18
    340c:	8d 83       	std	Y+5, r24	; 0x05
    340e:	9e 83       	std	Y+6, r25	; 0x06
    3410:	af 83       	std	Y+7, r26	; 0x07
    3412:	b8 87       	std	Y+8, r27	; 0x08

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    3414:	8d 81       	ldd	r24, Y+5	; 0x05
    3416:	9e 81       	ldd	r25, Y+6	; 0x06
    3418:	af 81       	ldd	r26, Y+7	; 0x07
    341a:	b8 85       	ldd	r27, Y+8	; 0x08
    341c:	8b 31       	cpi	r24, 0x1B	; 27
    341e:	27 e7       	ldi	r18, 0x77	; 119
    3420:	92 07       	cpc	r25, r18
    3422:	2e ef       	ldi	r18, 0xFE	; 254
    3424:	a2 07       	cpc	r26, r18
    3426:	2f ef       	ldi	r18, 0xFF	; 255
    3428:	b2 07       	cpc	r27, r18
    342a:	21 f0       	breq	.+8      	; 0x3434 <vCompeteingIntMathTask+0xb4>
		{
			sError = pdTRUE;
    342c:	81 e0       	ldi	r24, 0x01	; 1
    342e:	90 e0       	ldi	r25, 0x00	; 0
    3430:	9c 83       	std	Y+4, r25	; 0x04
    3432:	8b 83       	std	Y+3, r24	; 0x03
		}

		if( sError == pdFALSE )
    3434:	8b 81       	ldd	r24, Y+3	; 0x03
    3436:	9c 81       	ldd	r25, Y+4	; 0x04
    3438:	00 97       	sbiw	r24, 0x00	; 0
    343a:	09 f0       	breq	.+2      	; 0x343e <vCompeteingIntMathTask+0xbe>
    343c:	b3 cf       	rjmp	.-154    	; 0x33a4 <vCompeteingIntMathTask+0x24>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    343e:	0f b6       	in	r0, 0x3f	; 63
    3440:	f8 94       	cli
    3442:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    3444:	e9 81       	ldd	r30, Y+1	; 0x01
    3446:	fa 81       	ldd	r31, Y+2	; 0x02
    3448:	81 e0       	ldi	r24, 0x01	; 1
    344a:	80 83       	st	Z, r24
			portEXIT_CRITICAL();
    344c:	0f 90       	pop	r0
    344e:	0f be       	out	0x3f, r0	; 63
    3450:	a9 cf       	rjmp	.-174    	; 0x33a4 <vCompeteingIntMathTask+0x24>

00003452 <xAreIntegerMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
    3452:	df 93       	push	r29
    3454:	cf 93       	push	r28
    3456:	00 d0       	rcall	.+0      	; 0x3458 <xAreIntegerMathsTaskStillRunning+0x6>
    3458:	0f 92       	push	r0
    345a:	cd b7       	in	r28, 0x3d	; 61
    345c:	de b7       	in	r29, 0x3e	; 62
BaseType_t xReturn = pdTRUE;
    345e:	81 e0       	ldi	r24, 0x01	; 1
    3460:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    3462:	1a 82       	std	Y+2, r1	; 0x02
    3464:	19 82       	std	Y+1, r1	; 0x01
    3466:	14 c0       	rjmp	.+40     	; 0x3490 <xAreIntegerMathsTaskStillRunning+0x3e>
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    3468:	89 81       	ldd	r24, Y+1	; 0x01
    346a:	9a 81       	ldd	r25, Y+2	; 0x02
    346c:	fc 01       	movw	r30, r24
    346e:	e4 56       	subi	r30, 0x64	; 100
    3470:	f8 4f       	sbci	r31, 0xF8	; 248
    3472:	80 81       	ld	r24, Z
    3474:	88 23       	and	r24, r24
    3476:	09 f4       	brne	.+2      	; 0x347a <xAreIntegerMathsTaskStillRunning+0x28>
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
    3478:	1b 82       	std	Y+3, r1	; 0x03
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    347a:	89 81       	ldd	r24, Y+1	; 0x01
    347c:	9a 81       	ldd	r25, Y+2	; 0x02
    347e:	fc 01       	movw	r30, r24
    3480:	e4 56       	subi	r30, 0x64	; 100
    3482:	f8 4f       	sbci	r31, 0xF8	; 248
    3484:	10 82       	st	Z, r1
BaseType_t xReturn = pdTRUE;
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    3486:	89 81       	ldd	r24, Y+1	; 0x01
    3488:	9a 81       	ldd	r25, Y+2	; 0x02
    348a:	01 96       	adiw	r24, 0x01	; 1
    348c:	9a 83       	std	Y+2, r25	; 0x02
    348e:	89 83       	std	Y+1, r24	; 0x01
    3490:	89 81       	ldd	r24, Y+1	; 0x01
    3492:	9a 81       	ldd	r25, Y+2	; 0x02
    3494:	18 16       	cp	r1, r24
    3496:	19 06       	cpc	r1, r25
    3498:	3c f7       	brge	.-50     	; 0x3468 <xAreIntegerMathsTaskStillRunning+0x16>
		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
    349a:	8b 81       	ldd	r24, Y+3	; 0x03
}
    349c:	0f 90       	pop	r0
    349e:	0f 90       	pop	r0
    34a0:	0f 90       	pop	r0
    34a2:	cf 91       	pop	r28
    34a4:	df 91       	pop	r29
    34a6:	08 95       	ret

000034a8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    34a8:	df 93       	push	r29
    34aa:	cf 93       	push	r28
    34ac:	00 d0       	rcall	.+0      	; 0x34ae <vListInitialise+0x6>
    34ae:	cd b7       	in	r28, 0x3d	; 61
    34b0:	de b7       	in	r29, 0x3e	; 62
    34b2:	9a 83       	std	Y+2, r25	; 0x02
    34b4:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    34b6:	89 81       	ldd	r24, Y+1	; 0x01
    34b8:	9a 81       	ldd	r25, Y+2	; 0x02
    34ba:	03 96       	adiw	r24, 0x03	; 3
    34bc:	e9 81       	ldd	r30, Y+1	; 0x01
    34be:	fa 81       	ldd	r31, Y+2	; 0x02
    34c0:	92 83       	std	Z+2, r25	; 0x02
    34c2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    34c4:	e9 81       	ldd	r30, Y+1	; 0x01
    34c6:	fa 81       	ldd	r31, Y+2	; 0x02
    34c8:	8f ef       	ldi	r24, 0xFF	; 255
    34ca:	9f ef       	ldi	r25, 0xFF	; 255
    34cc:	94 83       	std	Z+4, r25	; 0x04
    34ce:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    34d0:	89 81       	ldd	r24, Y+1	; 0x01
    34d2:	9a 81       	ldd	r25, Y+2	; 0x02
    34d4:	03 96       	adiw	r24, 0x03	; 3
    34d6:	e9 81       	ldd	r30, Y+1	; 0x01
    34d8:	fa 81       	ldd	r31, Y+2	; 0x02
    34da:	96 83       	std	Z+6, r25	; 0x06
    34dc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    34de:	89 81       	ldd	r24, Y+1	; 0x01
    34e0:	9a 81       	ldd	r25, Y+2	; 0x02
    34e2:	03 96       	adiw	r24, 0x03	; 3
    34e4:	e9 81       	ldd	r30, Y+1	; 0x01
    34e6:	fa 81       	ldd	r31, Y+2	; 0x02
    34e8:	90 87       	std	Z+8, r25	; 0x08
    34ea:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    34ec:	e9 81       	ldd	r30, Y+1	; 0x01
    34ee:	fa 81       	ldd	r31, Y+2	; 0x02
    34f0:	10 82       	st	Z, r1
}
    34f2:	0f 90       	pop	r0
    34f4:	0f 90       	pop	r0
    34f6:	cf 91       	pop	r28
    34f8:	df 91       	pop	r29
    34fa:	08 95       	ret

000034fc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    34fc:	df 93       	push	r29
    34fe:	cf 93       	push	r28
    3500:	00 d0       	rcall	.+0      	; 0x3502 <vListInitialiseItem+0x6>
    3502:	cd b7       	in	r28, 0x3d	; 61
    3504:	de b7       	in	r29, 0x3e	; 62
    3506:	9a 83       	std	Y+2, r25	; 0x02
    3508:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    350a:	e9 81       	ldd	r30, Y+1	; 0x01
    350c:	fa 81       	ldd	r31, Y+2	; 0x02
    350e:	11 86       	std	Z+9, r1	; 0x09
    3510:	10 86       	std	Z+8, r1	; 0x08
}
    3512:	0f 90       	pop	r0
    3514:	0f 90       	pop	r0
    3516:	cf 91       	pop	r28
    3518:	df 91       	pop	r29
    351a:	08 95       	ret

0000351c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    351c:	df 93       	push	r29
    351e:	cf 93       	push	r28
    3520:	00 d0       	rcall	.+0      	; 0x3522 <vListInsertEnd+0x6>
    3522:	00 d0       	rcall	.+0      	; 0x3524 <vListInsertEnd+0x8>
    3524:	00 d0       	rcall	.+0      	; 0x3526 <vListInsertEnd+0xa>
    3526:	cd b7       	in	r28, 0x3d	; 61
    3528:	de b7       	in	r29, 0x3e	; 62
    352a:	9c 83       	std	Y+4, r25	; 0x04
    352c:	8b 83       	std	Y+3, r24	; 0x03
    352e:	7e 83       	std	Y+6, r23	; 0x06
    3530:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    3532:	eb 81       	ldd	r30, Y+3	; 0x03
    3534:	fc 81       	ldd	r31, Y+4	; 0x04
    3536:	81 81       	ldd	r24, Z+1	; 0x01
    3538:	92 81       	ldd	r25, Z+2	; 0x02
    353a:	9a 83       	std	Y+2, r25	; 0x02
    353c:	89 83       	std	Y+1, r24	; 0x01

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    353e:	ed 81       	ldd	r30, Y+5	; 0x05
    3540:	fe 81       	ldd	r31, Y+6	; 0x06
    3542:	89 81       	ldd	r24, Y+1	; 0x01
    3544:	9a 81       	ldd	r25, Y+2	; 0x02
    3546:	93 83       	std	Z+3, r25	; 0x03
    3548:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    354a:	e9 81       	ldd	r30, Y+1	; 0x01
    354c:	fa 81       	ldd	r31, Y+2	; 0x02
    354e:	84 81       	ldd	r24, Z+4	; 0x04
    3550:	95 81       	ldd	r25, Z+5	; 0x05
    3552:	ed 81       	ldd	r30, Y+5	; 0x05
    3554:	fe 81       	ldd	r31, Y+6	; 0x06
    3556:	95 83       	std	Z+5, r25	; 0x05
    3558:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    355a:	e9 81       	ldd	r30, Y+1	; 0x01
    355c:	fa 81       	ldd	r31, Y+2	; 0x02
    355e:	04 80       	ldd	r0, Z+4	; 0x04
    3560:	f5 81       	ldd	r31, Z+5	; 0x05
    3562:	e0 2d       	mov	r30, r0
    3564:	8d 81       	ldd	r24, Y+5	; 0x05
    3566:	9e 81       	ldd	r25, Y+6	; 0x06
    3568:	93 83       	std	Z+3, r25	; 0x03
    356a:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    356c:	e9 81       	ldd	r30, Y+1	; 0x01
    356e:	fa 81       	ldd	r31, Y+2	; 0x02
    3570:	8d 81       	ldd	r24, Y+5	; 0x05
    3572:	9e 81       	ldd	r25, Y+6	; 0x06
    3574:	95 83       	std	Z+5, r25	; 0x05
    3576:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    3578:	ed 81       	ldd	r30, Y+5	; 0x05
    357a:	fe 81       	ldd	r31, Y+6	; 0x06
    357c:	8b 81       	ldd	r24, Y+3	; 0x03
    357e:	9c 81       	ldd	r25, Y+4	; 0x04
    3580:	91 87       	std	Z+9, r25	; 0x09
    3582:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    3584:	eb 81       	ldd	r30, Y+3	; 0x03
    3586:	fc 81       	ldd	r31, Y+4	; 0x04
    3588:	80 81       	ld	r24, Z
    358a:	8f 5f       	subi	r24, 0xFF	; 255
    358c:	eb 81       	ldd	r30, Y+3	; 0x03
    358e:	fc 81       	ldd	r31, Y+4	; 0x04
    3590:	80 83       	st	Z, r24
}
    3592:	26 96       	adiw	r28, 0x06	; 6
    3594:	0f b6       	in	r0, 0x3f	; 63
    3596:	f8 94       	cli
    3598:	de bf       	out	0x3e, r29	; 62
    359a:	0f be       	out	0x3f, r0	; 63
    359c:	cd bf       	out	0x3d, r28	; 61
    359e:	cf 91       	pop	r28
    35a0:	df 91       	pop	r29
    35a2:	08 95       	ret

000035a4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    35a4:	df 93       	push	r29
    35a6:	cf 93       	push	r28
    35a8:	cd b7       	in	r28, 0x3d	; 61
    35aa:	de b7       	in	r29, 0x3e	; 62
    35ac:	28 97       	sbiw	r28, 0x08	; 8
    35ae:	0f b6       	in	r0, 0x3f	; 63
    35b0:	f8 94       	cli
    35b2:	de bf       	out	0x3e, r29	; 62
    35b4:	0f be       	out	0x3f, r0	; 63
    35b6:	cd bf       	out	0x3d, r28	; 61
    35b8:	9e 83       	std	Y+6, r25	; 0x06
    35ba:	8d 83       	std	Y+5, r24	; 0x05
    35bc:	78 87       	std	Y+8, r23	; 0x08
    35be:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    35c0:	ef 81       	ldd	r30, Y+7	; 0x07
    35c2:	f8 85       	ldd	r31, Y+8	; 0x08
    35c4:	80 81       	ld	r24, Z
    35c6:	91 81       	ldd	r25, Z+1	; 0x01
    35c8:	9a 83       	std	Y+2, r25	; 0x02
    35ca:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    35cc:	89 81       	ldd	r24, Y+1	; 0x01
    35ce:	9a 81       	ldd	r25, Y+2	; 0x02
    35d0:	2f ef       	ldi	r18, 0xFF	; 255
    35d2:	8f 3f       	cpi	r24, 0xFF	; 255
    35d4:	92 07       	cpc	r25, r18
    35d6:	39 f4       	brne	.+14     	; 0x35e6 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    35d8:	ed 81       	ldd	r30, Y+5	; 0x05
    35da:	fe 81       	ldd	r31, Y+6	; 0x06
    35dc:	87 81       	ldd	r24, Z+7	; 0x07
    35de:	90 85       	ldd	r25, Z+8	; 0x08
    35e0:	9c 83       	std	Y+4, r25	; 0x04
    35e2:	8b 83       	std	Y+3, r24	; 0x03
    35e4:	18 c0       	rjmp	.+48     	; 0x3616 <vListInsert+0x72>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    35e6:	8d 81       	ldd	r24, Y+5	; 0x05
    35e8:	9e 81       	ldd	r25, Y+6	; 0x06
    35ea:	03 96       	adiw	r24, 0x03	; 3
    35ec:	9c 83       	std	Y+4, r25	; 0x04
    35ee:	8b 83       	std	Y+3, r24	; 0x03
    35f0:	06 c0       	rjmp	.+12     	; 0x35fe <vListInsert+0x5a>
    35f2:	eb 81       	ldd	r30, Y+3	; 0x03
    35f4:	fc 81       	ldd	r31, Y+4	; 0x04
    35f6:	82 81       	ldd	r24, Z+2	; 0x02
    35f8:	93 81       	ldd	r25, Z+3	; 0x03
    35fa:	9c 83       	std	Y+4, r25	; 0x04
    35fc:	8b 83       	std	Y+3, r24	; 0x03
    35fe:	eb 81       	ldd	r30, Y+3	; 0x03
    3600:	fc 81       	ldd	r31, Y+4	; 0x04
    3602:	02 80       	ldd	r0, Z+2	; 0x02
    3604:	f3 81       	ldd	r31, Z+3	; 0x03
    3606:	e0 2d       	mov	r30, r0
    3608:	20 81       	ld	r18, Z
    360a:	31 81       	ldd	r19, Z+1	; 0x01
    360c:	89 81       	ldd	r24, Y+1	; 0x01
    360e:	9a 81       	ldd	r25, Y+2	; 0x02
    3610:	82 17       	cp	r24, r18
    3612:	93 07       	cpc	r25, r19
    3614:	70 f7       	brcc	.-36     	; 0x35f2 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    3616:	eb 81       	ldd	r30, Y+3	; 0x03
    3618:	fc 81       	ldd	r31, Y+4	; 0x04
    361a:	82 81       	ldd	r24, Z+2	; 0x02
    361c:	93 81       	ldd	r25, Z+3	; 0x03
    361e:	ef 81       	ldd	r30, Y+7	; 0x07
    3620:	f8 85       	ldd	r31, Y+8	; 0x08
    3622:	93 83       	std	Z+3, r25	; 0x03
    3624:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3626:	ef 81       	ldd	r30, Y+7	; 0x07
    3628:	f8 85       	ldd	r31, Y+8	; 0x08
    362a:	02 80       	ldd	r0, Z+2	; 0x02
    362c:	f3 81       	ldd	r31, Z+3	; 0x03
    362e:	e0 2d       	mov	r30, r0
    3630:	8f 81       	ldd	r24, Y+7	; 0x07
    3632:	98 85       	ldd	r25, Y+8	; 0x08
    3634:	95 83       	std	Z+5, r25	; 0x05
    3636:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    3638:	ef 81       	ldd	r30, Y+7	; 0x07
    363a:	f8 85       	ldd	r31, Y+8	; 0x08
    363c:	8b 81       	ldd	r24, Y+3	; 0x03
    363e:	9c 81       	ldd	r25, Y+4	; 0x04
    3640:	95 83       	std	Z+5, r25	; 0x05
    3642:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    3644:	eb 81       	ldd	r30, Y+3	; 0x03
    3646:	fc 81       	ldd	r31, Y+4	; 0x04
    3648:	8f 81       	ldd	r24, Y+7	; 0x07
    364a:	98 85       	ldd	r25, Y+8	; 0x08
    364c:	93 83       	std	Z+3, r25	; 0x03
    364e:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    3650:	ef 81       	ldd	r30, Y+7	; 0x07
    3652:	f8 85       	ldd	r31, Y+8	; 0x08
    3654:	8d 81       	ldd	r24, Y+5	; 0x05
    3656:	9e 81       	ldd	r25, Y+6	; 0x06
    3658:	91 87       	std	Z+9, r25	; 0x09
    365a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    365c:	ed 81       	ldd	r30, Y+5	; 0x05
    365e:	fe 81       	ldd	r31, Y+6	; 0x06
    3660:	80 81       	ld	r24, Z
    3662:	8f 5f       	subi	r24, 0xFF	; 255
    3664:	ed 81       	ldd	r30, Y+5	; 0x05
    3666:	fe 81       	ldd	r31, Y+6	; 0x06
    3668:	80 83       	st	Z, r24
}
    366a:	28 96       	adiw	r28, 0x08	; 8
    366c:	0f b6       	in	r0, 0x3f	; 63
    366e:	f8 94       	cli
    3670:	de bf       	out	0x3e, r29	; 62
    3672:	0f be       	out	0x3f, r0	; 63
    3674:	cd bf       	out	0x3d, r28	; 61
    3676:	cf 91       	pop	r28
    3678:	df 91       	pop	r29
    367a:	08 95       	ret

0000367c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    367c:	df 93       	push	r29
    367e:	cf 93       	push	r28
    3680:	00 d0       	rcall	.+0      	; 0x3682 <uxListRemove+0x6>
    3682:	00 d0       	rcall	.+0      	; 0x3684 <uxListRemove+0x8>
    3684:	cd b7       	in	r28, 0x3d	; 61
    3686:	de b7       	in	r29, 0x3e	; 62
    3688:	9c 83       	std	Y+4, r25	; 0x04
    368a:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    368c:	eb 81       	ldd	r30, Y+3	; 0x03
    368e:	fc 81       	ldd	r31, Y+4	; 0x04
    3690:	80 85       	ldd	r24, Z+8	; 0x08
    3692:	91 85       	ldd	r25, Z+9	; 0x09
    3694:	9a 83       	std	Y+2, r25	; 0x02
    3696:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3698:	eb 81       	ldd	r30, Y+3	; 0x03
    369a:	fc 81       	ldd	r31, Y+4	; 0x04
    369c:	a2 81       	ldd	r26, Z+2	; 0x02
    369e:	b3 81       	ldd	r27, Z+3	; 0x03
    36a0:	eb 81       	ldd	r30, Y+3	; 0x03
    36a2:	fc 81       	ldd	r31, Y+4	; 0x04
    36a4:	84 81       	ldd	r24, Z+4	; 0x04
    36a6:	95 81       	ldd	r25, Z+5	; 0x05
    36a8:	15 96       	adiw	r26, 0x05	; 5
    36aa:	9c 93       	st	X, r25
    36ac:	8e 93       	st	-X, r24
    36ae:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    36b0:	eb 81       	ldd	r30, Y+3	; 0x03
    36b2:	fc 81       	ldd	r31, Y+4	; 0x04
    36b4:	a4 81       	ldd	r26, Z+4	; 0x04
    36b6:	b5 81       	ldd	r27, Z+5	; 0x05
    36b8:	eb 81       	ldd	r30, Y+3	; 0x03
    36ba:	fc 81       	ldd	r31, Y+4	; 0x04
    36bc:	82 81       	ldd	r24, Z+2	; 0x02
    36be:	93 81       	ldd	r25, Z+3	; 0x03
    36c0:	13 96       	adiw	r26, 0x03	; 3
    36c2:	9c 93       	st	X, r25
    36c4:	8e 93       	st	-X, r24
    36c6:	12 97       	sbiw	r26, 0x02	; 2

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    36c8:	e9 81       	ldd	r30, Y+1	; 0x01
    36ca:	fa 81       	ldd	r31, Y+2	; 0x02
    36cc:	21 81       	ldd	r18, Z+1	; 0x01
    36ce:	32 81       	ldd	r19, Z+2	; 0x02
    36d0:	8b 81       	ldd	r24, Y+3	; 0x03
    36d2:	9c 81       	ldd	r25, Y+4	; 0x04
    36d4:	28 17       	cp	r18, r24
    36d6:	39 07       	cpc	r19, r25
    36d8:	41 f4       	brne	.+16     	; 0x36ea <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    36da:	eb 81       	ldd	r30, Y+3	; 0x03
    36dc:	fc 81       	ldd	r31, Y+4	; 0x04
    36de:	84 81       	ldd	r24, Z+4	; 0x04
    36e0:	95 81       	ldd	r25, Z+5	; 0x05
    36e2:	e9 81       	ldd	r30, Y+1	; 0x01
    36e4:	fa 81       	ldd	r31, Y+2	; 0x02
    36e6:	92 83       	std	Z+2, r25	; 0x02
    36e8:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    36ea:	eb 81       	ldd	r30, Y+3	; 0x03
    36ec:	fc 81       	ldd	r31, Y+4	; 0x04
    36ee:	11 86       	std	Z+9, r1	; 0x09
    36f0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    36f2:	e9 81       	ldd	r30, Y+1	; 0x01
    36f4:	fa 81       	ldd	r31, Y+2	; 0x02
    36f6:	80 81       	ld	r24, Z
    36f8:	81 50       	subi	r24, 0x01	; 1
    36fa:	e9 81       	ldd	r30, Y+1	; 0x01
    36fc:	fa 81       	ldd	r31, Y+2	; 0x02
    36fe:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    3700:	e9 81       	ldd	r30, Y+1	; 0x01
    3702:	fa 81       	ldd	r31, Y+2	; 0x02
    3704:	80 81       	ld	r24, Z
}
    3706:	0f 90       	pop	r0
    3708:	0f 90       	pop	r0
    370a:	0f 90       	pop	r0
    370c:	0f 90       	pop	r0
    370e:	cf 91       	pop	r28
    3710:	df 91       	pop	r29
    3712:	08 95       	ret

00003714 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    3714:	df 93       	push	r29
    3716:	cf 93       	push	r28
    3718:	cd b7       	in	r28, 0x3d	; 61
    371a:	de b7       	in	r29, 0x3e	; 62
    371c:	28 97       	sbiw	r28, 0x08	; 8
    371e:	0f b6       	in	r0, 0x3f	; 63
    3720:	f8 94       	cli
    3722:	de bf       	out	0x3e, r29	; 62
    3724:	0f be       	out	0x3f, r0	; 63
    3726:	cd bf       	out	0x3d, r28	; 61
    3728:	9c 83       	std	Y+4, r25	; 0x04
    372a:	8b 83       	std	Y+3, r24	; 0x03
    372c:	7e 83       	std	Y+6, r23	; 0x06
    372e:	6d 83       	std	Y+5, r22	; 0x05
    3730:	58 87       	std	Y+8, r21	; 0x08
    3732:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    3734:	eb 81       	ldd	r30, Y+3	; 0x03
    3736:	fc 81       	ldd	r31, Y+4	; 0x04
    3738:	81 e1       	ldi	r24, 0x11	; 17
    373a:	80 83       	st	Z, r24
	pxTopOfStack--;
    373c:	8b 81       	ldd	r24, Y+3	; 0x03
    373e:	9c 81       	ldd	r25, Y+4	; 0x04
    3740:	01 97       	sbiw	r24, 0x01	; 1
    3742:	9c 83       	std	Y+4, r25	; 0x04
    3744:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    3746:	eb 81       	ldd	r30, Y+3	; 0x03
    3748:	fc 81       	ldd	r31, Y+4	; 0x04
    374a:	82 e2       	ldi	r24, 0x22	; 34
    374c:	80 83       	st	Z, r24
	pxTopOfStack--;
    374e:	8b 81       	ldd	r24, Y+3	; 0x03
    3750:	9c 81       	ldd	r25, Y+4	; 0x04
    3752:	01 97       	sbiw	r24, 0x01	; 1
    3754:	9c 83       	std	Y+4, r25	; 0x04
    3756:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    3758:	eb 81       	ldd	r30, Y+3	; 0x03
    375a:	fc 81       	ldd	r31, Y+4	; 0x04
    375c:	83 e3       	ldi	r24, 0x33	; 51
    375e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3760:	8b 81       	ldd	r24, Y+3	; 0x03
    3762:	9c 81       	ldd	r25, Y+4	; 0x04
    3764:	01 97       	sbiw	r24, 0x01	; 1
    3766:	9c 83       	std	Y+4, r25	; 0x04
    3768:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    376a:	8d 81       	ldd	r24, Y+5	; 0x05
    376c:	9e 81       	ldd	r25, Y+6	; 0x06
    376e:	9a 83       	std	Y+2, r25	; 0x02
    3770:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3772:	89 81       	ldd	r24, Y+1	; 0x01
    3774:	eb 81       	ldd	r30, Y+3	; 0x03
    3776:	fc 81       	ldd	r31, Y+4	; 0x04
    3778:	80 83       	st	Z, r24
	pxTopOfStack--;
    377a:	8b 81       	ldd	r24, Y+3	; 0x03
    377c:	9c 81       	ldd	r25, Y+4	; 0x04
    377e:	01 97       	sbiw	r24, 0x01	; 1
    3780:	9c 83       	std	Y+4, r25	; 0x04
    3782:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3784:	89 81       	ldd	r24, Y+1	; 0x01
    3786:	9a 81       	ldd	r25, Y+2	; 0x02
    3788:	89 2f       	mov	r24, r25
    378a:	99 27       	eor	r25, r25
    378c:	9a 83       	std	Y+2, r25	; 0x02
    378e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3790:	89 81       	ldd	r24, Y+1	; 0x01
    3792:	eb 81       	ldd	r30, Y+3	; 0x03
    3794:	fc 81       	ldd	r31, Y+4	; 0x04
    3796:	80 83       	st	Z, r24
	pxTopOfStack--;
    3798:	8b 81       	ldd	r24, Y+3	; 0x03
    379a:	9c 81       	ldd	r25, Y+4	; 0x04
    379c:	01 97       	sbiw	r24, 0x01	; 1
    379e:	9c 83       	std	Y+4, r25	; 0x04
    37a0:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    37a2:	eb 81       	ldd	r30, Y+3	; 0x03
    37a4:	fc 81       	ldd	r31, Y+4	; 0x04
    37a6:	10 82       	st	Z, r1
	pxTopOfStack--;
    37a8:	8b 81       	ldd	r24, Y+3	; 0x03
    37aa:	9c 81       	ldd	r25, Y+4	; 0x04
    37ac:	01 97       	sbiw	r24, 0x01	; 1
    37ae:	9c 83       	std	Y+4, r25	; 0x04
    37b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    37b2:	eb 81       	ldd	r30, Y+3	; 0x03
    37b4:	fc 81       	ldd	r31, Y+4	; 0x04
    37b6:	80 e8       	ldi	r24, 0x80	; 128
    37b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    37ba:	8b 81       	ldd	r24, Y+3	; 0x03
    37bc:	9c 81       	ldd	r25, Y+4	; 0x04
    37be:	01 97       	sbiw	r24, 0x01	; 1
    37c0:	9c 83       	std	Y+4, r25	; 0x04
    37c2:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    37c4:	eb 81       	ldd	r30, Y+3	; 0x03
    37c6:	fc 81       	ldd	r31, Y+4	; 0x04
    37c8:	10 82       	st	Z, r1
	pxTopOfStack--;
    37ca:	8b 81       	ldd	r24, Y+3	; 0x03
    37cc:	9c 81       	ldd	r25, Y+4	; 0x04
    37ce:	01 97       	sbiw	r24, 0x01	; 1
    37d0:	9c 83       	std	Y+4, r25	; 0x04
    37d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    37d4:	eb 81       	ldd	r30, Y+3	; 0x03
    37d6:	fc 81       	ldd	r31, Y+4	; 0x04
    37d8:	82 e0       	ldi	r24, 0x02	; 2
    37da:	80 83       	st	Z, r24
	pxTopOfStack--;
    37dc:	8b 81       	ldd	r24, Y+3	; 0x03
    37de:	9c 81       	ldd	r25, Y+4	; 0x04
    37e0:	01 97       	sbiw	r24, 0x01	; 1
    37e2:	9c 83       	std	Y+4, r25	; 0x04
    37e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    37e6:	eb 81       	ldd	r30, Y+3	; 0x03
    37e8:	fc 81       	ldd	r31, Y+4	; 0x04
    37ea:	83 e0       	ldi	r24, 0x03	; 3
    37ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    37ee:	8b 81       	ldd	r24, Y+3	; 0x03
    37f0:	9c 81       	ldd	r25, Y+4	; 0x04
    37f2:	01 97       	sbiw	r24, 0x01	; 1
    37f4:	9c 83       	std	Y+4, r25	; 0x04
    37f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    37f8:	eb 81       	ldd	r30, Y+3	; 0x03
    37fa:	fc 81       	ldd	r31, Y+4	; 0x04
    37fc:	84 e0       	ldi	r24, 0x04	; 4
    37fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    3800:	8b 81       	ldd	r24, Y+3	; 0x03
    3802:	9c 81       	ldd	r25, Y+4	; 0x04
    3804:	01 97       	sbiw	r24, 0x01	; 1
    3806:	9c 83       	std	Y+4, r25	; 0x04
    3808:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    380a:	eb 81       	ldd	r30, Y+3	; 0x03
    380c:	fc 81       	ldd	r31, Y+4	; 0x04
    380e:	85 e0       	ldi	r24, 0x05	; 5
    3810:	80 83       	st	Z, r24
	pxTopOfStack--;
    3812:	8b 81       	ldd	r24, Y+3	; 0x03
    3814:	9c 81       	ldd	r25, Y+4	; 0x04
    3816:	01 97       	sbiw	r24, 0x01	; 1
    3818:	9c 83       	std	Y+4, r25	; 0x04
    381a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    381c:	eb 81       	ldd	r30, Y+3	; 0x03
    381e:	fc 81       	ldd	r31, Y+4	; 0x04
    3820:	86 e0       	ldi	r24, 0x06	; 6
    3822:	80 83       	st	Z, r24
	pxTopOfStack--;
    3824:	8b 81       	ldd	r24, Y+3	; 0x03
    3826:	9c 81       	ldd	r25, Y+4	; 0x04
    3828:	01 97       	sbiw	r24, 0x01	; 1
    382a:	9c 83       	std	Y+4, r25	; 0x04
    382c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    382e:	eb 81       	ldd	r30, Y+3	; 0x03
    3830:	fc 81       	ldd	r31, Y+4	; 0x04
    3832:	87 e0       	ldi	r24, 0x07	; 7
    3834:	80 83       	st	Z, r24
	pxTopOfStack--;
    3836:	8b 81       	ldd	r24, Y+3	; 0x03
    3838:	9c 81       	ldd	r25, Y+4	; 0x04
    383a:	01 97       	sbiw	r24, 0x01	; 1
    383c:	9c 83       	std	Y+4, r25	; 0x04
    383e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    3840:	eb 81       	ldd	r30, Y+3	; 0x03
    3842:	fc 81       	ldd	r31, Y+4	; 0x04
    3844:	88 e0       	ldi	r24, 0x08	; 8
    3846:	80 83       	st	Z, r24
	pxTopOfStack--;
    3848:	8b 81       	ldd	r24, Y+3	; 0x03
    384a:	9c 81       	ldd	r25, Y+4	; 0x04
    384c:	01 97       	sbiw	r24, 0x01	; 1
    384e:	9c 83       	std	Y+4, r25	; 0x04
    3850:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    3852:	eb 81       	ldd	r30, Y+3	; 0x03
    3854:	fc 81       	ldd	r31, Y+4	; 0x04
    3856:	89 e0       	ldi	r24, 0x09	; 9
    3858:	80 83       	st	Z, r24
	pxTopOfStack--;
    385a:	8b 81       	ldd	r24, Y+3	; 0x03
    385c:	9c 81       	ldd	r25, Y+4	; 0x04
    385e:	01 97       	sbiw	r24, 0x01	; 1
    3860:	9c 83       	std	Y+4, r25	; 0x04
    3862:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    3864:	eb 81       	ldd	r30, Y+3	; 0x03
    3866:	fc 81       	ldd	r31, Y+4	; 0x04
    3868:	80 e1       	ldi	r24, 0x10	; 16
    386a:	80 83       	st	Z, r24
	pxTopOfStack--;
    386c:	8b 81       	ldd	r24, Y+3	; 0x03
    386e:	9c 81       	ldd	r25, Y+4	; 0x04
    3870:	01 97       	sbiw	r24, 0x01	; 1
    3872:	9c 83       	std	Y+4, r25	; 0x04
    3874:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    3876:	eb 81       	ldd	r30, Y+3	; 0x03
    3878:	fc 81       	ldd	r31, Y+4	; 0x04
    387a:	81 e1       	ldi	r24, 0x11	; 17
    387c:	80 83       	st	Z, r24
	pxTopOfStack--;
    387e:	8b 81       	ldd	r24, Y+3	; 0x03
    3880:	9c 81       	ldd	r25, Y+4	; 0x04
    3882:	01 97       	sbiw	r24, 0x01	; 1
    3884:	9c 83       	std	Y+4, r25	; 0x04
    3886:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    3888:	eb 81       	ldd	r30, Y+3	; 0x03
    388a:	fc 81       	ldd	r31, Y+4	; 0x04
    388c:	82 e1       	ldi	r24, 0x12	; 18
    388e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3890:	8b 81       	ldd	r24, Y+3	; 0x03
    3892:	9c 81       	ldd	r25, Y+4	; 0x04
    3894:	01 97       	sbiw	r24, 0x01	; 1
    3896:	9c 83       	std	Y+4, r25	; 0x04
    3898:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    389a:	eb 81       	ldd	r30, Y+3	; 0x03
    389c:	fc 81       	ldd	r31, Y+4	; 0x04
    389e:	83 e1       	ldi	r24, 0x13	; 19
    38a0:	80 83       	st	Z, r24
	pxTopOfStack--;
    38a2:	8b 81       	ldd	r24, Y+3	; 0x03
    38a4:	9c 81       	ldd	r25, Y+4	; 0x04
    38a6:	01 97       	sbiw	r24, 0x01	; 1
    38a8:	9c 83       	std	Y+4, r25	; 0x04
    38aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    38ac:	eb 81       	ldd	r30, Y+3	; 0x03
    38ae:	fc 81       	ldd	r31, Y+4	; 0x04
    38b0:	84 e1       	ldi	r24, 0x14	; 20
    38b2:	80 83       	st	Z, r24
	pxTopOfStack--;
    38b4:	8b 81       	ldd	r24, Y+3	; 0x03
    38b6:	9c 81       	ldd	r25, Y+4	; 0x04
    38b8:	01 97       	sbiw	r24, 0x01	; 1
    38ba:	9c 83       	std	Y+4, r25	; 0x04
    38bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    38be:	eb 81       	ldd	r30, Y+3	; 0x03
    38c0:	fc 81       	ldd	r31, Y+4	; 0x04
    38c2:	85 e1       	ldi	r24, 0x15	; 21
    38c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    38c6:	8b 81       	ldd	r24, Y+3	; 0x03
    38c8:	9c 81       	ldd	r25, Y+4	; 0x04
    38ca:	01 97       	sbiw	r24, 0x01	; 1
    38cc:	9c 83       	std	Y+4, r25	; 0x04
    38ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    38d0:	eb 81       	ldd	r30, Y+3	; 0x03
    38d2:	fc 81       	ldd	r31, Y+4	; 0x04
    38d4:	86 e1       	ldi	r24, 0x16	; 22
    38d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    38d8:	8b 81       	ldd	r24, Y+3	; 0x03
    38da:	9c 81       	ldd	r25, Y+4	; 0x04
    38dc:	01 97       	sbiw	r24, 0x01	; 1
    38de:	9c 83       	std	Y+4, r25	; 0x04
    38e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    38e2:	eb 81       	ldd	r30, Y+3	; 0x03
    38e4:	fc 81       	ldd	r31, Y+4	; 0x04
    38e6:	87 e1       	ldi	r24, 0x17	; 23
    38e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    38ea:	8b 81       	ldd	r24, Y+3	; 0x03
    38ec:	9c 81       	ldd	r25, Y+4	; 0x04
    38ee:	01 97       	sbiw	r24, 0x01	; 1
    38f0:	9c 83       	std	Y+4, r25	; 0x04
    38f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    38f4:	eb 81       	ldd	r30, Y+3	; 0x03
    38f6:	fc 81       	ldd	r31, Y+4	; 0x04
    38f8:	88 e1       	ldi	r24, 0x18	; 24
    38fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    38fc:	8b 81       	ldd	r24, Y+3	; 0x03
    38fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3900:	01 97       	sbiw	r24, 0x01	; 1
    3902:	9c 83       	std	Y+4, r25	; 0x04
    3904:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    3906:	eb 81       	ldd	r30, Y+3	; 0x03
    3908:	fc 81       	ldd	r31, Y+4	; 0x04
    390a:	89 e1       	ldi	r24, 0x19	; 25
    390c:	80 83       	st	Z, r24
	pxTopOfStack--;
    390e:	8b 81       	ldd	r24, Y+3	; 0x03
    3910:	9c 81       	ldd	r25, Y+4	; 0x04
    3912:	01 97       	sbiw	r24, 0x01	; 1
    3914:	9c 83       	std	Y+4, r25	; 0x04
    3916:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    3918:	eb 81       	ldd	r30, Y+3	; 0x03
    391a:	fc 81       	ldd	r31, Y+4	; 0x04
    391c:	80 e2       	ldi	r24, 0x20	; 32
    391e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3920:	8b 81       	ldd	r24, Y+3	; 0x03
    3922:	9c 81       	ldd	r25, Y+4	; 0x04
    3924:	01 97       	sbiw	r24, 0x01	; 1
    3926:	9c 83       	std	Y+4, r25	; 0x04
    3928:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    392a:	eb 81       	ldd	r30, Y+3	; 0x03
    392c:	fc 81       	ldd	r31, Y+4	; 0x04
    392e:	81 e2       	ldi	r24, 0x21	; 33
    3930:	80 83       	st	Z, r24
	pxTopOfStack--;
    3932:	8b 81       	ldd	r24, Y+3	; 0x03
    3934:	9c 81       	ldd	r25, Y+4	; 0x04
    3936:	01 97       	sbiw	r24, 0x01	; 1
    3938:	9c 83       	std	Y+4, r25	; 0x04
    393a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    393c:	eb 81       	ldd	r30, Y+3	; 0x03
    393e:	fc 81       	ldd	r31, Y+4	; 0x04
    3940:	82 e2       	ldi	r24, 0x22	; 34
    3942:	80 83       	st	Z, r24
	pxTopOfStack--;
    3944:	8b 81       	ldd	r24, Y+3	; 0x03
    3946:	9c 81       	ldd	r25, Y+4	; 0x04
    3948:	01 97       	sbiw	r24, 0x01	; 1
    394a:	9c 83       	std	Y+4, r25	; 0x04
    394c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    394e:	eb 81       	ldd	r30, Y+3	; 0x03
    3950:	fc 81       	ldd	r31, Y+4	; 0x04
    3952:	83 e2       	ldi	r24, 0x23	; 35
    3954:	80 83       	st	Z, r24
	pxTopOfStack--;
    3956:	8b 81       	ldd	r24, Y+3	; 0x03
    3958:	9c 81       	ldd	r25, Y+4	; 0x04
    395a:	01 97       	sbiw	r24, 0x01	; 1
    395c:	9c 83       	std	Y+4, r25	; 0x04
    395e:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    3960:	8f 81       	ldd	r24, Y+7	; 0x07
    3962:	98 85       	ldd	r25, Y+8	; 0x08
    3964:	9a 83       	std	Y+2, r25	; 0x02
    3966:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3968:	89 81       	ldd	r24, Y+1	; 0x01
    396a:	eb 81       	ldd	r30, Y+3	; 0x03
    396c:	fc 81       	ldd	r31, Y+4	; 0x04
    396e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3970:	8b 81       	ldd	r24, Y+3	; 0x03
    3972:	9c 81       	ldd	r25, Y+4	; 0x04
    3974:	01 97       	sbiw	r24, 0x01	; 1
    3976:	9c 83       	std	Y+4, r25	; 0x04
    3978:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    397a:	89 81       	ldd	r24, Y+1	; 0x01
    397c:	9a 81       	ldd	r25, Y+2	; 0x02
    397e:	89 2f       	mov	r24, r25
    3980:	99 27       	eor	r25, r25
    3982:	9a 83       	std	Y+2, r25	; 0x02
    3984:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3986:	89 81       	ldd	r24, Y+1	; 0x01
    3988:	eb 81       	ldd	r30, Y+3	; 0x03
    398a:	fc 81       	ldd	r31, Y+4	; 0x04
    398c:	80 83       	st	Z, r24
	pxTopOfStack--;
    398e:	8b 81       	ldd	r24, Y+3	; 0x03
    3990:	9c 81       	ldd	r25, Y+4	; 0x04
    3992:	01 97       	sbiw	r24, 0x01	; 1
    3994:	9c 83       	std	Y+4, r25	; 0x04
    3996:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    3998:	eb 81       	ldd	r30, Y+3	; 0x03
    399a:	fc 81       	ldd	r31, Y+4	; 0x04
    399c:	86 e2       	ldi	r24, 0x26	; 38
    399e:	80 83       	st	Z, r24
	pxTopOfStack--;
    39a0:	8b 81       	ldd	r24, Y+3	; 0x03
    39a2:	9c 81       	ldd	r25, Y+4	; 0x04
    39a4:	01 97       	sbiw	r24, 0x01	; 1
    39a6:	9c 83       	std	Y+4, r25	; 0x04
    39a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    39aa:	eb 81       	ldd	r30, Y+3	; 0x03
    39ac:	fc 81       	ldd	r31, Y+4	; 0x04
    39ae:	87 e2       	ldi	r24, 0x27	; 39
    39b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    39b2:	8b 81       	ldd	r24, Y+3	; 0x03
    39b4:	9c 81       	ldd	r25, Y+4	; 0x04
    39b6:	01 97       	sbiw	r24, 0x01	; 1
    39b8:	9c 83       	std	Y+4, r25	; 0x04
    39ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    39bc:	eb 81       	ldd	r30, Y+3	; 0x03
    39be:	fc 81       	ldd	r31, Y+4	; 0x04
    39c0:	88 e2       	ldi	r24, 0x28	; 40
    39c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    39c4:	8b 81       	ldd	r24, Y+3	; 0x03
    39c6:	9c 81       	ldd	r25, Y+4	; 0x04
    39c8:	01 97       	sbiw	r24, 0x01	; 1
    39ca:	9c 83       	std	Y+4, r25	; 0x04
    39cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    39ce:	eb 81       	ldd	r30, Y+3	; 0x03
    39d0:	fc 81       	ldd	r31, Y+4	; 0x04
    39d2:	89 e2       	ldi	r24, 0x29	; 41
    39d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    39d6:	8b 81       	ldd	r24, Y+3	; 0x03
    39d8:	9c 81       	ldd	r25, Y+4	; 0x04
    39da:	01 97       	sbiw	r24, 0x01	; 1
    39dc:	9c 83       	std	Y+4, r25	; 0x04
    39de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    39e0:	eb 81       	ldd	r30, Y+3	; 0x03
    39e2:	fc 81       	ldd	r31, Y+4	; 0x04
    39e4:	80 e3       	ldi	r24, 0x30	; 48
    39e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    39e8:	8b 81       	ldd	r24, Y+3	; 0x03
    39ea:	9c 81       	ldd	r25, Y+4	; 0x04
    39ec:	01 97       	sbiw	r24, 0x01	; 1
    39ee:	9c 83       	std	Y+4, r25	; 0x04
    39f0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    39f2:	eb 81       	ldd	r30, Y+3	; 0x03
    39f4:	fc 81       	ldd	r31, Y+4	; 0x04
    39f6:	81 e3       	ldi	r24, 0x31	; 49
    39f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    39fa:	8b 81       	ldd	r24, Y+3	; 0x03
    39fc:	9c 81       	ldd	r25, Y+4	; 0x04
    39fe:	01 97       	sbiw	r24, 0x01	; 1
    3a00:	9c 83       	std	Y+4, r25	; 0x04
    3a02:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3a04:	8b 81       	ldd	r24, Y+3	; 0x03
    3a06:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3a08:	28 96       	adiw	r28, 0x08	; 8
    3a0a:	0f b6       	in	r0, 0x3f	; 63
    3a0c:	f8 94       	cli
    3a0e:	de bf       	out	0x3e, r29	; 62
    3a10:	0f be       	out	0x3f, r0	; 63
    3a12:	cd bf       	out	0x3d, r28	; 61
    3a14:	cf 91       	pop	r28
    3a16:	df 91       	pop	r29
    3a18:	08 95       	ret

00003a1a <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    3a1a:	df 93       	push	r29
    3a1c:	cf 93       	push	r28
    3a1e:	cd b7       	in	r28, 0x3d	; 61
    3a20:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    3a22:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3a26:	a0 91 9d 07 	lds	r26, 0x079D
    3a2a:	b0 91 9e 07 	lds	r27, 0x079E
    3a2e:	cd 91       	ld	r28, X+
    3a30:	cd bf       	out	0x3d, r28	; 61
    3a32:	dd 91       	ld	r29, X+
    3a34:	de bf       	out	0x3e, r29	; 62
    3a36:	ff 91       	pop	r31
    3a38:	ef 91       	pop	r30
    3a3a:	df 91       	pop	r29
    3a3c:	cf 91       	pop	r28
    3a3e:	bf 91       	pop	r27
    3a40:	af 91       	pop	r26
    3a42:	9f 91       	pop	r25
    3a44:	8f 91       	pop	r24
    3a46:	7f 91       	pop	r23
    3a48:	6f 91       	pop	r22
    3a4a:	5f 91       	pop	r21
    3a4c:	4f 91       	pop	r20
    3a4e:	3f 91       	pop	r19
    3a50:	2f 91       	pop	r18
    3a52:	1f 91       	pop	r17
    3a54:	0f 91       	pop	r16
    3a56:	ff 90       	pop	r15
    3a58:	ef 90       	pop	r14
    3a5a:	df 90       	pop	r13
    3a5c:	cf 90       	pop	r12
    3a5e:	bf 90       	pop	r11
    3a60:	af 90       	pop	r10
    3a62:	9f 90       	pop	r9
    3a64:	8f 90       	pop	r8
    3a66:	7f 90       	pop	r7
    3a68:	6f 90       	pop	r6
    3a6a:	5f 90       	pop	r5
    3a6c:	4f 90       	pop	r4
    3a6e:	3f 90       	pop	r3
    3a70:	2f 90       	pop	r2
    3a72:	1f 90       	pop	r1
    3a74:	0f 90       	pop	r0
    3a76:	0f be       	out	0x3f, r0	; 63
    3a78:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3a7a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    3a7c:	81 e0       	ldi	r24, 0x01	; 1
}
    3a7e:	cf 91       	pop	r28
    3a80:	df 91       	pop	r29
    3a82:	08 95       	ret

00003a84 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3a84:	df 93       	push	r29
    3a86:	cf 93       	push	r28
    3a88:	cd b7       	in	r28, 0x3d	; 61
    3a8a:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    3a8c:	cf 91       	pop	r28
    3a8e:	df 91       	pop	r29
    3a90:	08 95       	ret

00003a92 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3a92:	0f 92       	push	r0
    3a94:	0f b6       	in	r0, 0x3f	; 63
    3a96:	f8 94       	cli
    3a98:	0f 92       	push	r0
    3a9a:	1f 92       	push	r1
    3a9c:	11 24       	eor	r1, r1
    3a9e:	2f 92       	push	r2
    3aa0:	3f 92       	push	r3
    3aa2:	4f 92       	push	r4
    3aa4:	5f 92       	push	r5
    3aa6:	6f 92       	push	r6
    3aa8:	7f 92       	push	r7
    3aaa:	8f 92       	push	r8
    3aac:	9f 92       	push	r9
    3aae:	af 92       	push	r10
    3ab0:	bf 92       	push	r11
    3ab2:	cf 92       	push	r12
    3ab4:	df 92       	push	r13
    3ab6:	ef 92       	push	r14
    3ab8:	ff 92       	push	r15
    3aba:	0f 93       	push	r16
    3abc:	1f 93       	push	r17
    3abe:	2f 93       	push	r18
    3ac0:	3f 93       	push	r19
    3ac2:	4f 93       	push	r20
    3ac4:	5f 93       	push	r21
    3ac6:	6f 93       	push	r22
    3ac8:	7f 93       	push	r23
    3aca:	8f 93       	push	r24
    3acc:	9f 93       	push	r25
    3ace:	af 93       	push	r26
    3ad0:	bf 93       	push	r27
    3ad2:	cf 93       	push	r28
    3ad4:	df 93       	push	r29
    3ad6:	ef 93       	push	r30
    3ad8:	ff 93       	push	r31
    3ada:	a0 91 9d 07 	lds	r26, 0x079D
    3ade:	b0 91 9e 07 	lds	r27, 0x079E
    3ae2:	0d b6       	in	r0, 0x3d	; 61
    3ae4:	0d 92       	st	X+, r0
    3ae6:	0e b6       	in	r0, 0x3e	; 62
    3ae8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3aea:	0e 94 71 29 	call	0x52e2	; 0x52e2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3aee:	a0 91 9d 07 	lds	r26, 0x079D
    3af2:	b0 91 9e 07 	lds	r27, 0x079E
    3af6:	cd 91       	ld	r28, X+
    3af8:	cd bf       	out	0x3d, r28	; 61
    3afa:	dd 91       	ld	r29, X+
    3afc:	de bf       	out	0x3e, r29	; 62
    3afe:	ff 91       	pop	r31
    3b00:	ef 91       	pop	r30
    3b02:	df 91       	pop	r29
    3b04:	cf 91       	pop	r28
    3b06:	bf 91       	pop	r27
    3b08:	af 91       	pop	r26
    3b0a:	9f 91       	pop	r25
    3b0c:	8f 91       	pop	r24
    3b0e:	7f 91       	pop	r23
    3b10:	6f 91       	pop	r22
    3b12:	5f 91       	pop	r21
    3b14:	4f 91       	pop	r20
    3b16:	3f 91       	pop	r19
    3b18:	2f 91       	pop	r18
    3b1a:	1f 91       	pop	r17
    3b1c:	0f 91       	pop	r16
    3b1e:	ff 90       	pop	r15
    3b20:	ef 90       	pop	r14
    3b22:	df 90       	pop	r13
    3b24:	cf 90       	pop	r12
    3b26:	bf 90       	pop	r11
    3b28:	af 90       	pop	r10
    3b2a:	9f 90       	pop	r9
    3b2c:	8f 90       	pop	r8
    3b2e:	7f 90       	pop	r7
    3b30:	6f 90       	pop	r6
    3b32:	5f 90       	pop	r5
    3b34:	4f 90       	pop	r4
    3b36:	3f 90       	pop	r3
    3b38:	2f 90       	pop	r2
    3b3a:	1f 90       	pop	r1
    3b3c:	0f 90       	pop	r0
    3b3e:	0f be       	out	0x3f, r0	; 63
    3b40:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3b42:	08 95       	ret

00003b44 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3b44:	0f 92       	push	r0
    3b46:	0f b6       	in	r0, 0x3f	; 63
    3b48:	f8 94       	cli
    3b4a:	0f 92       	push	r0
    3b4c:	1f 92       	push	r1
    3b4e:	11 24       	eor	r1, r1
    3b50:	2f 92       	push	r2
    3b52:	3f 92       	push	r3
    3b54:	4f 92       	push	r4
    3b56:	5f 92       	push	r5
    3b58:	6f 92       	push	r6
    3b5a:	7f 92       	push	r7
    3b5c:	8f 92       	push	r8
    3b5e:	9f 92       	push	r9
    3b60:	af 92       	push	r10
    3b62:	bf 92       	push	r11
    3b64:	cf 92       	push	r12
    3b66:	df 92       	push	r13
    3b68:	ef 92       	push	r14
    3b6a:	ff 92       	push	r15
    3b6c:	0f 93       	push	r16
    3b6e:	1f 93       	push	r17
    3b70:	2f 93       	push	r18
    3b72:	3f 93       	push	r19
    3b74:	4f 93       	push	r20
    3b76:	5f 93       	push	r21
    3b78:	6f 93       	push	r22
    3b7a:	7f 93       	push	r23
    3b7c:	8f 93       	push	r24
    3b7e:	9f 93       	push	r25
    3b80:	af 93       	push	r26
    3b82:	bf 93       	push	r27
    3b84:	cf 93       	push	r28
    3b86:	df 93       	push	r29
    3b88:	ef 93       	push	r30
    3b8a:	ff 93       	push	r31
    3b8c:	a0 91 9d 07 	lds	r26, 0x079D
    3b90:	b0 91 9e 07 	lds	r27, 0x079E
    3b94:	0d b6       	in	r0, 0x3d	; 61
    3b96:	0d 92       	st	X+, r0
    3b98:	0e b6       	in	r0, 0x3e	; 62
    3b9a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    3b9c:	0e 94 8a 28 	call	0x5114	; 0x5114 <xTaskIncrementTick>
    3ba0:	88 23       	and	r24, r24
    3ba2:	11 f0       	breq	.+4      	; 0x3ba8 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    3ba4:	0e 94 71 29 	call	0x52e2	; 0x52e2 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    3ba8:	a0 91 9d 07 	lds	r26, 0x079D
    3bac:	b0 91 9e 07 	lds	r27, 0x079E
    3bb0:	cd 91       	ld	r28, X+
    3bb2:	cd bf       	out	0x3d, r28	; 61
    3bb4:	dd 91       	ld	r29, X+
    3bb6:	de bf       	out	0x3e, r29	; 62
    3bb8:	ff 91       	pop	r31
    3bba:	ef 91       	pop	r30
    3bbc:	df 91       	pop	r29
    3bbe:	cf 91       	pop	r28
    3bc0:	bf 91       	pop	r27
    3bc2:	af 91       	pop	r26
    3bc4:	9f 91       	pop	r25
    3bc6:	8f 91       	pop	r24
    3bc8:	7f 91       	pop	r23
    3bca:	6f 91       	pop	r22
    3bcc:	5f 91       	pop	r21
    3bce:	4f 91       	pop	r20
    3bd0:	3f 91       	pop	r19
    3bd2:	2f 91       	pop	r18
    3bd4:	1f 91       	pop	r17
    3bd6:	0f 91       	pop	r16
    3bd8:	ff 90       	pop	r15
    3bda:	ef 90       	pop	r14
    3bdc:	df 90       	pop	r13
    3bde:	cf 90       	pop	r12
    3be0:	bf 90       	pop	r11
    3be2:	af 90       	pop	r10
    3be4:	9f 90       	pop	r9
    3be6:	8f 90       	pop	r8
    3be8:	7f 90       	pop	r7
    3bea:	6f 90       	pop	r6
    3bec:	5f 90       	pop	r5
    3bee:	4f 90       	pop	r4
    3bf0:	3f 90       	pop	r3
    3bf2:	2f 90       	pop	r2
    3bf4:	1f 90       	pop	r1
    3bf6:	0f 90       	pop	r0
    3bf8:	0f be       	out	0x3f, r0	; 63
    3bfa:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3bfc:	08 95       	ret

00003bfe <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3bfe:	df 93       	push	r29
    3c00:	cf 93       	push	r28
    3c02:	00 d0       	rcall	.+0      	; 0x3c04 <prvSetupTimerInterrupt+0x6>
    3c04:	00 d0       	rcall	.+0      	; 0x3c06 <prvSetupTimerInterrupt+0x8>
    3c06:	00 d0       	rcall	.+0      	; 0x3c08 <prvSetupTimerInterrupt+0xa>
    3c08:	cd b7       	in	r28, 0x3d	; 61
    3c0a:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3c0c:	80 e4       	ldi	r24, 0x40	; 64
    3c0e:	9f e1       	ldi	r25, 0x1F	; 31
    3c10:	a0 e0       	ldi	r26, 0x00	; 0
    3c12:	b0 e0       	ldi	r27, 0x00	; 0
    3c14:	8b 83       	std	Y+3, r24	; 0x03
    3c16:	9c 83       	std	Y+4, r25	; 0x04
    3c18:	ad 83       	std	Y+5, r26	; 0x05
    3c1a:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    3c1c:	8b 81       	ldd	r24, Y+3	; 0x03
    3c1e:	9c 81       	ldd	r25, Y+4	; 0x04
    3c20:	ad 81       	ldd	r26, Y+5	; 0x05
    3c22:	be 81       	ldd	r27, Y+6	; 0x06
    3c24:	68 94       	set
    3c26:	15 f8       	bld	r1, 5
    3c28:	b6 95       	lsr	r27
    3c2a:	a7 95       	ror	r26
    3c2c:	97 95       	ror	r25
    3c2e:	87 95       	ror	r24
    3c30:	16 94       	lsr	r1
    3c32:	d1 f7       	brne	.-12     	; 0x3c28 <prvSetupTimerInterrupt+0x2a>
    3c34:	8b 83       	std	Y+3, r24	; 0x03
    3c36:	9c 83       	std	Y+4, r25	; 0x04
    3c38:	ad 83       	std	Y+5, r26	; 0x05
    3c3a:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    3c3c:	8b 81       	ldd	r24, Y+3	; 0x03
    3c3e:	9c 81       	ldd	r25, Y+4	; 0x04
    3c40:	ad 81       	ldd	r26, Y+5	; 0x05
    3c42:	be 81       	ldd	r27, Y+6	; 0x06
    3c44:	01 97       	sbiw	r24, 0x01	; 1
    3c46:	a1 09       	sbc	r26, r1
    3c48:	b1 09       	sbc	r27, r1
    3c4a:	8b 83       	std	Y+3, r24	; 0x03
    3c4c:	9c 83       	std	Y+4, r25	; 0x04
    3c4e:	ad 83       	std	Y+5, r26	; 0x05
    3c50:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    3c52:	8b 81       	ldd	r24, Y+3	; 0x03
    3c54:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    3c56:	8b 81       	ldd	r24, Y+3	; 0x03
    3c58:	9c 81       	ldd	r25, Y+4	; 0x04
    3c5a:	ad 81       	ldd	r26, Y+5	; 0x05
    3c5c:	be 81       	ldd	r27, Y+6	; 0x06
    3c5e:	89 2f       	mov	r24, r25
    3c60:	9a 2f       	mov	r25, r26
    3c62:	ab 2f       	mov	r26, r27
    3c64:	bb 27       	eor	r27, r27
    3c66:	8b 83       	std	Y+3, r24	; 0x03
    3c68:	9c 83       	std	Y+4, r25	; 0x04
    3c6a:	ad 83       	std	Y+5, r26	; 0x05
    3c6c:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    3c6e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c70:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    3c72:	eb e4       	ldi	r30, 0x4B	; 75
    3c74:	f0 e0       	ldi	r31, 0x00	; 0
    3c76:	8a 81       	ldd	r24, Y+2	; 0x02
    3c78:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    3c7a:	ea e4       	ldi	r30, 0x4A	; 74
    3c7c:	f0 e0       	ldi	r31, 0x00	; 0
    3c7e:	89 81       	ldd	r24, Y+1	; 0x01
    3c80:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    3c82:	8b e0       	ldi	r24, 0x0B	; 11
    3c84:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    3c86:	ee e4       	ldi	r30, 0x4E	; 78
    3c88:	f0 e0       	ldi	r31, 0x00	; 0
    3c8a:	89 81       	ldd	r24, Y+1	; 0x01
    3c8c:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    3c8e:	e9 e5       	ldi	r30, 0x59	; 89
    3c90:	f0 e0       	ldi	r31, 0x00	; 0
    3c92:	80 81       	ld	r24, Z
    3c94:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3c96:	89 81       	ldd	r24, Y+1	; 0x01
    3c98:	80 61       	ori	r24, 0x10	; 16
    3c9a:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    3c9c:	e9 e5       	ldi	r30, 0x59	; 89
    3c9e:	f0 e0       	ldi	r31, 0x00	; 0
    3ca0:	89 81       	ldd	r24, Y+1	; 0x01
    3ca2:	80 83       	st	Z, r24
}
    3ca4:	26 96       	adiw	r28, 0x06	; 6
    3ca6:	0f b6       	in	r0, 0x3f	; 63
    3ca8:	f8 94       	cli
    3caa:	de bf       	out	0x3e, r29	; 62
    3cac:	0f be       	out	0x3f, r0	; 63
    3cae:	cd bf       	out	0x3d, r28	; 61
    3cb0:	cf 91       	pop	r28
    3cb2:	df 91       	pop	r29
    3cb4:	08 95       	ret

00003cb6 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    3cb6:	0e 94 a2 1d 	call	0x3b44	; 0x3b44 <vPortYieldFromTick>
		asm volatile ( "reti" );
    3cba:	18 95       	reti

00003cbc <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    3cbc:	df 93       	push	r29
    3cbe:	cf 93       	push	r28
    3cc0:	00 d0       	rcall	.+0      	; 0x3cc2 <xQueueGenericReset+0x6>
    3cc2:	00 d0       	rcall	.+0      	; 0x3cc4 <xQueueGenericReset+0x8>
    3cc4:	0f 92       	push	r0
    3cc6:	cd b7       	in	r28, 0x3d	; 61
    3cc8:	de b7       	in	r29, 0x3e	; 62
    3cca:	9c 83       	std	Y+4, r25	; 0x04
    3ccc:	8b 83       	std	Y+3, r24	; 0x03
    3cce:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3cd0:	8b 81       	ldd	r24, Y+3	; 0x03
    3cd2:	9c 81       	ldd	r25, Y+4	; 0x04
    3cd4:	9a 83       	std	Y+2, r25	; 0x02
    3cd6:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3cd8:	0f b6       	in	r0, 0x3f	; 63
    3cda:	f8 94       	cli
    3cdc:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    3cde:	e9 81       	ldd	r30, Y+1	; 0x01
    3ce0:	fa 81       	ldd	r31, Y+2	; 0x02
    3ce2:	40 81       	ld	r20, Z
    3ce4:	51 81       	ldd	r21, Z+1	; 0x01
    3ce6:	e9 81       	ldd	r30, Y+1	; 0x01
    3ce8:	fa 81       	ldd	r31, Y+2	; 0x02
    3cea:	83 8d       	ldd	r24, Z+27	; 0x1b
    3cec:	28 2f       	mov	r18, r24
    3cee:	30 e0       	ldi	r19, 0x00	; 0
    3cf0:	e9 81       	ldd	r30, Y+1	; 0x01
    3cf2:	fa 81       	ldd	r31, Y+2	; 0x02
    3cf4:	84 8d       	ldd	r24, Z+28	; 0x1c
    3cf6:	88 2f       	mov	r24, r24
    3cf8:	90 e0       	ldi	r25, 0x00	; 0
    3cfa:	bc 01       	movw	r22, r24
    3cfc:	26 9f       	mul	r18, r22
    3cfe:	c0 01       	movw	r24, r0
    3d00:	27 9f       	mul	r18, r23
    3d02:	90 0d       	add	r25, r0
    3d04:	36 9f       	mul	r19, r22
    3d06:	90 0d       	add	r25, r0
    3d08:	11 24       	eor	r1, r1
    3d0a:	84 0f       	add	r24, r20
    3d0c:	95 1f       	adc	r25, r21
    3d0e:	e9 81       	ldd	r30, Y+1	; 0x01
    3d10:	fa 81       	ldd	r31, Y+2	; 0x02
    3d12:	93 83       	std	Z+3, r25	; 0x03
    3d14:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    3d16:	e9 81       	ldd	r30, Y+1	; 0x01
    3d18:	fa 81       	ldd	r31, Y+2	; 0x02
    3d1a:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    3d1c:	e9 81       	ldd	r30, Y+1	; 0x01
    3d1e:	fa 81       	ldd	r31, Y+2	; 0x02
    3d20:	80 81       	ld	r24, Z
    3d22:	91 81       	ldd	r25, Z+1	; 0x01
    3d24:	e9 81       	ldd	r30, Y+1	; 0x01
    3d26:	fa 81       	ldd	r31, Y+2	; 0x02
    3d28:	95 83       	std	Z+5, r25	; 0x05
    3d2a:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    3d2c:	e9 81       	ldd	r30, Y+1	; 0x01
    3d2e:	fa 81       	ldd	r31, Y+2	; 0x02
    3d30:	40 81       	ld	r20, Z
    3d32:	51 81       	ldd	r21, Z+1	; 0x01
    3d34:	e9 81       	ldd	r30, Y+1	; 0x01
    3d36:	fa 81       	ldd	r31, Y+2	; 0x02
    3d38:	83 8d       	ldd	r24, Z+27	; 0x1b
    3d3a:	88 2f       	mov	r24, r24
    3d3c:	90 e0       	ldi	r25, 0x00	; 0
    3d3e:	9c 01       	movw	r18, r24
    3d40:	21 50       	subi	r18, 0x01	; 1
    3d42:	30 40       	sbci	r19, 0x00	; 0
    3d44:	e9 81       	ldd	r30, Y+1	; 0x01
    3d46:	fa 81       	ldd	r31, Y+2	; 0x02
    3d48:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d4a:	88 2f       	mov	r24, r24
    3d4c:	90 e0       	ldi	r25, 0x00	; 0
    3d4e:	bc 01       	movw	r22, r24
    3d50:	26 9f       	mul	r18, r22
    3d52:	c0 01       	movw	r24, r0
    3d54:	27 9f       	mul	r18, r23
    3d56:	90 0d       	add	r25, r0
    3d58:	36 9f       	mul	r19, r22
    3d5a:	90 0d       	add	r25, r0
    3d5c:	11 24       	eor	r1, r1
    3d5e:	84 0f       	add	r24, r20
    3d60:	95 1f       	adc	r25, r21
    3d62:	e9 81       	ldd	r30, Y+1	; 0x01
    3d64:	fa 81       	ldd	r31, Y+2	; 0x02
    3d66:	97 83       	std	Z+7, r25	; 0x07
    3d68:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    3d6a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d6c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d6e:	8f ef       	ldi	r24, 0xFF	; 255
    3d70:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    3d72:	e9 81       	ldd	r30, Y+1	; 0x01
    3d74:	fa 81       	ldd	r31, Y+2	; 0x02
    3d76:	8f ef       	ldi	r24, 0xFF	; 255
    3d78:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    3d7a:	8d 81       	ldd	r24, Y+5	; 0x05
    3d7c:	88 23       	and	r24, r24
    3d7e:	79 f4       	brne	.+30     	; 0x3d9e <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3d80:	e9 81       	ldd	r30, Y+1	; 0x01
    3d82:	fa 81       	ldd	r31, Y+2	; 0x02
    3d84:	80 85       	ldd	r24, Z+8	; 0x08
    3d86:	88 23       	and	r24, r24
    3d88:	a1 f0       	breq	.+40     	; 0x3db2 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3d8a:	89 81       	ldd	r24, Y+1	; 0x01
    3d8c:	9a 81       	ldd	r25, Y+2	; 0x02
    3d8e:	08 96       	adiw	r24, 0x08	; 8
    3d90:	0e 94 52 2a 	call	0x54a4	; 0x54a4 <xTaskRemoveFromEventList>
    3d94:	81 30       	cpi	r24, 0x01	; 1
    3d96:	69 f4       	brne	.+26     	; 0x3db2 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    3d98:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <vPortYield>
    3d9c:	0a c0       	rjmp	.+20     	; 0x3db2 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    3d9e:	89 81       	ldd	r24, Y+1	; 0x01
    3da0:	9a 81       	ldd	r25, Y+2	; 0x02
    3da2:	08 96       	adiw	r24, 0x08	; 8
    3da4:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    3da8:	89 81       	ldd	r24, Y+1	; 0x01
    3daa:	9a 81       	ldd	r25, Y+2	; 0x02
    3dac:	41 96       	adiw	r24, 0x11	; 17
    3dae:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    3db2:	0f 90       	pop	r0
    3db4:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    3db6:	81 e0       	ldi	r24, 0x01	; 1
}
    3db8:	0f 90       	pop	r0
    3dba:	0f 90       	pop	r0
    3dbc:	0f 90       	pop	r0
    3dbe:	0f 90       	pop	r0
    3dc0:	0f 90       	pop	r0
    3dc2:	cf 91       	pop	r28
    3dc4:	df 91       	pop	r29
    3dc6:	08 95       	ret

00003dc8 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    3dc8:	df 93       	push	r29
    3dca:	cf 93       	push	r28
    3dcc:	cd b7       	in	r28, 0x3d	; 61
    3dce:	de b7       	in	r29, 0x3e	; 62
    3dd0:	29 97       	sbiw	r28, 0x09	; 9
    3dd2:	0f b6       	in	r0, 0x3f	; 63
    3dd4:	f8 94       	cli
    3dd6:	de bf       	out	0x3e, r29	; 62
    3dd8:	0f be       	out	0x3f, r0	; 63
    3dda:	cd bf       	out	0x3d, r28	; 61
    3ddc:	8f 83       	std	Y+7, r24	; 0x07
    3dde:	68 87       	std	Y+8, r22	; 0x08
    3de0:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    3de2:	1a 82       	std	Y+2, r1	; 0x02
    3de4:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    3de6:	8f 81       	ldd	r24, Y+7	; 0x07
    3de8:	88 23       	and	r24, r24
    3dea:	09 f4       	brne	.+2      	; 0x3dee <xQueueGenericCreate+0x26>
    3dec:	3f c0       	rjmp	.+126    	; 0x3e6c <xQueueGenericCreate+0xa4>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    3dee:	8f e1       	ldi	r24, 0x1F	; 31
    3df0:	90 e0       	ldi	r25, 0x00	; 0
    3df2:	0e 94 06 19 	call	0x320c	; 0x320c <pvPortMalloc>
    3df6:	9e 83       	std	Y+6, r25	; 0x06
    3df8:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    3dfa:	8d 81       	ldd	r24, Y+5	; 0x05
    3dfc:	9e 81       	ldd	r25, Y+6	; 0x06
    3dfe:	00 97       	sbiw	r24, 0x00	; 0
    3e00:	a9 f1       	breq	.+106    	; 0x3e6c <xQueueGenericCreate+0xa4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3e02:	8f 81       	ldd	r24, Y+7	; 0x07
    3e04:	28 2f       	mov	r18, r24
    3e06:	30 e0       	ldi	r19, 0x00	; 0
    3e08:	88 85       	ldd	r24, Y+8	; 0x08
    3e0a:	88 2f       	mov	r24, r24
    3e0c:	90 e0       	ldi	r25, 0x00	; 0
    3e0e:	ac 01       	movw	r20, r24
    3e10:	24 9f       	mul	r18, r20
    3e12:	c0 01       	movw	r24, r0
    3e14:	25 9f       	mul	r18, r21
    3e16:	90 0d       	add	r25, r0
    3e18:	34 9f       	mul	r19, r20
    3e1a:	90 0d       	add	r25, r0
    3e1c:	11 24       	eor	r1, r1
    3e1e:	01 96       	adiw	r24, 0x01	; 1
    3e20:	9c 83       	std	Y+4, r25	; 0x04
    3e22:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    3e24:	8b 81       	ldd	r24, Y+3	; 0x03
    3e26:	9c 81       	ldd	r25, Y+4	; 0x04
    3e28:	0e 94 06 19 	call	0x320c	; 0x320c <pvPortMalloc>
    3e2c:	ed 81       	ldd	r30, Y+5	; 0x05
    3e2e:	fe 81       	ldd	r31, Y+6	; 0x06
    3e30:	91 83       	std	Z+1, r25	; 0x01
    3e32:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    3e34:	ed 81       	ldd	r30, Y+5	; 0x05
    3e36:	fe 81       	ldd	r31, Y+6	; 0x06
    3e38:	80 81       	ld	r24, Z
    3e3a:	91 81       	ldd	r25, Z+1	; 0x01
    3e3c:	00 97       	sbiw	r24, 0x00	; 0
    3e3e:	91 f0       	breq	.+36     	; 0x3e64 <xQueueGenericCreate+0x9c>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    3e40:	ed 81       	ldd	r30, Y+5	; 0x05
    3e42:	fe 81       	ldd	r31, Y+6	; 0x06
    3e44:	8f 81       	ldd	r24, Y+7	; 0x07
    3e46:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    3e48:	ed 81       	ldd	r30, Y+5	; 0x05
    3e4a:	fe 81       	ldd	r31, Y+6	; 0x06
    3e4c:	88 85       	ldd	r24, Y+8	; 0x08
    3e4e:	84 8f       	std	Z+28, r24	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    3e50:	8d 81       	ldd	r24, Y+5	; 0x05
    3e52:	9e 81       	ldd	r25, Y+6	; 0x06
    3e54:	61 e0       	ldi	r22, 0x01	; 1
    3e56:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    3e5a:	8d 81       	ldd	r24, Y+5	; 0x05
    3e5c:	9e 81       	ldd	r25, Y+6	; 0x06
    3e5e:	9a 83       	std	Y+2, r25	; 0x02
    3e60:	89 83       	std	Y+1, r24	; 0x01
    3e62:	04 c0       	rjmp	.+8      	; 0x3e6c <xQueueGenericCreate+0xa4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    3e64:	8d 81       	ldd	r24, Y+5	; 0x05
    3e66:	9e 81       	ldd	r25, Y+6	; 0x06
    3e68:	0e 94 5c 19 	call	0x32b8	; 0x32b8 <vPortFree>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    3e6c:	89 81       	ldd	r24, Y+1	; 0x01
    3e6e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3e70:	29 96       	adiw	r28, 0x09	; 9
    3e72:	0f b6       	in	r0, 0x3f	; 63
    3e74:	f8 94       	cli
    3e76:	de bf       	out	0x3e, r29	; 62
    3e78:	0f be       	out	0x3f, r0	; 63
    3e7a:	cd bf       	out	0x3d, r28	; 61
    3e7c:	cf 91       	pop	r28
    3e7e:	df 91       	pop	r29
    3e80:	08 95       	ret

00003e82 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    3e82:	df 93       	push	r29
    3e84:	cf 93       	push	r28
    3e86:	00 d0       	rcall	.+0      	; 0x3e88 <xQueueCreateCountingSemaphore+0x6>
    3e88:	00 d0       	rcall	.+0      	; 0x3e8a <xQueueCreateCountingSemaphore+0x8>
    3e8a:	cd b7       	in	r28, 0x3d	; 61
    3e8c:	de b7       	in	r29, 0x3e	; 62
    3e8e:	8b 83       	std	Y+3, r24	; 0x03
    3e90:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    3e92:	8b 81       	ldd	r24, Y+3	; 0x03
    3e94:	60 e0       	ldi	r22, 0x00	; 0
    3e96:	42 e0       	ldi	r20, 0x02	; 2
    3e98:	0e 94 e4 1e 	call	0x3dc8	; 0x3dc8 <xQueueGenericCreate>
    3e9c:	9a 83       	std	Y+2, r25	; 0x02
    3e9e:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    3ea0:	89 81       	ldd	r24, Y+1	; 0x01
    3ea2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ea4:	00 97       	sbiw	r24, 0x00	; 0
    3ea6:	21 f0       	breq	.+8      	; 0x3eb0 <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    3ea8:	e9 81       	ldd	r30, Y+1	; 0x01
    3eaa:	fa 81       	ldd	r31, Y+2	; 0x02
    3eac:	8c 81       	ldd	r24, Y+4	; 0x04
    3eae:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
		return xHandle;
    3eb0:	89 81       	ldd	r24, Y+1	; 0x01
    3eb2:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    3eb4:	0f 90       	pop	r0
    3eb6:	0f 90       	pop	r0
    3eb8:	0f 90       	pop	r0
    3eba:	0f 90       	pop	r0
    3ebc:	cf 91       	pop	r28
    3ebe:	df 91       	pop	r29
    3ec0:	08 95       	ret

00003ec2 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    3ec2:	df 93       	push	r29
    3ec4:	cf 93       	push	r28
    3ec6:	cd b7       	in	r28, 0x3d	; 61
    3ec8:	de b7       	in	r29, 0x3e	; 62
    3eca:	2f 97       	sbiw	r28, 0x0f	; 15
    3ecc:	0f b6       	in	r0, 0x3f	; 63
    3ece:	f8 94       	cli
    3ed0:	de bf       	out	0x3e, r29	; 62
    3ed2:	0f be       	out	0x3f, r0	; 63
    3ed4:	cd bf       	out	0x3d, r28	; 61
    3ed6:	99 87       	std	Y+9, r25	; 0x09
    3ed8:	88 87       	std	Y+8, r24	; 0x08
    3eda:	7b 87       	std	Y+11, r23	; 0x0b
    3edc:	6a 87       	std	Y+10, r22	; 0x0a
    3ede:	5d 87       	std	Y+13, r21	; 0x0d
    3ee0:	4c 87       	std	Y+12, r20	; 0x0c
    3ee2:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    3ee4:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3ee6:	88 85       	ldd	r24, Y+8	; 0x08
    3ee8:	99 85       	ldd	r25, Y+9	; 0x09
    3eea:	9a 83       	std	Y+2, r25	; 0x02
    3eec:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3eee:	0f b6       	in	r0, 0x3f	; 63
    3ef0:	f8 94       	cli
    3ef2:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3ef4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ef6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ef8:	92 8d       	ldd	r25, Z+26	; 0x1a
    3efa:	e9 81       	ldd	r30, Y+1	; 0x01
    3efc:	fa 81       	ldd	r31, Y+2	; 0x02
    3efe:	83 8d       	ldd	r24, Z+27	; 0x1b
    3f00:	98 17       	cp	r25, r24
    3f02:	18 f0       	brcs	.+6      	; 0x3f0a <xQueueGenericSend+0x48>
    3f04:	8e 85       	ldd	r24, Y+14	; 0x0e
    3f06:	82 30       	cpi	r24, 0x02	; 2
    3f08:	11 f5       	brne	.+68     	; 0x3f4e <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3f0a:	89 81       	ldd	r24, Y+1	; 0x01
    3f0c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f0e:	2a 85       	ldd	r18, Y+10	; 0x0a
    3f10:	3b 85       	ldd	r19, Y+11	; 0x0b
    3f12:	b9 01       	movw	r22, r18
    3f14:	4e 85       	ldd	r20, Y+14	; 0x0e
    3f16:	0e 94 36 22 	call	0x446c	; 0x446c <prvCopyDataToQueue>
    3f1a:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3f1c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f1e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f20:	81 89       	ldd	r24, Z+17	; 0x11
    3f22:	88 23       	and	r24, r24
    3f24:	51 f0       	breq	.+20     	; 0x3f3a <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    3f26:	89 81       	ldd	r24, Y+1	; 0x01
    3f28:	9a 81       	ldd	r25, Y+2	; 0x02
    3f2a:	41 96       	adiw	r24, 0x11	; 17
    3f2c:	0e 94 52 2a 	call	0x54a4	; 0x54a4 <xTaskRemoveFromEventList>
    3f30:	81 30       	cpi	r24, 0x01	; 1
    3f32:	41 f4       	brne	.+16     	; 0x3f44 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    3f34:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <vPortYield>
    3f38:	05 c0       	rjmp	.+10     	; 0x3f44 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    3f3a:	8b 81       	ldd	r24, Y+3	; 0x03
    3f3c:	88 23       	and	r24, r24
    3f3e:	11 f0       	breq	.+4      	; 0x3f44 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    3f40:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    3f44:	0f 90       	pop	r0
    3f46:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3f48:	81 e0       	ldi	r24, 0x01	; 1
    3f4a:	8f 87       	std	Y+15, r24	; 0x0f
    3f4c:	5c c0       	rjmp	.+184    	; 0x4006 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3f4e:	8c 85       	ldd	r24, Y+12	; 0x0c
    3f50:	9d 85       	ldd	r25, Y+13	; 0x0d
    3f52:	00 97       	sbiw	r24, 0x00	; 0
    3f54:	21 f4       	brne	.+8      	; 0x3f5e <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3f56:	0f 90       	pop	r0
    3f58:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3f5a:	1f 86       	std	Y+15, r1	; 0x0f
    3f5c:	54 c0       	rjmp	.+168    	; 0x4006 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    3f5e:	8c 81       	ldd	r24, Y+4	; 0x04
    3f60:	88 23       	and	r24, r24
    3f62:	31 f4       	brne	.+12     	; 0x3f70 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3f64:	ce 01       	movw	r24, r28
    3f66:	05 96       	adiw	r24, 0x05	; 5
    3f68:	0e 94 22 2b 	call	0x5644	; 0x5644 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3f6c:	81 e0       	ldi	r24, 0x01	; 1
    3f6e:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3f70:	0f 90       	pop	r0
    3f72:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3f74:	0e 94 bf 27 	call	0x4f7e	; 0x4f7e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3f78:	0f b6       	in	r0, 0x3f	; 63
    3f7a:	f8 94       	cli
    3f7c:	0f 92       	push	r0
    3f7e:	e9 81       	ldd	r30, Y+1	; 0x01
    3f80:	fa 81       	ldd	r31, Y+2	; 0x02
    3f82:	85 8d       	ldd	r24, Z+29	; 0x1d
    3f84:	8f 3f       	cpi	r24, 0xFF	; 255
    3f86:	19 f4       	brne	.+6      	; 0x3f8e <xQueueGenericSend+0xcc>
    3f88:	e9 81       	ldd	r30, Y+1	; 0x01
    3f8a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f8c:	15 8e       	std	Z+29, r1	; 0x1d
    3f8e:	e9 81       	ldd	r30, Y+1	; 0x01
    3f90:	fa 81       	ldd	r31, Y+2	; 0x02
    3f92:	86 8d       	ldd	r24, Z+30	; 0x1e
    3f94:	8f 3f       	cpi	r24, 0xFF	; 255
    3f96:	19 f4       	brne	.+6      	; 0x3f9e <xQueueGenericSend+0xdc>
    3f98:	e9 81       	ldd	r30, Y+1	; 0x01
    3f9a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f9c:	16 8e       	std	Z+30, r1	; 0x1e
    3f9e:	0f 90       	pop	r0
    3fa0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3fa2:	ce 01       	movw	r24, r28
    3fa4:	05 96       	adiw	r24, 0x05	; 5
    3fa6:	9e 01       	movw	r18, r28
    3fa8:	24 5f       	subi	r18, 0xF4	; 244
    3faa:	3f 4f       	sbci	r19, 0xFF	; 255
    3fac:	b9 01       	movw	r22, r18
    3fae:	0e 94 3b 2b 	call	0x5676	; 0x5676 <xTaskCheckForTimeOut>
    3fb2:	88 23       	and	r24, r24
    3fb4:	09 f5       	brne	.+66     	; 0x3ff8 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3fb6:	89 81       	ldd	r24, Y+1	; 0x01
    3fb8:	9a 81       	ldd	r25, Y+2	; 0x02
    3fba:	0e 94 ad 23 	call	0x475a	; 0x475a <prvIsQueueFull>
    3fbe:	88 23       	and	r24, r24
    3fc0:	a1 f0       	breq	.+40     	; 0x3fea <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3fc2:	89 81       	ldd	r24, Y+1	; 0x01
    3fc4:	9a 81       	ldd	r25, Y+2	; 0x02
    3fc6:	08 96       	adiw	r24, 0x08	; 8
    3fc8:	2c 85       	ldd	r18, Y+12	; 0x0c
    3fca:	3d 85       	ldd	r19, Y+13	; 0x0d
    3fcc:	b9 01       	movw	r22, r18
    3fce:	0e 94 da 29 	call	0x53b4	; 0x53b4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3fd2:	89 81       	ldd	r24, Y+1	; 0x01
    3fd4:	9a 81       	ldd	r25, Y+2	; 0x02
    3fd6:	0e 94 24 23 	call	0x4648	; 0x4648 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3fda:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <xTaskResumeAll>
    3fde:	88 23       	and	r24, r24
    3fe0:	09 f0       	breq	.+2      	; 0x3fe4 <xQueueGenericSend+0x122>
    3fe2:	85 cf       	rjmp	.-246    	; 0x3eee <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    3fe4:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <vPortYield>
    3fe8:	82 cf       	rjmp	.-252    	; 0x3eee <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3fea:	89 81       	ldd	r24, Y+1	; 0x01
    3fec:	9a 81       	ldd	r25, Y+2	; 0x02
    3fee:	0e 94 24 23 	call	0x4648	; 0x4648 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3ff2:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <xTaskResumeAll>
    3ff6:	7b cf       	rjmp	.-266    	; 0x3eee <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3ff8:	89 81       	ldd	r24, Y+1	; 0x01
    3ffa:	9a 81       	ldd	r25, Y+2	; 0x02
    3ffc:	0e 94 24 23 	call	0x4648	; 0x4648 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    4000:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    4004:	1f 86       	std	Y+15, r1	; 0x0f
    4006:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
}
    4008:	2f 96       	adiw	r28, 0x0f	; 15
    400a:	0f b6       	in	r0, 0x3f	; 63
    400c:	f8 94       	cli
    400e:	de bf       	out	0x3e, r29	; 62
    4010:	0f be       	out	0x3f, r0	; 63
    4012:	cd bf       	out	0x3d, r28	; 61
    4014:	cf 91       	pop	r28
    4016:	df 91       	pop	r29
    4018:	08 95       	ret

0000401a <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    401a:	df 93       	push	r29
    401c:	cf 93       	push	r28
    401e:	cd b7       	in	r28, 0x3d	; 61
    4020:	de b7       	in	r29, 0x3e	; 62
    4022:	2b 97       	sbiw	r28, 0x0b	; 11
    4024:	0f b6       	in	r0, 0x3f	; 63
    4026:	f8 94       	cli
    4028:	de bf       	out	0x3e, r29	; 62
    402a:	0f be       	out	0x3f, r0	; 63
    402c:	cd bf       	out	0x3d, r28	; 61
    402e:	9e 83       	std	Y+6, r25	; 0x06
    4030:	8d 83       	std	Y+5, r24	; 0x05
    4032:	78 87       	std	Y+8, r23	; 0x08
    4034:	6f 83       	std	Y+7, r22	; 0x07
    4036:	5a 87       	std	Y+10, r21	; 0x0a
    4038:	49 87       	std	Y+9, r20	; 0x09
    403a:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    403c:	8d 81       	ldd	r24, Y+5	; 0x05
    403e:	9e 81       	ldd	r25, Y+6	; 0x06
    4040:	9a 83       	std	Y+2, r25	; 0x02
    4042:	89 83       	std	Y+1, r24	; 0x01
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4044:	1b 82       	std	Y+3, r1	; 0x03
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    4046:	e9 81       	ldd	r30, Y+1	; 0x01
    4048:	fa 81       	ldd	r31, Y+2	; 0x02
    404a:	92 8d       	ldd	r25, Z+26	; 0x1a
    404c:	e9 81       	ldd	r30, Y+1	; 0x01
    404e:	fa 81       	ldd	r31, Y+2	; 0x02
    4050:	83 8d       	ldd	r24, Z+27	; 0x1b
    4052:	98 17       	cp	r25, r24
    4054:	18 f0       	brcs	.+6      	; 0x405c <xQueueGenericSendFromISR+0x42>
    4056:	8b 85       	ldd	r24, Y+11	; 0x0b
    4058:	82 30       	cpi	r24, 0x02	; 2
    405a:	b1 f5       	brne	.+108    	; 0x40c8 <xQueueGenericSendFromISR+0xae>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    405c:	89 81       	ldd	r24, Y+1	; 0x01
    405e:	9a 81       	ldd	r25, Y+2	; 0x02
    4060:	2f 81       	ldd	r18, Y+7	; 0x07
    4062:	38 85       	ldd	r19, Y+8	; 0x08
    4064:	b9 01       	movw	r22, r18
    4066:	4b 85       	ldd	r20, Y+11	; 0x0b
    4068:	0e 94 36 22 	call	0x446c	; 0x446c <prvCopyDataToQueue>
    406c:	88 23       	and	r24, r24
    406e:	41 f0       	breq	.+16     	; 0x4080 <xQueueGenericSendFromISR+0x66>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    4070:	89 85       	ldd	r24, Y+9	; 0x09
    4072:	9a 85       	ldd	r25, Y+10	; 0x0a
    4074:	00 97       	sbiw	r24, 0x00	; 0
    4076:	21 f0       	breq	.+8      	; 0x4080 <xQueueGenericSendFromISR+0x66>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    4078:	e9 85       	ldd	r30, Y+9	; 0x09
    407a:	fa 85       	ldd	r31, Y+10	; 0x0a
    407c:	81 e0       	ldi	r24, 0x01	; 1
    407e:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    4080:	e9 81       	ldd	r30, Y+1	; 0x01
    4082:	fa 81       	ldd	r31, Y+2	; 0x02
    4084:	86 8d       	ldd	r24, Z+30	; 0x1e
    4086:	8f 3f       	cpi	r24, 0xFF	; 255
    4088:	a9 f4       	brne	.+42     	; 0x40b4 <xQueueGenericSendFromISR+0x9a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    408a:	e9 81       	ldd	r30, Y+1	; 0x01
    408c:	fa 81       	ldd	r31, Y+2	; 0x02
    408e:	81 89       	ldd	r24, Z+17	; 0x11
    4090:	88 23       	and	r24, r24
    4092:	b9 f0       	breq	.+46     	; 0x40c2 <xQueueGenericSendFromISR+0xa8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4094:	89 81       	ldd	r24, Y+1	; 0x01
    4096:	9a 81       	ldd	r25, Y+2	; 0x02
    4098:	41 96       	adiw	r24, 0x11	; 17
    409a:	0e 94 52 2a 	call	0x54a4	; 0x54a4 <xTaskRemoveFromEventList>
    409e:	88 23       	and	r24, r24
    40a0:	81 f0       	breq	.+32     	; 0x40c2 <xQueueGenericSendFromISR+0xa8>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    40a2:	89 85       	ldd	r24, Y+9	; 0x09
    40a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    40a6:	00 97       	sbiw	r24, 0x00	; 0
    40a8:	61 f0       	breq	.+24     	; 0x40c2 <xQueueGenericSendFromISR+0xa8>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    40aa:	e9 85       	ldd	r30, Y+9	; 0x09
    40ac:	fa 85       	ldd	r31, Y+10	; 0x0a
    40ae:	81 e0       	ldi	r24, 0x01	; 1
    40b0:	80 83       	st	Z, r24
    40b2:	07 c0       	rjmp	.+14     	; 0x40c2 <xQueueGenericSendFromISR+0xa8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    40b4:	e9 81       	ldd	r30, Y+1	; 0x01
    40b6:	fa 81       	ldd	r31, Y+2	; 0x02
    40b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    40ba:	8f 5f       	subi	r24, 0xFF	; 255
    40bc:	e9 81       	ldd	r30, Y+1	; 0x01
    40be:	fa 81       	ldd	r31, Y+2	; 0x02
    40c0:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    40c2:	81 e0       	ldi	r24, 0x01	; 1
    40c4:	8c 83       	std	Y+4, r24	; 0x04
    40c6:	01 c0       	rjmp	.+2      	; 0x40ca <xQueueGenericSendFromISR+0xb0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    40c8:	1c 82       	std	Y+4, r1	; 0x04
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    40ca:	8c 81       	ldd	r24, Y+4	; 0x04
}
    40cc:	2b 96       	adiw	r28, 0x0b	; 11
    40ce:	0f b6       	in	r0, 0x3f	; 63
    40d0:	f8 94       	cli
    40d2:	de bf       	out	0x3e, r29	; 62
    40d4:	0f be       	out	0x3f, r0	; 63
    40d6:	cd bf       	out	0x3d, r28	; 61
    40d8:	cf 91       	pop	r28
    40da:	df 91       	pop	r29
    40dc:	08 95       	ret

000040de <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    40de:	df 93       	push	r29
    40e0:	cf 93       	push	r28
    40e2:	cd b7       	in	r28, 0x3d	; 61
    40e4:	de b7       	in	r29, 0x3e	; 62
    40e6:	60 97       	sbiw	r28, 0x10	; 16
    40e8:	0f b6       	in	r0, 0x3f	; 63
    40ea:	f8 94       	cli
    40ec:	de bf       	out	0x3e, r29	; 62
    40ee:	0f be       	out	0x3f, r0	; 63
    40f0:	cd bf       	out	0x3d, r28	; 61
    40f2:	9a 87       	std	Y+10, r25	; 0x0a
    40f4:	89 87       	std	Y+9, r24	; 0x09
    40f6:	7c 87       	std	Y+12, r23	; 0x0c
    40f8:	6b 87       	std	Y+11, r22	; 0x0b
    40fa:	5e 87       	std	Y+14, r21	; 0x0e
    40fc:	4d 87       	std	Y+13, r20	; 0x0d
    40fe:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    4100:	1d 82       	std	Y+5, r1	; 0x05
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4102:	89 85       	ldd	r24, Y+9	; 0x09
    4104:	9a 85       	ldd	r25, Y+10	; 0x0a
    4106:	9a 83       	std	Y+2, r25	; 0x02
    4108:	89 83       	std	Y+1, r24	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    410a:	0f b6       	in	r0, 0x3f	; 63
    410c:	f8 94       	cli
    410e:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    4110:	e9 81       	ldd	r30, Y+1	; 0x01
    4112:	fa 81       	ldd	r31, Y+2	; 0x02
    4114:	82 8d       	ldd	r24, Z+26	; 0x1a
    4116:	88 23       	and	r24, r24
    4118:	09 f4       	brne	.+2      	; 0x411c <xQueueGenericReceive+0x3e>
    411a:	3f c0       	rjmp	.+126    	; 0x419a <xQueueGenericReceive+0xbc>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    411c:	e9 81       	ldd	r30, Y+1	; 0x01
    411e:	fa 81       	ldd	r31, Y+2	; 0x02
    4120:	86 81       	ldd	r24, Z+6	; 0x06
    4122:	97 81       	ldd	r25, Z+7	; 0x07
    4124:	9c 83       	std	Y+4, r25	; 0x04
    4126:	8b 83       	std	Y+3, r24	; 0x03

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    4128:	89 81       	ldd	r24, Y+1	; 0x01
    412a:	9a 81       	ldd	r25, Y+2	; 0x02
    412c:	2b 85       	ldd	r18, Y+11	; 0x0b
    412e:	3c 85       	ldd	r19, Y+12	; 0x0c
    4130:	b9 01       	movw	r22, r18
    4132:	0e 94 dd 22 	call	0x45ba	; 0x45ba <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    4136:	8f 85       	ldd	r24, Y+15	; 0x0f
    4138:	88 23       	and	r24, r24
    413a:	b1 f4       	brne	.+44     	; 0x4168 <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    413c:	e9 81       	ldd	r30, Y+1	; 0x01
    413e:	fa 81       	ldd	r31, Y+2	; 0x02
    4140:	82 8d       	ldd	r24, Z+26	; 0x1a
    4142:	81 50       	subi	r24, 0x01	; 1
    4144:	e9 81       	ldd	r30, Y+1	; 0x01
    4146:	fa 81       	ldd	r31, Y+2	; 0x02
    4148:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    414a:	e9 81       	ldd	r30, Y+1	; 0x01
    414c:	fa 81       	ldd	r31, Y+2	; 0x02
    414e:	80 85       	ldd	r24, Z+8	; 0x08
    4150:	88 23       	and	r24, r24
    4152:	f1 f0       	breq	.+60     	; 0x4190 <xQueueGenericReceive+0xb2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    4154:	89 81       	ldd	r24, Y+1	; 0x01
    4156:	9a 81       	ldd	r25, Y+2	; 0x02
    4158:	08 96       	adiw	r24, 0x08	; 8
    415a:	0e 94 52 2a 	call	0x54a4	; 0x54a4 <xTaskRemoveFromEventList>
    415e:	81 30       	cpi	r24, 0x01	; 1
    4160:	b9 f4       	brne	.+46     	; 0x4190 <xQueueGenericReceive+0xb2>
						{
							queueYIELD_IF_USING_PREEMPTION();
    4162:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <vPortYield>
    4166:	14 c0       	rjmp	.+40     	; 0x4190 <xQueueGenericReceive+0xb2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    4168:	e9 81       	ldd	r30, Y+1	; 0x01
    416a:	fa 81       	ldd	r31, Y+2	; 0x02
    416c:	8b 81       	ldd	r24, Y+3	; 0x03
    416e:	9c 81       	ldd	r25, Y+4	; 0x04
    4170:	97 83       	std	Z+7, r25	; 0x07
    4172:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4174:	e9 81       	ldd	r30, Y+1	; 0x01
    4176:	fa 81       	ldd	r31, Y+2	; 0x02
    4178:	81 89       	ldd	r24, Z+17	; 0x11
    417a:	88 23       	and	r24, r24
    417c:	49 f0       	breq	.+18     	; 0x4190 <xQueueGenericReceive+0xb2>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    417e:	89 81       	ldd	r24, Y+1	; 0x01
    4180:	9a 81       	ldd	r25, Y+2	; 0x02
    4182:	41 96       	adiw	r24, 0x11	; 17
    4184:	0e 94 52 2a 	call	0x54a4	; 0x54a4 <xTaskRemoveFromEventList>
    4188:	88 23       	and	r24, r24
    418a:	11 f0       	breq	.+4      	; 0x4190 <xQueueGenericReceive+0xb2>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    418c:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    4190:	0f 90       	pop	r0
    4192:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    4194:	81 e0       	ldi	r24, 0x01	; 1
    4196:	88 8b       	std	Y+16, r24	; 0x10
    4198:	5c c0       	rjmp	.+184    	; 0x4252 <xQueueGenericReceive+0x174>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    419a:	8d 85       	ldd	r24, Y+13	; 0x0d
    419c:	9e 85       	ldd	r25, Y+14	; 0x0e
    419e:	00 97       	sbiw	r24, 0x00	; 0
    41a0:	21 f4       	brne	.+8      	; 0x41aa <xQueueGenericReceive+0xcc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    41a2:	0f 90       	pop	r0
    41a4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    41a6:	18 8a       	std	Y+16, r1	; 0x10
    41a8:	54 c0       	rjmp	.+168    	; 0x4252 <xQueueGenericReceive+0x174>
				}
				else if( xEntryTimeSet == pdFALSE )
    41aa:	8d 81       	ldd	r24, Y+5	; 0x05
    41ac:	88 23       	and	r24, r24
    41ae:	31 f4       	brne	.+12     	; 0x41bc <xQueueGenericReceive+0xde>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    41b0:	ce 01       	movw	r24, r28
    41b2:	06 96       	adiw	r24, 0x06	; 6
    41b4:	0e 94 22 2b 	call	0x5644	; 0x5644 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    41b8:	81 e0       	ldi	r24, 0x01	; 1
    41ba:	8d 83       	std	Y+5, r24	; 0x05
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    41bc:	0f 90       	pop	r0
    41be:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    41c0:	0e 94 bf 27 	call	0x4f7e	; 0x4f7e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    41c4:	0f b6       	in	r0, 0x3f	; 63
    41c6:	f8 94       	cli
    41c8:	0f 92       	push	r0
    41ca:	e9 81       	ldd	r30, Y+1	; 0x01
    41cc:	fa 81       	ldd	r31, Y+2	; 0x02
    41ce:	85 8d       	ldd	r24, Z+29	; 0x1d
    41d0:	8f 3f       	cpi	r24, 0xFF	; 255
    41d2:	19 f4       	brne	.+6      	; 0x41da <xQueueGenericReceive+0xfc>
    41d4:	e9 81       	ldd	r30, Y+1	; 0x01
    41d6:	fa 81       	ldd	r31, Y+2	; 0x02
    41d8:	15 8e       	std	Z+29, r1	; 0x1d
    41da:	e9 81       	ldd	r30, Y+1	; 0x01
    41dc:	fa 81       	ldd	r31, Y+2	; 0x02
    41de:	86 8d       	ldd	r24, Z+30	; 0x1e
    41e0:	8f 3f       	cpi	r24, 0xFF	; 255
    41e2:	19 f4       	brne	.+6      	; 0x41ea <xQueueGenericReceive+0x10c>
    41e4:	e9 81       	ldd	r30, Y+1	; 0x01
    41e6:	fa 81       	ldd	r31, Y+2	; 0x02
    41e8:	16 8e       	std	Z+30, r1	; 0x1e
    41ea:	0f 90       	pop	r0
    41ec:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    41ee:	ce 01       	movw	r24, r28
    41f0:	06 96       	adiw	r24, 0x06	; 6
    41f2:	9e 01       	movw	r18, r28
    41f4:	23 5f       	subi	r18, 0xF3	; 243
    41f6:	3f 4f       	sbci	r19, 0xFF	; 255
    41f8:	b9 01       	movw	r22, r18
    41fa:	0e 94 3b 2b 	call	0x5676	; 0x5676 <xTaskCheckForTimeOut>
    41fe:	88 23       	and	r24, r24
    4200:	09 f5       	brne	.+66     	; 0x4244 <xQueueGenericReceive+0x166>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4202:	89 81       	ldd	r24, Y+1	; 0x01
    4204:	9a 81       	ldd	r25, Y+2	; 0x02
    4206:	0e 94 78 23 	call	0x46f0	; 0x46f0 <prvIsQueueEmpty>
    420a:	88 23       	and	r24, r24
    420c:	a1 f0       	breq	.+40     	; 0x4236 <xQueueGenericReceive+0x158>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    420e:	89 81       	ldd	r24, Y+1	; 0x01
    4210:	9a 81       	ldd	r25, Y+2	; 0x02
    4212:	41 96       	adiw	r24, 0x11	; 17
    4214:	2d 85       	ldd	r18, Y+13	; 0x0d
    4216:	3e 85       	ldd	r19, Y+14	; 0x0e
    4218:	b9 01       	movw	r22, r18
    421a:	0e 94 da 29 	call	0x53b4	; 0x53b4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    421e:	89 81       	ldd	r24, Y+1	; 0x01
    4220:	9a 81       	ldd	r25, Y+2	; 0x02
    4222:	0e 94 24 23 	call	0x4648	; 0x4648 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    4226:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <xTaskResumeAll>
    422a:	88 23       	and	r24, r24
    422c:	09 f0       	breq	.+2      	; 0x4230 <xQueueGenericReceive+0x152>
    422e:	6d cf       	rjmp	.-294    	; 0x410a <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    4230:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <vPortYield>
    4234:	6a cf       	rjmp	.-300    	; 0x410a <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    4236:	89 81       	ldd	r24, Y+1	; 0x01
    4238:	9a 81       	ldd	r25, Y+2	; 0x02
    423a:	0e 94 24 23 	call	0x4648	; 0x4648 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    423e:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <xTaskResumeAll>
    4242:	63 cf       	rjmp	.-314    	; 0x410a <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    4244:	89 81       	ldd	r24, Y+1	; 0x01
    4246:	9a 81       	ldd	r25, Y+2	; 0x02
    4248:	0e 94 24 23 	call	0x4648	; 0x4648 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    424c:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    4250:	18 8a       	std	Y+16, r1	; 0x10
    4252:	88 89       	ldd	r24, Y+16	; 0x10
		}
	}
}
    4254:	60 96       	adiw	r28, 0x10	; 16
    4256:	0f b6       	in	r0, 0x3f	; 63
    4258:	f8 94       	cli
    425a:	de bf       	out	0x3e, r29	; 62
    425c:	0f be       	out	0x3f, r0	; 63
    425e:	cd bf       	out	0x3d, r28	; 61
    4260:	cf 91       	pop	r28
    4262:	df 91       	pop	r29
    4264:	08 95       	ret

00004266 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    4266:	df 93       	push	r29
    4268:	cf 93       	push	r28
    426a:	cd b7       	in	r28, 0x3d	; 61
    426c:	de b7       	in	r29, 0x3e	; 62
    426e:	2a 97       	sbiw	r28, 0x0a	; 10
    4270:	0f b6       	in	r0, 0x3f	; 63
    4272:	f8 94       	cli
    4274:	de bf       	out	0x3e, r29	; 62
    4276:	0f be       	out	0x3f, r0	; 63
    4278:	cd bf       	out	0x3d, r28	; 61
    427a:	9e 83       	std	Y+6, r25	; 0x06
    427c:	8d 83       	std	Y+5, r24	; 0x05
    427e:	78 87       	std	Y+8, r23	; 0x08
    4280:	6f 83       	std	Y+7, r22	; 0x07
    4282:	5a 87       	std	Y+10, r21	; 0x0a
    4284:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4286:	8d 81       	ldd	r24, Y+5	; 0x05
    4288:	9e 81       	ldd	r25, Y+6	; 0x06
    428a:	9a 83       	std	Y+2, r25	; 0x02
    428c:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    428e:	1b 82       	std	Y+3, r1	; 0x03
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    4290:	e9 81       	ldd	r30, Y+1	; 0x01
    4292:	fa 81       	ldd	r31, Y+2	; 0x02
    4294:	82 8d       	ldd	r24, Z+26	; 0x1a
    4296:	88 23       	and	r24, r24
    4298:	91 f1       	breq	.+100    	; 0x42fe <xQueueReceiveFromISR+0x98>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    429a:	89 81       	ldd	r24, Y+1	; 0x01
    429c:	9a 81       	ldd	r25, Y+2	; 0x02
    429e:	2f 81       	ldd	r18, Y+7	; 0x07
    42a0:	38 85       	ldd	r19, Y+8	; 0x08
    42a2:	b9 01       	movw	r22, r18
    42a4:	0e 94 dd 22 	call	0x45ba	; 0x45ba <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    42a8:	e9 81       	ldd	r30, Y+1	; 0x01
    42aa:	fa 81       	ldd	r31, Y+2	; 0x02
    42ac:	82 8d       	ldd	r24, Z+26	; 0x1a
    42ae:	81 50       	subi	r24, 0x01	; 1
    42b0:	e9 81       	ldd	r30, Y+1	; 0x01
    42b2:	fa 81       	ldd	r31, Y+2	; 0x02
    42b4:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    42b6:	e9 81       	ldd	r30, Y+1	; 0x01
    42b8:	fa 81       	ldd	r31, Y+2	; 0x02
    42ba:	85 8d       	ldd	r24, Z+29	; 0x1d
    42bc:	8f 3f       	cpi	r24, 0xFF	; 255
    42be:	a9 f4       	brne	.+42     	; 0x42ea <xQueueReceiveFromISR+0x84>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    42c0:	e9 81       	ldd	r30, Y+1	; 0x01
    42c2:	fa 81       	ldd	r31, Y+2	; 0x02
    42c4:	80 85       	ldd	r24, Z+8	; 0x08
    42c6:	88 23       	and	r24, r24
    42c8:	b9 f0       	breq	.+46     	; 0x42f8 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    42ca:	89 81       	ldd	r24, Y+1	; 0x01
    42cc:	9a 81       	ldd	r25, Y+2	; 0x02
    42ce:	08 96       	adiw	r24, 0x08	; 8
    42d0:	0e 94 52 2a 	call	0x54a4	; 0x54a4 <xTaskRemoveFromEventList>
    42d4:	88 23       	and	r24, r24
    42d6:	81 f0       	breq	.+32     	; 0x42f8 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    42d8:	89 85       	ldd	r24, Y+9	; 0x09
    42da:	9a 85       	ldd	r25, Y+10	; 0x0a
    42dc:	00 97       	sbiw	r24, 0x00	; 0
    42de:	61 f0       	breq	.+24     	; 0x42f8 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    42e0:	e9 85       	ldd	r30, Y+9	; 0x09
    42e2:	fa 85       	ldd	r31, Y+10	; 0x0a
    42e4:	81 e0       	ldi	r24, 0x01	; 1
    42e6:	80 83       	st	Z, r24
    42e8:	07 c0       	rjmp	.+14     	; 0x42f8 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    42ea:	e9 81       	ldd	r30, Y+1	; 0x01
    42ec:	fa 81       	ldd	r31, Y+2	; 0x02
    42ee:	85 8d       	ldd	r24, Z+29	; 0x1d
    42f0:	8f 5f       	subi	r24, 0xFF	; 255
    42f2:	e9 81       	ldd	r30, Y+1	; 0x01
    42f4:	fa 81       	ldd	r31, Y+2	; 0x02
    42f6:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    42f8:	81 e0       	ldi	r24, 0x01	; 1
    42fa:	8c 83       	std	Y+4, r24	; 0x04
    42fc:	01 c0       	rjmp	.+2      	; 0x4300 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    42fe:	1c 82       	std	Y+4, r1	; 0x04
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4300:	8c 81       	ldd	r24, Y+4	; 0x04
}
    4302:	2a 96       	adiw	r28, 0x0a	; 10
    4304:	0f b6       	in	r0, 0x3f	; 63
    4306:	f8 94       	cli
    4308:	de bf       	out	0x3e, r29	; 62
    430a:	0f be       	out	0x3f, r0	; 63
    430c:	cd bf       	out	0x3d, r28	; 61
    430e:	cf 91       	pop	r28
    4310:	df 91       	pop	r29
    4312:	08 95       	ret

00004314 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    4314:	df 93       	push	r29
    4316:	cf 93       	push	r28
    4318:	cd b7       	in	r28, 0x3d	; 61
    431a:	de b7       	in	r29, 0x3e	; 62
    431c:	2a 97       	sbiw	r28, 0x0a	; 10
    431e:	0f b6       	in	r0, 0x3f	; 63
    4320:	f8 94       	cli
    4322:	de bf       	out	0x3e, r29	; 62
    4324:	0f be       	out	0x3f, r0	; 63
    4326:	cd bf       	out	0x3d, r28	; 61
    4328:	98 87       	std	Y+8, r25	; 0x08
    432a:	8f 83       	std	Y+7, r24	; 0x07
    432c:	7a 87       	std	Y+10, r23	; 0x0a
    432e:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4330:	8f 81       	ldd	r24, Y+7	; 0x07
    4332:	98 85       	ldd	r25, Y+8	; 0x08
    4334:	9a 83       	std	Y+2, r25	; 0x02
    4336:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4338:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    433a:	e9 81       	ldd	r30, Y+1	; 0x01
    433c:	fa 81       	ldd	r31, Y+2	; 0x02
    433e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4340:	88 23       	and	r24, r24
    4342:	b1 f0       	breq	.+44     	; 0x4370 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    4344:	e9 81       	ldd	r30, Y+1	; 0x01
    4346:	fa 81       	ldd	r31, Y+2	; 0x02
    4348:	86 81       	ldd	r24, Z+6	; 0x06
    434a:	97 81       	ldd	r25, Z+7	; 0x07
    434c:	9c 83       	std	Y+4, r25	; 0x04
    434e:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    4350:	89 81       	ldd	r24, Y+1	; 0x01
    4352:	9a 81       	ldd	r25, Y+2	; 0x02
    4354:	29 85       	ldd	r18, Y+9	; 0x09
    4356:	3a 85       	ldd	r19, Y+10	; 0x0a
    4358:	b9 01       	movw	r22, r18
    435a:	0e 94 dd 22 	call	0x45ba	; 0x45ba <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    435e:	e9 81       	ldd	r30, Y+1	; 0x01
    4360:	fa 81       	ldd	r31, Y+2	; 0x02
    4362:	8b 81       	ldd	r24, Y+3	; 0x03
    4364:	9c 81       	ldd	r25, Y+4	; 0x04
    4366:	97 83       	std	Z+7, r25	; 0x07
    4368:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    436a:	81 e0       	ldi	r24, 0x01	; 1
    436c:	8e 83       	std	Y+6, r24	; 0x06
    436e:	01 c0       	rjmp	.+2      	; 0x4372 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    4370:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4372:	8e 81       	ldd	r24, Y+6	; 0x06
}
    4374:	2a 96       	adiw	r28, 0x0a	; 10
    4376:	0f b6       	in	r0, 0x3f	; 63
    4378:	f8 94       	cli
    437a:	de bf       	out	0x3e, r29	; 62
    437c:	0f be       	out	0x3f, r0	; 63
    437e:	cd bf       	out	0x3d, r28	; 61
    4380:	cf 91       	pop	r28
    4382:	df 91       	pop	r29
    4384:	08 95       	ret

00004386 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    4386:	df 93       	push	r29
    4388:	cf 93       	push	r28
    438a:	00 d0       	rcall	.+0      	; 0x438c <uxQueueMessagesWaiting+0x6>
    438c:	0f 92       	push	r0
    438e:	cd b7       	in	r28, 0x3d	; 61
    4390:	de b7       	in	r29, 0x3e	; 62
    4392:	9b 83       	std	Y+3, r25	; 0x03
    4394:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    4396:	0f b6       	in	r0, 0x3f	; 63
    4398:	f8 94       	cli
    439a:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    439c:	ea 81       	ldd	r30, Y+2	; 0x02
    439e:	fb 81       	ldd	r31, Y+3	; 0x03
    43a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    43a2:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    43a4:	0f 90       	pop	r0
    43a6:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    43a8:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    43aa:	0f 90       	pop	r0
    43ac:	0f 90       	pop	r0
    43ae:	0f 90       	pop	r0
    43b0:	cf 91       	pop	r28
    43b2:	df 91       	pop	r29
    43b4:	08 95       	ret

000043b6 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    43b6:	df 93       	push	r29
    43b8:	cf 93       	push	r28
    43ba:	00 d0       	rcall	.+0      	; 0x43bc <uxQueueSpacesAvailable+0x6>
    43bc:	00 d0       	rcall	.+0      	; 0x43be <uxQueueSpacesAvailable+0x8>
    43be:	0f 92       	push	r0
    43c0:	cd b7       	in	r28, 0x3d	; 61
    43c2:	de b7       	in	r29, 0x3e	; 62
    43c4:	9d 83       	std	Y+5, r25	; 0x05
    43c6:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    43c8:	8c 81       	ldd	r24, Y+4	; 0x04
    43ca:	9d 81       	ldd	r25, Y+5	; 0x05
    43cc:	9a 83       	std	Y+2, r25	; 0x02
    43ce:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    43d0:	0f b6       	in	r0, 0x3f	; 63
    43d2:	f8 94       	cli
    43d4:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    43d6:	e9 81       	ldd	r30, Y+1	; 0x01
    43d8:	fa 81       	ldd	r31, Y+2	; 0x02
    43da:	93 8d       	ldd	r25, Z+27	; 0x1b
    43dc:	e9 81       	ldd	r30, Y+1	; 0x01
    43de:	fa 81       	ldd	r31, Y+2	; 0x02
    43e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    43e2:	29 2f       	mov	r18, r25
    43e4:	28 1b       	sub	r18, r24
    43e6:	82 2f       	mov	r24, r18
    43e8:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    43ea:	0f 90       	pop	r0
    43ec:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    43ee:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    43f0:	0f 90       	pop	r0
    43f2:	0f 90       	pop	r0
    43f4:	0f 90       	pop	r0
    43f6:	0f 90       	pop	r0
    43f8:	0f 90       	pop	r0
    43fa:	cf 91       	pop	r28
    43fc:	df 91       	pop	r29
    43fe:	08 95       	ret

00004400 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    4400:	df 93       	push	r29
    4402:	cf 93       	push	r28
    4404:	00 d0       	rcall	.+0      	; 0x4406 <uxQueueMessagesWaitingFromISR+0x6>
    4406:	0f 92       	push	r0
    4408:	cd b7       	in	r28, 0x3d	; 61
    440a:	de b7       	in	r29, 0x3e	; 62
    440c:	9b 83       	std	Y+3, r25	; 0x03
    440e:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    4410:	ea 81       	ldd	r30, Y+2	; 0x02
    4412:	fb 81       	ldd	r31, Y+3	; 0x03
    4414:	82 8d       	ldd	r24, Z+26	; 0x1a
    4416:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    4418:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    441a:	0f 90       	pop	r0
    441c:	0f 90       	pop	r0
    441e:	0f 90       	pop	r0
    4420:	cf 91       	pop	r28
    4422:	df 91       	pop	r29
    4424:	08 95       	ret

00004426 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    4426:	df 93       	push	r29
    4428:	cf 93       	push	r28
    442a:	00 d0       	rcall	.+0      	; 0x442c <vQueueDelete+0x6>
    442c:	00 d0       	rcall	.+0      	; 0x442e <vQueueDelete+0x8>
    442e:	cd b7       	in	r28, 0x3d	; 61
    4430:	de b7       	in	r29, 0x3e	; 62
    4432:	9c 83       	std	Y+4, r25	; 0x04
    4434:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4436:	8b 81       	ldd	r24, Y+3	; 0x03
    4438:	9c 81       	ldd	r25, Y+4	; 0x04
    443a:	9a 83       	std	Y+2, r25	; 0x02
    443c:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	if( pxQueue->pcHead != NULL )
    443e:	e9 81       	ldd	r30, Y+1	; 0x01
    4440:	fa 81       	ldd	r31, Y+2	; 0x02
    4442:	80 81       	ld	r24, Z
    4444:	91 81       	ldd	r25, Z+1	; 0x01
    4446:	00 97       	sbiw	r24, 0x00	; 0
    4448:	31 f0       	breq	.+12     	; 0x4456 <vQueueDelete+0x30>
	{
		vPortFree( pxQueue->pcHead );
    444a:	e9 81       	ldd	r30, Y+1	; 0x01
    444c:	fa 81       	ldd	r31, Y+2	; 0x02
    444e:	80 81       	ld	r24, Z
    4450:	91 81       	ldd	r25, Z+1	; 0x01
    4452:	0e 94 5c 19 	call	0x32b8	; 0x32b8 <vPortFree>
	}
	vPortFree( pxQueue );
    4456:	89 81       	ldd	r24, Y+1	; 0x01
    4458:	9a 81       	ldd	r25, Y+2	; 0x02
    445a:	0e 94 5c 19 	call	0x32b8	; 0x32b8 <vPortFree>
}
    445e:	0f 90       	pop	r0
    4460:	0f 90       	pop	r0
    4462:	0f 90       	pop	r0
    4464:	0f 90       	pop	r0
    4466:	cf 91       	pop	r28
    4468:	df 91       	pop	r29
    446a:	08 95       	ret

0000446c <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    446c:	df 93       	push	r29
    446e:	cf 93       	push	r28
    4470:	00 d0       	rcall	.+0      	; 0x4472 <prvCopyDataToQueue+0x6>
    4472:	00 d0       	rcall	.+0      	; 0x4474 <prvCopyDataToQueue+0x8>
    4474:	00 d0       	rcall	.+0      	; 0x4476 <prvCopyDataToQueue+0xa>
    4476:	cd b7       	in	r28, 0x3d	; 61
    4478:	de b7       	in	r29, 0x3e	; 62
    447a:	9b 83       	std	Y+3, r25	; 0x03
    447c:	8a 83       	std	Y+2, r24	; 0x02
    447e:	7d 83       	std	Y+5, r23	; 0x05
    4480:	6c 83       	std	Y+4, r22	; 0x04
    4482:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    4484:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    4486:	ea 81       	ldd	r30, Y+2	; 0x02
    4488:	fb 81       	ldd	r31, Y+3	; 0x03
    448a:	84 8d       	ldd	r24, Z+28	; 0x1c
    448c:	88 23       	and	r24, r24
    448e:	09 f4       	brne	.+2      	; 0x4492 <prvCopyDataToQueue+0x26>
    4490:	83 c0       	rjmp	.+262    	; 0x4598 <prvCopyDataToQueue+0x12c>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    4492:	8e 81       	ldd	r24, Y+6	; 0x06
    4494:	88 23       	and	r24, r24
    4496:	99 f5       	brne	.+102    	; 0x44fe <prvCopyDataToQueue+0x92>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    4498:	ea 81       	ldd	r30, Y+2	; 0x02
    449a:	fb 81       	ldd	r31, Y+3	; 0x03
    449c:	64 81       	ldd	r22, Z+4	; 0x04
    449e:	75 81       	ldd	r23, Z+5	; 0x05
    44a0:	ea 81       	ldd	r30, Y+2	; 0x02
    44a2:	fb 81       	ldd	r31, Y+3	; 0x03
    44a4:	84 8d       	ldd	r24, Z+28	; 0x1c
    44a6:	48 2f       	mov	r20, r24
    44a8:	50 e0       	ldi	r21, 0x00	; 0
    44aa:	2c 81       	ldd	r18, Y+4	; 0x04
    44ac:	3d 81       	ldd	r19, Y+5	; 0x05
    44ae:	cb 01       	movw	r24, r22
    44b0:	b9 01       	movw	r22, r18
    44b2:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    44b6:	ea 81       	ldd	r30, Y+2	; 0x02
    44b8:	fb 81       	ldd	r31, Y+3	; 0x03
    44ba:	24 81       	ldd	r18, Z+4	; 0x04
    44bc:	35 81       	ldd	r19, Z+5	; 0x05
    44be:	ea 81       	ldd	r30, Y+2	; 0x02
    44c0:	fb 81       	ldd	r31, Y+3	; 0x03
    44c2:	84 8d       	ldd	r24, Z+28	; 0x1c
    44c4:	88 2f       	mov	r24, r24
    44c6:	90 e0       	ldi	r25, 0x00	; 0
    44c8:	82 0f       	add	r24, r18
    44ca:	93 1f       	adc	r25, r19
    44cc:	ea 81       	ldd	r30, Y+2	; 0x02
    44ce:	fb 81       	ldd	r31, Y+3	; 0x03
    44d0:	95 83       	std	Z+5, r25	; 0x05
    44d2:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    44d4:	ea 81       	ldd	r30, Y+2	; 0x02
    44d6:	fb 81       	ldd	r31, Y+3	; 0x03
    44d8:	24 81       	ldd	r18, Z+4	; 0x04
    44da:	35 81       	ldd	r19, Z+5	; 0x05
    44dc:	ea 81       	ldd	r30, Y+2	; 0x02
    44de:	fb 81       	ldd	r31, Y+3	; 0x03
    44e0:	82 81       	ldd	r24, Z+2	; 0x02
    44e2:	93 81       	ldd	r25, Z+3	; 0x03
    44e4:	28 17       	cp	r18, r24
    44e6:	39 07       	cpc	r19, r25
    44e8:	08 f4       	brcc	.+2      	; 0x44ec <prvCopyDataToQueue+0x80>
    44ea:	56 c0       	rjmp	.+172    	; 0x4598 <prvCopyDataToQueue+0x12c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    44ec:	ea 81       	ldd	r30, Y+2	; 0x02
    44ee:	fb 81       	ldd	r31, Y+3	; 0x03
    44f0:	80 81       	ld	r24, Z
    44f2:	91 81       	ldd	r25, Z+1	; 0x01
    44f4:	ea 81       	ldd	r30, Y+2	; 0x02
    44f6:	fb 81       	ldd	r31, Y+3	; 0x03
    44f8:	95 83       	std	Z+5, r25	; 0x05
    44fa:	84 83       	std	Z+4, r24	; 0x04
    44fc:	4d c0       	rjmp	.+154    	; 0x4598 <prvCopyDataToQueue+0x12c>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    44fe:	ea 81       	ldd	r30, Y+2	; 0x02
    4500:	fb 81       	ldd	r31, Y+3	; 0x03
    4502:	66 81       	ldd	r22, Z+6	; 0x06
    4504:	77 81       	ldd	r23, Z+7	; 0x07
    4506:	ea 81       	ldd	r30, Y+2	; 0x02
    4508:	fb 81       	ldd	r31, Y+3	; 0x03
    450a:	84 8d       	ldd	r24, Z+28	; 0x1c
    450c:	48 2f       	mov	r20, r24
    450e:	50 e0       	ldi	r21, 0x00	; 0
    4510:	2c 81       	ldd	r18, Y+4	; 0x04
    4512:	3d 81       	ldd	r19, Y+5	; 0x05
    4514:	cb 01       	movw	r24, r22
    4516:	b9 01       	movw	r22, r18
    4518:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    451c:	ea 81       	ldd	r30, Y+2	; 0x02
    451e:	fb 81       	ldd	r31, Y+3	; 0x03
    4520:	26 81       	ldd	r18, Z+6	; 0x06
    4522:	37 81       	ldd	r19, Z+7	; 0x07
    4524:	ea 81       	ldd	r30, Y+2	; 0x02
    4526:	fb 81       	ldd	r31, Y+3	; 0x03
    4528:	84 8d       	ldd	r24, Z+28	; 0x1c
    452a:	88 2f       	mov	r24, r24
    452c:	90 e0       	ldi	r25, 0x00	; 0
    452e:	90 95       	com	r25
    4530:	81 95       	neg	r24
    4532:	9f 4f       	sbci	r25, 0xFF	; 255
    4534:	82 0f       	add	r24, r18
    4536:	93 1f       	adc	r25, r19
    4538:	ea 81       	ldd	r30, Y+2	; 0x02
    453a:	fb 81       	ldd	r31, Y+3	; 0x03
    453c:	97 83       	std	Z+7, r25	; 0x07
    453e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    4540:	ea 81       	ldd	r30, Y+2	; 0x02
    4542:	fb 81       	ldd	r31, Y+3	; 0x03
    4544:	26 81       	ldd	r18, Z+6	; 0x06
    4546:	37 81       	ldd	r19, Z+7	; 0x07
    4548:	ea 81       	ldd	r30, Y+2	; 0x02
    454a:	fb 81       	ldd	r31, Y+3	; 0x03
    454c:	80 81       	ld	r24, Z
    454e:	91 81       	ldd	r25, Z+1	; 0x01
    4550:	28 17       	cp	r18, r24
    4552:	39 07       	cpc	r19, r25
    4554:	90 f4       	brcc	.+36     	; 0x457a <prvCopyDataToQueue+0x10e>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    4556:	ea 81       	ldd	r30, Y+2	; 0x02
    4558:	fb 81       	ldd	r31, Y+3	; 0x03
    455a:	22 81       	ldd	r18, Z+2	; 0x02
    455c:	33 81       	ldd	r19, Z+3	; 0x03
    455e:	ea 81       	ldd	r30, Y+2	; 0x02
    4560:	fb 81       	ldd	r31, Y+3	; 0x03
    4562:	84 8d       	ldd	r24, Z+28	; 0x1c
    4564:	88 2f       	mov	r24, r24
    4566:	90 e0       	ldi	r25, 0x00	; 0
    4568:	90 95       	com	r25
    456a:	81 95       	neg	r24
    456c:	9f 4f       	sbci	r25, 0xFF	; 255
    456e:	82 0f       	add	r24, r18
    4570:	93 1f       	adc	r25, r19
    4572:	ea 81       	ldd	r30, Y+2	; 0x02
    4574:	fb 81       	ldd	r31, Y+3	; 0x03
    4576:	97 83       	std	Z+7, r25	; 0x07
    4578:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    457a:	8e 81       	ldd	r24, Y+6	; 0x06
    457c:	82 30       	cpi	r24, 0x02	; 2
    457e:	61 f4       	brne	.+24     	; 0x4598 <prvCopyDataToQueue+0x12c>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    4580:	ea 81       	ldd	r30, Y+2	; 0x02
    4582:	fb 81       	ldd	r31, Y+3	; 0x03
    4584:	82 8d       	ldd	r24, Z+26	; 0x1a
    4586:	88 23       	and	r24, r24
    4588:	39 f0       	breq	.+14     	; 0x4598 <prvCopyDataToQueue+0x12c>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    458a:	ea 81       	ldd	r30, Y+2	; 0x02
    458c:	fb 81       	ldd	r31, Y+3	; 0x03
    458e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4590:	81 50       	subi	r24, 0x01	; 1
    4592:	ea 81       	ldd	r30, Y+2	; 0x02
    4594:	fb 81       	ldd	r31, Y+3	; 0x03
    4596:	82 8f       	std	Z+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    4598:	ea 81       	ldd	r30, Y+2	; 0x02
    459a:	fb 81       	ldd	r31, Y+3	; 0x03
    459c:	82 8d       	ldd	r24, Z+26	; 0x1a
    459e:	8f 5f       	subi	r24, 0xFF	; 255
    45a0:	ea 81       	ldd	r30, Y+2	; 0x02
    45a2:	fb 81       	ldd	r31, Y+3	; 0x03
    45a4:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    45a6:	89 81       	ldd	r24, Y+1	; 0x01
}
    45a8:	26 96       	adiw	r28, 0x06	; 6
    45aa:	0f b6       	in	r0, 0x3f	; 63
    45ac:	f8 94       	cli
    45ae:	de bf       	out	0x3e, r29	; 62
    45b0:	0f be       	out	0x3f, r0	; 63
    45b2:	cd bf       	out	0x3d, r28	; 61
    45b4:	cf 91       	pop	r28
    45b6:	df 91       	pop	r29
    45b8:	08 95       	ret

000045ba <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    45ba:	df 93       	push	r29
    45bc:	cf 93       	push	r28
    45be:	00 d0       	rcall	.+0      	; 0x45c0 <prvCopyDataFromQueue+0x6>
    45c0:	00 d0       	rcall	.+0      	; 0x45c2 <prvCopyDataFromQueue+0x8>
    45c2:	cd b7       	in	r28, 0x3d	; 61
    45c4:	de b7       	in	r29, 0x3e	; 62
    45c6:	9a 83       	std	Y+2, r25	; 0x02
    45c8:	89 83       	std	Y+1, r24	; 0x01
    45ca:	7c 83       	std	Y+4, r23	; 0x04
    45cc:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    45ce:	e9 81       	ldd	r30, Y+1	; 0x01
    45d0:	fa 81       	ldd	r31, Y+2	; 0x02
    45d2:	84 8d       	ldd	r24, Z+28	; 0x1c
    45d4:	88 23       	and	r24, r24
    45d6:	89 f1       	breq	.+98     	; 0x463a <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    45d8:	e9 81       	ldd	r30, Y+1	; 0x01
    45da:	fa 81       	ldd	r31, Y+2	; 0x02
    45dc:	26 81       	ldd	r18, Z+6	; 0x06
    45de:	37 81       	ldd	r19, Z+7	; 0x07
    45e0:	e9 81       	ldd	r30, Y+1	; 0x01
    45e2:	fa 81       	ldd	r31, Y+2	; 0x02
    45e4:	84 8d       	ldd	r24, Z+28	; 0x1c
    45e6:	88 2f       	mov	r24, r24
    45e8:	90 e0       	ldi	r25, 0x00	; 0
    45ea:	82 0f       	add	r24, r18
    45ec:	93 1f       	adc	r25, r19
    45ee:	e9 81       	ldd	r30, Y+1	; 0x01
    45f0:	fa 81       	ldd	r31, Y+2	; 0x02
    45f2:	97 83       	std	Z+7, r25	; 0x07
    45f4:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    45f6:	e9 81       	ldd	r30, Y+1	; 0x01
    45f8:	fa 81       	ldd	r31, Y+2	; 0x02
    45fa:	26 81       	ldd	r18, Z+6	; 0x06
    45fc:	37 81       	ldd	r19, Z+7	; 0x07
    45fe:	e9 81       	ldd	r30, Y+1	; 0x01
    4600:	fa 81       	ldd	r31, Y+2	; 0x02
    4602:	82 81       	ldd	r24, Z+2	; 0x02
    4604:	93 81       	ldd	r25, Z+3	; 0x03
    4606:	28 17       	cp	r18, r24
    4608:	39 07       	cpc	r19, r25
    460a:	40 f0       	brcs	.+16     	; 0x461c <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    460c:	e9 81       	ldd	r30, Y+1	; 0x01
    460e:	fa 81       	ldd	r31, Y+2	; 0x02
    4610:	80 81       	ld	r24, Z
    4612:	91 81       	ldd	r25, Z+1	; 0x01
    4614:	e9 81       	ldd	r30, Y+1	; 0x01
    4616:	fa 81       	ldd	r31, Y+2	; 0x02
    4618:	97 83       	std	Z+7, r25	; 0x07
    461a:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    461c:	e9 81       	ldd	r30, Y+1	; 0x01
    461e:	fa 81       	ldd	r31, Y+2	; 0x02
    4620:	46 81       	ldd	r20, Z+6	; 0x06
    4622:	57 81       	ldd	r21, Z+7	; 0x07
    4624:	e9 81       	ldd	r30, Y+1	; 0x01
    4626:	fa 81       	ldd	r31, Y+2	; 0x02
    4628:	84 8d       	ldd	r24, Z+28	; 0x1c
    462a:	28 2f       	mov	r18, r24
    462c:	30 e0       	ldi	r19, 0x00	; 0
    462e:	8b 81       	ldd	r24, Y+3	; 0x03
    4630:	9c 81       	ldd	r25, Y+4	; 0x04
    4632:	ba 01       	movw	r22, r20
    4634:	a9 01       	movw	r20, r18
    4636:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <memcpy>
	}
}
    463a:	0f 90       	pop	r0
    463c:	0f 90       	pop	r0
    463e:	0f 90       	pop	r0
    4640:	0f 90       	pop	r0
    4642:	cf 91       	pop	r28
    4644:	df 91       	pop	r29
    4646:	08 95       	ret

00004648 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    4648:	df 93       	push	r29
    464a:	cf 93       	push	r28
    464c:	00 d0       	rcall	.+0      	; 0x464e <prvUnlockQueue+0x6>
    464e:	cd b7       	in	r28, 0x3d	; 61
    4650:	de b7       	in	r29, 0x3e	; 62
    4652:	9a 83       	std	Y+2, r25	; 0x02
    4654:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    4656:	0f b6       	in	r0, 0x3f	; 63
    4658:	f8 94       	cli
    465a:	0f 92       	push	r0
    465c:	15 c0       	rjmp	.+42     	; 0x4688 <prvUnlockQueue+0x40>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    465e:	e9 81       	ldd	r30, Y+1	; 0x01
    4660:	fa 81       	ldd	r31, Y+2	; 0x02
    4662:	81 89       	ldd	r24, Z+17	; 0x11
    4664:	88 23       	and	r24, r24
    4666:	a9 f0       	breq	.+42     	; 0x4692 <prvUnlockQueue+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4668:	89 81       	ldd	r24, Y+1	; 0x01
    466a:	9a 81       	ldd	r25, Y+2	; 0x02
    466c:	41 96       	adiw	r24, 0x11	; 17
    466e:	0e 94 52 2a 	call	0x54a4	; 0x54a4 <xTaskRemoveFromEventList>
    4672:	88 23       	and	r24, r24
    4674:	11 f0       	breq	.+4      	; 0x467a <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    4676:	0e 94 9e 2b 	call	0x573c	; 0x573c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    467a:	e9 81       	ldd	r30, Y+1	; 0x01
    467c:	fa 81       	ldd	r31, Y+2	; 0x02
    467e:	86 8d       	ldd	r24, Z+30	; 0x1e
    4680:	81 50       	subi	r24, 0x01	; 1
    4682:	e9 81       	ldd	r30, Y+1	; 0x01
    4684:	fa 81       	ldd	r31, Y+2	; 0x02
    4686:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4688:	e9 81       	ldd	r30, Y+1	; 0x01
    468a:	fa 81       	ldd	r31, Y+2	; 0x02
    468c:	86 8d       	ldd	r24, Z+30	; 0x1e
    468e:	18 16       	cp	r1, r24
    4690:	34 f3       	brlt	.-52     	; 0x465e <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4692:	e9 81       	ldd	r30, Y+1	; 0x01
    4694:	fa 81       	ldd	r31, Y+2	; 0x02
    4696:	8f ef       	ldi	r24, 0xFF	; 255
    4698:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    469a:	0f 90       	pop	r0
    469c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    469e:	0f b6       	in	r0, 0x3f	; 63
    46a0:	f8 94       	cli
    46a2:	0f 92       	push	r0
    46a4:	15 c0       	rjmp	.+42     	; 0x46d0 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    46a6:	e9 81       	ldd	r30, Y+1	; 0x01
    46a8:	fa 81       	ldd	r31, Y+2	; 0x02
    46aa:	80 85       	ldd	r24, Z+8	; 0x08
    46ac:	88 23       	and	r24, r24
    46ae:	a9 f0       	breq	.+42     	; 0x46da <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    46b0:	89 81       	ldd	r24, Y+1	; 0x01
    46b2:	9a 81       	ldd	r25, Y+2	; 0x02
    46b4:	08 96       	adiw	r24, 0x08	; 8
    46b6:	0e 94 52 2a 	call	0x54a4	; 0x54a4 <xTaskRemoveFromEventList>
    46ba:	88 23       	and	r24, r24
    46bc:	11 f0       	breq	.+4      	; 0x46c2 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    46be:	0e 94 9e 2b 	call	0x573c	; 0x573c <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    46c2:	e9 81       	ldd	r30, Y+1	; 0x01
    46c4:	fa 81       	ldd	r31, Y+2	; 0x02
    46c6:	85 8d       	ldd	r24, Z+29	; 0x1d
    46c8:	81 50       	subi	r24, 0x01	; 1
    46ca:	e9 81       	ldd	r30, Y+1	; 0x01
    46cc:	fa 81       	ldd	r31, Y+2	; 0x02
    46ce:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    46d0:	e9 81       	ldd	r30, Y+1	; 0x01
    46d2:	fa 81       	ldd	r31, Y+2	; 0x02
    46d4:	85 8d       	ldd	r24, Z+29	; 0x1d
    46d6:	18 16       	cp	r1, r24
    46d8:	34 f3       	brlt	.-52     	; 0x46a6 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    46da:	e9 81       	ldd	r30, Y+1	; 0x01
    46dc:	fa 81       	ldd	r31, Y+2	; 0x02
    46de:	8f ef       	ldi	r24, 0xFF	; 255
    46e0:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    46e2:	0f 90       	pop	r0
    46e4:	0f be       	out	0x3f, r0	; 63
}
    46e6:	0f 90       	pop	r0
    46e8:	0f 90       	pop	r0
    46ea:	cf 91       	pop	r28
    46ec:	df 91       	pop	r29
    46ee:	08 95       	ret

000046f0 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    46f0:	df 93       	push	r29
    46f2:	cf 93       	push	r28
    46f4:	00 d0       	rcall	.+0      	; 0x46f6 <prvIsQueueEmpty+0x6>
    46f6:	0f 92       	push	r0
    46f8:	cd b7       	in	r28, 0x3d	; 61
    46fa:	de b7       	in	r29, 0x3e	; 62
    46fc:	9b 83       	std	Y+3, r25	; 0x03
    46fe:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    4700:	0f b6       	in	r0, 0x3f	; 63
    4702:	f8 94       	cli
    4704:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    4706:	ea 81       	ldd	r30, Y+2	; 0x02
    4708:	fb 81       	ldd	r31, Y+3	; 0x03
    470a:	82 8d       	ldd	r24, Z+26	; 0x1a
    470c:	88 23       	and	r24, r24
    470e:	19 f4       	brne	.+6      	; 0x4716 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    4710:	81 e0       	ldi	r24, 0x01	; 1
    4712:	89 83       	std	Y+1, r24	; 0x01
    4714:	01 c0       	rjmp	.+2      	; 0x4718 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    4716:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4718:	0f 90       	pop	r0
    471a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    471c:	89 81       	ldd	r24, Y+1	; 0x01
}
    471e:	0f 90       	pop	r0
    4720:	0f 90       	pop	r0
    4722:	0f 90       	pop	r0
    4724:	cf 91       	pop	r28
    4726:	df 91       	pop	r29
    4728:	08 95       	ret

0000472a <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    472a:	df 93       	push	r29
    472c:	cf 93       	push	r28
    472e:	00 d0       	rcall	.+0      	; 0x4730 <xQueueIsQueueEmptyFromISR+0x6>
    4730:	0f 92       	push	r0
    4732:	cd b7       	in	r28, 0x3d	; 61
    4734:	de b7       	in	r29, 0x3e	; 62
    4736:	9b 83       	std	Y+3, r25	; 0x03
    4738:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    473a:	ea 81       	ldd	r30, Y+2	; 0x02
    473c:	fb 81       	ldd	r31, Y+3	; 0x03
    473e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4740:	88 23       	and	r24, r24
    4742:	19 f4       	brne	.+6      	; 0x474a <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    4744:	81 e0       	ldi	r24, 0x01	; 1
    4746:	89 83       	std	Y+1, r24	; 0x01
    4748:	01 c0       	rjmp	.+2      	; 0x474c <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    474a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    474c:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    474e:	0f 90       	pop	r0
    4750:	0f 90       	pop	r0
    4752:	0f 90       	pop	r0
    4754:	cf 91       	pop	r28
    4756:	df 91       	pop	r29
    4758:	08 95       	ret

0000475a <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    475a:	df 93       	push	r29
    475c:	cf 93       	push	r28
    475e:	00 d0       	rcall	.+0      	; 0x4760 <prvIsQueueFull+0x6>
    4760:	0f 92       	push	r0
    4762:	cd b7       	in	r28, 0x3d	; 61
    4764:	de b7       	in	r29, 0x3e	; 62
    4766:	9b 83       	std	Y+3, r25	; 0x03
    4768:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    476a:	0f b6       	in	r0, 0x3f	; 63
    476c:	f8 94       	cli
    476e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    4770:	ea 81       	ldd	r30, Y+2	; 0x02
    4772:	fb 81       	ldd	r31, Y+3	; 0x03
    4774:	92 8d       	ldd	r25, Z+26	; 0x1a
    4776:	ea 81       	ldd	r30, Y+2	; 0x02
    4778:	fb 81       	ldd	r31, Y+3	; 0x03
    477a:	83 8d       	ldd	r24, Z+27	; 0x1b
    477c:	98 17       	cp	r25, r24
    477e:	19 f4       	brne	.+6      	; 0x4786 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    4780:	81 e0       	ldi	r24, 0x01	; 1
    4782:	89 83       	std	Y+1, r24	; 0x01
    4784:	01 c0       	rjmp	.+2      	; 0x4788 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    4786:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4788:	0f 90       	pop	r0
    478a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    478c:	89 81       	ldd	r24, Y+1	; 0x01
}
    478e:	0f 90       	pop	r0
    4790:	0f 90       	pop	r0
    4792:	0f 90       	pop	r0
    4794:	cf 91       	pop	r28
    4796:	df 91       	pop	r29
    4798:	08 95       	ret

0000479a <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    479a:	df 93       	push	r29
    479c:	cf 93       	push	r28
    479e:	00 d0       	rcall	.+0      	; 0x47a0 <xQueueIsQueueFullFromISR+0x6>
    47a0:	0f 92       	push	r0
    47a2:	cd b7       	in	r28, 0x3d	; 61
    47a4:	de b7       	in	r29, 0x3e	; 62
    47a6:	9b 83       	std	Y+3, r25	; 0x03
    47a8:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    47aa:	ea 81       	ldd	r30, Y+2	; 0x02
    47ac:	fb 81       	ldd	r31, Y+3	; 0x03
    47ae:	92 8d       	ldd	r25, Z+26	; 0x1a
    47b0:	ea 81       	ldd	r30, Y+2	; 0x02
    47b2:	fb 81       	ldd	r31, Y+3	; 0x03
    47b4:	83 8d       	ldd	r24, Z+27	; 0x1b
    47b6:	98 17       	cp	r25, r24
    47b8:	19 f4       	brne	.+6      	; 0x47c0 <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    47ba:	81 e0       	ldi	r24, 0x01	; 1
    47bc:	89 83       	std	Y+1, r24	; 0x01
    47be:	01 c0       	rjmp	.+2      	; 0x47c2 <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    47c0:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    47c2:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    47c4:	0f 90       	pop	r0
    47c6:	0f 90       	pop	r0
    47c8:	0f 90       	pop	r0
    47ca:	cf 91       	pop	r28
    47cc:	df 91       	pop	r29
    47ce:	08 95       	ret

000047d0 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    47d0:	df 93       	push	r29
    47d2:	cf 93       	push	r28
    47d4:	cd b7       	in	r28, 0x3d	; 61
    47d6:	de b7       	in	r29, 0x3e	; 62
    47d8:	2a 97       	sbiw	r28, 0x0a	; 10
    47da:	0f b6       	in	r0, 0x3f	; 63
    47dc:	f8 94       	cli
    47de:	de bf       	out	0x3e, r29	; 62
    47e0:	0f be       	out	0x3f, r0	; 63
    47e2:	cd bf       	out	0x3d, r28	; 61
    47e4:	9d 83       	std	Y+5, r25	; 0x05
    47e6:	8c 83       	std	Y+4, r24	; 0x04
    47e8:	7f 83       	std	Y+7, r23	; 0x07
    47ea:	6e 83       	std	Y+6, r22	; 0x06
    47ec:	59 87       	std	Y+9, r21	; 0x09
    47ee:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    47f0:	8c 81       	ldd	r24, Y+4	; 0x04
    47f2:	9d 81       	ldd	r25, Y+5	; 0x05
    47f4:	9a 83       	std	Y+2, r25	; 0x02
    47f6:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    47f8:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    47fa:	89 81       	ldd	r24, Y+1	; 0x01
    47fc:	9a 81       	ldd	r25, Y+2	; 0x02
    47fe:	0e 94 ad 23 	call	0x475a	; 0x475a <prvIsQueueFull>
    4802:	88 23       	and	r24, r24
    4804:	a9 f0       	breq	.+42     	; 0x4830 <xQueueCRSend+0x60>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    4806:	88 85       	ldd	r24, Y+8	; 0x08
    4808:	99 85       	ldd	r25, Y+9	; 0x09
    480a:	00 97       	sbiw	r24, 0x00	; 0
    480c:	71 f0       	breq	.+28     	; 0x482a <xQueueCRSend+0x5a>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    480e:	89 81       	ldd	r24, Y+1	; 0x01
    4810:	9a 81       	ldd	r25, Y+2	; 0x02
    4812:	9c 01       	movw	r18, r24
    4814:	28 5f       	subi	r18, 0xF8	; 248
    4816:	3f 4f       	sbci	r19, 0xFF	; 255
    4818:	88 85       	ldd	r24, Y+8	; 0x08
    481a:	99 85       	ldd	r25, Y+9	; 0x09
    481c:	b9 01       	movw	r22, r18
    481e:	0e 94 82 13 	call	0x2704	; 0x2704 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    4822:	78 94       	sei
					return errQUEUE_BLOCKED;
    4824:	8c ef       	ldi	r24, 0xFC	; 252
    4826:	8a 87       	std	Y+10, r24	; 0x0a
    4828:	2a c0       	rjmp	.+84     	; 0x487e <xQueueCRSend+0xae>
				}
				else
				{
					portENABLE_INTERRUPTS();
    482a:	78 94       	sei
					return errQUEUE_FULL;
    482c:	1a 86       	std	Y+10, r1	; 0x0a
    482e:	27 c0       	rjmp	.+78     	; 0x487e <xQueueCRSend+0xae>
				}
			}
		}
		portENABLE_INTERRUPTS();
    4830:	78 94       	sei

		portDISABLE_INTERRUPTS();
    4832:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    4834:	e9 81       	ldd	r30, Y+1	; 0x01
    4836:	fa 81       	ldd	r31, Y+2	; 0x02
    4838:	92 8d       	ldd	r25, Z+26	; 0x1a
    483a:	e9 81       	ldd	r30, Y+1	; 0x01
    483c:	fa 81       	ldd	r31, Y+2	; 0x02
    483e:	83 8d       	ldd	r24, Z+27	; 0x1b
    4840:	98 17       	cp	r25, r24
    4842:	c8 f4       	brcc	.+50     	; 0x4876 <xQueueCRSend+0xa6>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    4844:	89 81       	ldd	r24, Y+1	; 0x01
    4846:	9a 81       	ldd	r25, Y+2	; 0x02
    4848:	2e 81       	ldd	r18, Y+6	; 0x06
    484a:	3f 81       	ldd	r19, Y+7	; 0x07
    484c:	b9 01       	movw	r22, r18
    484e:	40 e0       	ldi	r20, 0x00	; 0
    4850:	0e 94 36 22 	call	0x446c	; 0x446c <prvCopyDataToQueue>
				xReturn = pdPASS;
    4854:	81 e0       	ldi	r24, 0x01	; 1
    4856:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4858:	e9 81       	ldd	r30, Y+1	; 0x01
    485a:	fa 81       	ldd	r31, Y+2	; 0x02
    485c:	81 89       	ldd	r24, Z+17	; 0x11
    485e:	88 23       	and	r24, r24
    4860:	59 f0       	breq	.+22     	; 0x4878 <xQueueCRSend+0xa8>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4862:	89 81       	ldd	r24, Y+1	; 0x01
    4864:	9a 81       	ldd	r25, Y+2	; 0x02
    4866:	41 96       	adiw	r24, 0x11	; 17
    4868:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <xCoRoutineRemoveFromEventList>
    486c:	88 23       	and	r24, r24
    486e:	21 f0       	breq	.+8      	; 0x4878 <xQueueCRSend+0xa8>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    4870:	8b ef       	ldi	r24, 0xFB	; 251
    4872:	8b 83       	std	Y+3, r24	; 0x03
    4874:	01 c0       	rjmp	.+2      	; 0x4878 <xQueueCRSend+0xa8>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    4876:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    4878:	78 94       	sei

		return xReturn;
    487a:	8b 81       	ldd	r24, Y+3	; 0x03
    487c:	8a 87       	std	Y+10, r24	; 0x0a
    487e:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    4880:	2a 96       	adiw	r28, 0x0a	; 10
    4882:	0f b6       	in	r0, 0x3f	; 63
    4884:	f8 94       	cli
    4886:	de bf       	out	0x3e, r29	; 62
    4888:	0f be       	out	0x3f, r0	; 63
    488a:	cd bf       	out	0x3d, r28	; 61
    488c:	cf 91       	pop	r28
    488e:	df 91       	pop	r29
    4890:	08 95       	ret

00004892 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    4892:	df 93       	push	r29
    4894:	cf 93       	push	r28
    4896:	cd b7       	in	r28, 0x3d	; 61
    4898:	de b7       	in	r29, 0x3e	; 62
    489a:	2a 97       	sbiw	r28, 0x0a	; 10
    489c:	0f b6       	in	r0, 0x3f	; 63
    489e:	f8 94       	cli
    48a0:	de bf       	out	0x3e, r29	; 62
    48a2:	0f be       	out	0x3f, r0	; 63
    48a4:	cd bf       	out	0x3d, r28	; 61
    48a6:	9d 83       	std	Y+5, r25	; 0x05
    48a8:	8c 83       	std	Y+4, r24	; 0x04
    48aa:	7f 83       	std	Y+7, r23	; 0x07
    48ac:	6e 83       	std	Y+6, r22	; 0x06
    48ae:	59 87       	std	Y+9, r21	; 0x09
    48b0:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    48b2:	8c 81       	ldd	r24, Y+4	; 0x04
    48b4:	9d 81       	ldd	r25, Y+5	; 0x05
    48b6:	9a 83       	std	Y+2, r25	; 0x02
    48b8:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    48ba:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    48bc:	e9 81       	ldd	r30, Y+1	; 0x01
    48be:	fa 81       	ldd	r31, Y+2	; 0x02
    48c0:	82 8d       	ldd	r24, Z+26	; 0x1a
    48c2:	88 23       	and	r24, r24
    48c4:	a9 f4       	brne	.+42     	; 0x48f0 <xQueueCRReceive+0x5e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    48c6:	88 85       	ldd	r24, Y+8	; 0x08
    48c8:	99 85       	ldd	r25, Y+9	; 0x09
    48ca:	00 97       	sbiw	r24, 0x00	; 0
    48cc:	71 f0       	breq	.+28     	; 0x48ea <xQueueCRReceive+0x58>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    48ce:	89 81       	ldd	r24, Y+1	; 0x01
    48d0:	9a 81       	ldd	r25, Y+2	; 0x02
    48d2:	9c 01       	movw	r18, r24
    48d4:	2f 5e       	subi	r18, 0xEF	; 239
    48d6:	3f 4f       	sbci	r19, 0xFF	; 255
    48d8:	88 85       	ldd	r24, Y+8	; 0x08
    48da:	99 85       	ldd	r25, Y+9	; 0x09
    48dc:	b9 01       	movw	r22, r18
    48de:	0e 94 82 13 	call	0x2704	; 0x2704 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    48e2:	78 94       	sei
					return errQUEUE_BLOCKED;
    48e4:	8c ef       	ldi	r24, 0xFC	; 252
    48e6:	8a 87       	std	Y+10, r24	; 0x0a
    48e8:	58 c0       	rjmp	.+176    	; 0x499a <xQueueCRReceive+0x108>
				}
				else
				{
					portENABLE_INTERRUPTS();
    48ea:	78 94       	sei
					return errQUEUE_FULL;
    48ec:	1a 86       	std	Y+10, r1	; 0x0a
    48ee:	55 c0       	rjmp	.+170    	; 0x499a <xQueueCRReceive+0x108>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    48f0:	78 94       	sei

		portDISABLE_INTERRUPTS();
    48f2:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    48f4:	e9 81       	ldd	r30, Y+1	; 0x01
    48f6:	fa 81       	ldd	r31, Y+2	; 0x02
    48f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    48fa:	88 23       	and	r24, r24
    48fc:	09 f4       	brne	.+2      	; 0x4900 <xQueueCRReceive+0x6e>
    48fe:	49 c0       	rjmp	.+146    	; 0x4992 <xQueueCRReceive+0x100>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    4900:	e9 81       	ldd	r30, Y+1	; 0x01
    4902:	fa 81       	ldd	r31, Y+2	; 0x02
    4904:	26 81       	ldd	r18, Z+6	; 0x06
    4906:	37 81       	ldd	r19, Z+7	; 0x07
    4908:	e9 81       	ldd	r30, Y+1	; 0x01
    490a:	fa 81       	ldd	r31, Y+2	; 0x02
    490c:	84 8d       	ldd	r24, Z+28	; 0x1c
    490e:	88 2f       	mov	r24, r24
    4910:	90 e0       	ldi	r25, 0x00	; 0
    4912:	82 0f       	add	r24, r18
    4914:	93 1f       	adc	r25, r19
    4916:	e9 81       	ldd	r30, Y+1	; 0x01
    4918:	fa 81       	ldd	r31, Y+2	; 0x02
    491a:	97 83       	std	Z+7, r25	; 0x07
    491c:	86 83       	std	Z+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    491e:	e9 81       	ldd	r30, Y+1	; 0x01
    4920:	fa 81       	ldd	r31, Y+2	; 0x02
    4922:	26 81       	ldd	r18, Z+6	; 0x06
    4924:	37 81       	ldd	r19, Z+7	; 0x07
    4926:	e9 81       	ldd	r30, Y+1	; 0x01
    4928:	fa 81       	ldd	r31, Y+2	; 0x02
    492a:	82 81       	ldd	r24, Z+2	; 0x02
    492c:	93 81       	ldd	r25, Z+3	; 0x03
    492e:	28 17       	cp	r18, r24
    4930:	39 07       	cpc	r19, r25
    4932:	40 f0       	brcs	.+16     	; 0x4944 <xQueueCRReceive+0xb2>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    4934:	e9 81       	ldd	r30, Y+1	; 0x01
    4936:	fa 81       	ldd	r31, Y+2	; 0x02
    4938:	80 81       	ld	r24, Z
    493a:	91 81       	ldd	r25, Z+1	; 0x01
    493c:	e9 81       	ldd	r30, Y+1	; 0x01
    493e:	fa 81       	ldd	r31, Y+2	; 0x02
    4940:	97 83       	std	Z+7, r25	; 0x07
    4942:	86 83       	std	Z+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    4944:	e9 81       	ldd	r30, Y+1	; 0x01
    4946:	fa 81       	ldd	r31, Y+2	; 0x02
    4948:	82 8d       	ldd	r24, Z+26	; 0x1a
    494a:	81 50       	subi	r24, 0x01	; 1
    494c:	e9 81       	ldd	r30, Y+1	; 0x01
    494e:	fa 81       	ldd	r31, Y+2	; 0x02
    4950:	82 8f       	std	Z+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    4952:	e9 81       	ldd	r30, Y+1	; 0x01
    4954:	fa 81       	ldd	r31, Y+2	; 0x02
    4956:	46 81       	ldd	r20, Z+6	; 0x06
    4958:	57 81       	ldd	r21, Z+7	; 0x07
    495a:	e9 81       	ldd	r30, Y+1	; 0x01
    495c:	fa 81       	ldd	r31, Y+2	; 0x02
    495e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4960:	28 2f       	mov	r18, r24
    4962:	30 e0       	ldi	r19, 0x00	; 0
    4964:	8e 81       	ldd	r24, Y+6	; 0x06
    4966:	9f 81       	ldd	r25, Y+7	; 0x07
    4968:	ba 01       	movw	r22, r20
    496a:	a9 01       	movw	r20, r18
    496c:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <memcpy>

				xReturn = pdPASS;
    4970:	81 e0       	ldi	r24, 0x01	; 1
    4972:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4974:	e9 81       	ldd	r30, Y+1	; 0x01
    4976:	fa 81       	ldd	r31, Y+2	; 0x02
    4978:	80 85       	ldd	r24, Z+8	; 0x08
    497a:	88 23       	and	r24, r24
    497c:	59 f0       	breq	.+22     	; 0x4994 <xQueueCRReceive+0x102>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    497e:	89 81       	ldd	r24, Y+1	; 0x01
    4980:	9a 81       	ldd	r25, Y+2	; 0x02
    4982:	08 96       	adiw	r24, 0x08	; 8
    4984:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <xCoRoutineRemoveFromEventList>
    4988:	88 23       	and	r24, r24
    498a:	21 f0       	breq	.+8      	; 0x4994 <xQueueCRReceive+0x102>
					{
						xReturn = errQUEUE_YIELD;
    498c:	8b ef       	ldi	r24, 0xFB	; 251
    498e:	8b 83       	std	Y+3, r24	; 0x03
    4990:	01 c0       	rjmp	.+2      	; 0x4994 <xQueueCRReceive+0x102>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    4992:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    4994:	78 94       	sei

		return xReturn;
    4996:	8b 81       	ldd	r24, Y+3	; 0x03
    4998:	8a 87       	std	Y+10, r24	; 0x0a
    499a:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    499c:	2a 96       	adiw	r28, 0x0a	; 10
    499e:	0f b6       	in	r0, 0x3f	; 63
    49a0:	f8 94       	cli
    49a2:	de bf       	out	0x3e, r29	; 62
    49a4:	0f be       	out	0x3f, r0	; 63
    49a6:	cd bf       	out	0x3d, r28	; 61
    49a8:	cf 91       	pop	r28
    49aa:	df 91       	pop	r29
    49ac:	08 95       	ret

000049ae <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    49ae:	df 93       	push	r29
    49b0:	cf 93       	push	r28
    49b2:	cd b7       	in	r28, 0x3d	; 61
    49b4:	de b7       	in	r29, 0x3e	; 62
    49b6:	28 97       	sbiw	r28, 0x08	; 8
    49b8:	0f b6       	in	r0, 0x3f	; 63
    49ba:	f8 94       	cli
    49bc:	de bf       	out	0x3e, r29	; 62
    49be:	0f be       	out	0x3f, r0	; 63
    49c0:	cd bf       	out	0x3d, r28	; 61
    49c2:	9c 83       	std	Y+4, r25	; 0x04
    49c4:	8b 83       	std	Y+3, r24	; 0x03
    49c6:	7e 83       	std	Y+6, r23	; 0x06
    49c8:	6d 83       	std	Y+5, r22	; 0x05
    49ca:	4f 83       	std	Y+7, r20	; 0x07
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    49cc:	8b 81       	ldd	r24, Y+3	; 0x03
    49ce:	9c 81       	ldd	r25, Y+4	; 0x04
    49d0:	9a 83       	std	Y+2, r25	; 0x02
    49d2:	89 83       	std	Y+1, r24	; 0x01

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    49d4:	e9 81       	ldd	r30, Y+1	; 0x01
    49d6:	fa 81       	ldd	r31, Y+2	; 0x02
    49d8:	92 8d       	ldd	r25, Z+26	; 0x1a
    49da:	e9 81       	ldd	r30, Y+1	; 0x01
    49dc:	fa 81       	ldd	r31, Y+2	; 0x02
    49de:	83 8d       	ldd	r24, Z+27	; 0x1b
    49e0:	98 17       	cp	r25, r24
    49e2:	d0 f4       	brcc	.+52     	; 0x4a18 <xQueueCRSendFromISR+0x6a>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    49e4:	89 81       	ldd	r24, Y+1	; 0x01
    49e6:	9a 81       	ldd	r25, Y+2	; 0x02
    49e8:	2d 81       	ldd	r18, Y+5	; 0x05
    49ea:	3e 81       	ldd	r19, Y+6	; 0x06
    49ec:	b9 01       	movw	r22, r18
    49ee:	40 e0       	ldi	r20, 0x00	; 0
    49f0:	0e 94 36 22 	call	0x446c	; 0x446c <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    49f4:	8f 81       	ldd	r24, Y+7	; 0x07
    49f6:	88 23       	and	r24, r24
    49f8:	79 f4       	brne	.+30     	; 0x4a18 <xQueueCRSendFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    49fa:	e9 81       	ldd	r30, Y+1	; 0x01
    49fc:	fa 81       	ldd	r31, Y+2	; 0x02
    49fe:	81 89       	ldd	r24, Z+17	; 0x11
    4a00:	88 23       	and	r24, r24
    4a02:	51 f0       	breq	.+20     	; 0x4a18 <xQueueCRSendFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4a04:	89 81       	ldd	r24, Y+1	; 0x01
    4a06:	9a 81       	ldd	r25, Y+2	; 0x02
    4a08:	41 96       	adiw	r24, 0x11	; 17
    4a0a:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <xCoRoutineRemoveFromEventList>
    4a0e:	88 23       	and	r24, r24
    4a10:	19 f0       	breq	.+6      	; 0x4a18 <xQueueCRSendFromISR+0x6a>
					{
						return pdTRUE;
    4a12:	81 e0       	ldi	r24, 0x01	; 1
    4a14:	88 87       	std	Y+8, r24	; 0x08
    4a16:	02 c0       	rjmp	.+4      	; 0x4a1c <xQueueCRSendFromISR+0x6e>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    4a18:	8f 81       	ldd	r24, Y+7	; 0x07
    4a1a:	88 87       	std	Y+8, r24	; 0x08
    4a1c:	88 85       	ldd	r24, Y+8	; 0x08
	}
    4a1e:	28 96       	adiw	r28, 0x08	; 8
    4a20:	0f b6       	in	r0, 0x3f	; 63
    4a22:	f8 94       	cli
    4a24:	de bf       	out	0x3e, r29	; 62
    4a26:	0f be       	out	0x3f, r0	; 63
    4a28:	cd bf       	out	0x3d, r28	; 61
    4a2a:	cf 91       	pop	r28
    4a2c:	df 91       	pop	r29
    4a2e:	08 95       	ret

00004a30 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    4a30:	df 93       	push	r29
    4a32:	cf 93       	push	r28
    4a34:	cd b7       	in	r28, 0x3d	; 61
    4a36:	de b7       	in	r29, 0x3e	; 62
    4a38:	29 97       	sbiw	r28, 0x09	; 9
    4a3a:	0f b6       	in	r0, 0x3f	; 63
    4a3c:	f8 94       	cli
    4a3e:	de bf       	out	0x3e, r29	; 62
    4a40:	0f be       	out	0x3f, r0	; 63
    4a42:	cd bf       	out	0x3d, r28	; 61
    4a44:	9d 83       	std	Y+5, r25	; 0x05
    4a46:	8c 83       	std	Y+4, r24	; 0x04
    4a48:	7f 83       	std	Y+7, r23	; 0x07
    4a4a:	6e 83       	std	Y+6, r22	; 0x06
    4a4c:	59 87       	std	Y+9, r21	; 0x09
    4a4e:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4a50:	8c 81       	ldd	r24, Y+4	; 0x04
    4a52:	9d 81       	ldd	r25, Y+5	; 0x05
    4a54:	9a 83       	std	Y+2, r25	; 0x02
    4a56:	89 83       	std	Y+1, r24	; 0x01

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    4a58:	e9 81       	ldd	r30, Y+1	; 0x01
    4a5a:	fa 81       	ldd	r31, Y+2	; 0x02
    4a5c:	82 8d       	ldd	r24, Z+26	; 0x1a
    4a5e:	88 23       	and	r24, r24
    4a60:	09 f4       	brne	.+2      	; 0x4a64 <xQueueCRReceiveFromISR+0x34>
    4a62:	50 c0       	rjmp	.+160    	; 0x4b04 <xQueueCRReceiveFromISR+0xd4>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    4a64:	e9 81       	ldd	r30, Y+1	; 0x01
    4a66:	fa 81       	ldd	r31, Y+2	; 0x02
    4a68:	26 81       	ldd	r18, Z+6	; 0x06
    4a6a:	37 81       	ldd	r19, Z+7	; 0x07
    4a6c:	e9 81       	ldd	r30, Y+1	; 0x01
    4a6e:	fa 81       	ldd	r31, Y+2	; 0x02
    4a70:	84 8d       	ldd	r24, Z+28	; 0x1c
    4a72:	88 2f       	mov	r24, r24
    4a74:	90 e0       	ldi	r25, 0x00	; 0
    4a76:	82 0f       	add	r24, r18
    4a78:	93 1f       	adc	r25, r19
    4a7a:	e9 81       	ldd	r30, Y+1	; 0x01
    4a7c:	fa 81       	ldd	r31, Y+2	; 0x02
    4a7e:	97 83       	std	Z+7, r25	; 0x07
    4a80:	86 83       	std	Z+6, r24	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    4a82:	e9 81       	ldd	r30, Y+1	; 0x01
    4a84:	fa 81       	ldd	r31, Y+2	; 0x02
    4a86:	26 81       	ldd	r18, Z+6	; 0x06
    4a88:	37 81       	ldd	r19, Z+7	; 0x07
    4a8a:	e9 81       	ldd	r30, Y+1	; 0x01
    4a8c:	fa 81       	ldd	r31, Y+2	; 0x02
    4a8e:	82 81       	ldd	r24, Z+2	; 0x02
    4a90:	93 81       	ldd	r25, Z+3	; 0x03
    4a92:	28 17       	cp	r18, r24
    4a94:	39 07       	cpc	r19, r25
    4a96:	40 f0       	brcs	.+16     	; 0x4aa8 <xQueueCRReceiveFromISR+0x78>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    4a98:	e9 81       	ldd	r30, Y+1	; 0x01
    4a9a:	fa 81       	ldd	r31, Y+2	; 0x02
    4a9c:	80 81       	ld	r24, Z
    4a9e:	91 81       	ldd	r25, Z+1	; 0x01
    4aa0:	e9 81       	ldd	r30, Y+1	; 0x01
    4aa2:	fa 81       	ldd	r31, Y+2	; 0x02
    4aa4:	97 83       	std	Z+7, r25	; 0x07
    4aa6:	86 83       	std	Z+6, r24	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    4aa8:	e9 81       	ldd	r30, Y+1	; 0x01
    4aaa:	fa 81       	ldd	r31, Y+2	; 0x02
    4aac:	82 8d       	ldd	r24, Z+26	; 0x1a
    4aae:	81 50       	subi	r24, 0x01	; 1
    4ab0:	e9 81       	ldd	r30, Y+1	; 0x01
    4ab2:	fa 81       	ldd	r31, Y+2	; 0x02
    4ab4:	82 8f       	std	Z+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    4ab6:	e9 81       	ldd	r30, Y+1	; 0x01
    4ab8:	fa 81       	ldd	r31, Y+2	; 0x02
    4aba:	46 81       	ldd	r20, Z+6	; 0x06
    4abc:	57 81       	ldd	r21, Z+7	; 0x07
    4abe:	e9 81       	ldd	r30, Y+1	; 0x01
    4ac0:	fa 81       	ldd	r31, Y+2	; 0x02
    4ac2:	84 8d       	ldd	r24, Z+28	; 0x1c
    4ac4:	28 2f       	mov	r18, r24
    4ac6:	30 e0       	ldi	r19, 0x00	; 0
    4ac8:	8e 81       	ldd	r24, Y+6	; 0x06
    4aca:	9f 81       	ldd	r25, Y+7	; 0x07
    4acc:	ba 01       	movw	r22, r20
    4ace:	a9 01       	movw	r20, r18
    4ad0:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    4ad4:	e8 85       	ldd	r30, Y+8	; 0x08
    4ad6:	f9 85       	ldd	r31, Y+9	; 0x09
    4ad8:	80 81       	ld	r24, Z
    4ada:	88 23       	and	r24, r24
    4adc:	81 f4       	brne	.+32     	; 0x4afe <xQueueCRReceiveFromISR+0xce>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4ade:	e9 81       	ldd	r30, Y+1	; 0x01
    4ae0:	fa 81       	ldd	r31, Y+2	; 0x02
    4ae2:	80 85       	ldd	r24, Z+8	; 0x08
    4ae4:	88 23       	and	r24, r24
    4ae6:	59 f0       	breq	.+22     	; 0x4afe <xQueueCRReceiveFromISR+0xce>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4ae8:	89 81       	ldd	r24, Y+1	; 0x01
    4aea:	9a 81       	ldd	r25, Y+2	; 0x02
    4aec:	08 96       	adiw	r24, 0x08	; 8
    4aee:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <xCoRoutineRemoveFromEventList>
    4af2:	88 23       	and	r24, r24
    4af4:	21 f0       	breq	.+8      	; 0x4afe <xQueueCRReceiveFromISR+0xce>
					{
						*pxCoRoutineWoken = pdTRUE;
    4af6:	e8 85       	ldd	r30, Y+8	; 0x08
    4af8:	f9 85       	ldd	r31, Y+9	; 0x09
    4afa:	81 e0       	ldi	r24, 0x01	; 1
    4afc:	80 83       	st	Z, r24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    4afe:	81 e0       	ldi	r24, 0x01	; 1
    4b00:	8b 83       	std	Y+3, r24	; 0x03
    4b02:	01 c0       	rjmp	.+2      	; 0x4b06 <xQueueCRReceiveFromISR+0xd6>
		}
		else
		{
			xReturn = pdFAIL;
    4b04:	1b 82       	std	Y+3, r1	; 0x03
		}

		return xReturn;
    4b06:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    4b08:	29 96       	adiw	r28, 0x09	; 9
    4b0a:	0f b6       	in	r0, 0x3f	; 63
    4b0c:	f8 94       	cli
    4b0e:	de bf       	out	0x3e, r29	; 62
    4b10:	0f be       	out	0x3f, r0	; 63
    4b12:	cd bf       	out	0x3d, r28	; 61
    4b14:	cf 91       	pop	r28
    4b16:	df 91       	pop	r29
    4b18:	08 95       	ret

00004b1a <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4b1a:	af 92       	push	r10
    4b1c:	bf 92       	push	r11
    4b1e:	cf 92       	push	r12
    4b20:	df 92       	push	r13
    4b22:	ef 92       	push	r14
    4b24:	ff 92       	push	r15
    4b26:	0f 93       	push	r16
    4b28:	1f 93       	push	r17
    4b2a:	df 93       	push	r29
    4b2c:	cf 93       	push	r28
    4b2e:	cd b7       	in	r28, 0x3d	; 61
    4b30:	de b7       	in	r29, 0x3e	; 62
    4b32:	64 97       	sbiw	r28, 0x14	; 20
    4b34:	0f b6       	in	r0, 0x3f	; 63
    4b36:	f8 94       	cli
    4b38:	de bf       	out	0x3e, r29	; 62
    4b3a:	0f be       	out	0x3f, r0	; 63
    4b3c:	cd bf       	out	0x3d, r28	; 61
    4b3e:	9f 83       	std	Y+7, r25	; 0x07
    4b40:	8e 83       	std	Y+6, r24	; 0x06
    4b42:	79 87       	std	Y+9, r23	; 0x09
    4b44:	68 87       	std	Y+8, r22	; 0x08
    4b46:	5b 87       	std	Y+11, r21	; 0x0b
    4b48:	4a 87       	std	Y+10, r20	; 0x0a
    4b4a:	3d 87       	std	Y+13, r19	; 0x0d
    4b4c:	2c 87       	std	Y+12, r18	; 0x0c
    4b4e:	0e 87       	std	Y+14, r16	; 0x0e
    4b50:	f8 8a       	std	Y+16, r15	; 0x10
    4b52:	ef 86       	std	Y+15, r14	; 0x0f
    4b54:	da 8a       	std	Y+18, r13	; 0x12
    4b56:	c9 8a       	std	Y+17, r12	; 0x11
    4b58:	bc 8a       	std	Y+20, r11	; 0x14
    4b5a:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    4b5c:	8a 85       	ldd	r24, Y+10	; 0x0a
    4b5e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4b60:	29 89       	ldd	r18, Y+17	; 0x11
    4b62:	3a 89       	ldd	r19, Y+18	; 0x12
    4b64:	b9 01       	movw	r22, r18
    4b66:	0e 94 f0 2c 	call	0x59e0	; 0x59e0 <prvAllocateTCBAndStack>
    4b6a:	9c 83       	std	Y+4, r25	; 0x04
    4b6c:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    4b6e:	8b 81       	ldd	r24, Y+3	; 0x03
    4b70:	9c 81       	ldd	r25, Y+4	; 0x04
    4b72:	00 97       	sbiw	r24, 0x00	; 0
    4b74:	09 f4       	brne	.+2      	; 0x4b78 <xTaskGenericCreate+0x5e>
    4b76:	8d c0       	rjmp	.+282    	; 0x4c92 <xTaskGenericCreate+0x178>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    4b78:	eb 81       	ldd	r30, Y+3	; 0x03
    4b7a:	fc 81       	ldd	r31, Y+4	; 0x04
    4b7c:	27 89       	ldd	r18, Z+23	; 0x17
    4b7e:	30 8d       	ldd	r19, Z+24	; 0x18
    4b80:	8a 85       	ldd	r24, Y+10	; 0x0a
    4b82:	9b 85       	ldd	r25, Y+11	; 0x0b
    4b84:	01 97       	sbiw	r24, 0x01	; 1
    4b86:	82 0f       	add	r24, r18
    4b88:	93 1f       	adc	r25, r19
    4b8a:	9a 83       	std	Y+2, r25	; 0x02
    4b8c:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    4b8e:	8b 81       	ldd	r24, Y+3	; 0x03
    4b90:	9c 81       	ldd	r25, Y+4	; 0x04
    4b92:	28 85       	ldd	r18, Y+8	; 0x08
    4b94:	39 85       	ldd	r19, Y+9	; 0x09
    4b96:	eb 89       	ldd	r30, Y+19	; 0x13
    4b98:	fc 89       	ldd	r31, Y+20	; 0x14
    4b9a:	aa 85       	ldd	r26, Y+10	; 0x0a
    4b9c:	bb 85       	ldd	r27, Y+11	; 0x0b
    4b9e:	b9 01       	movw	r22, r18
    4ba0:	4e 85       	ldd	r20, Y+14	; 0x0e
    4ba2:	9f 01       	movw	r18, r30
    4ba4:	8d 01       	movw	r16, r26
    4ba6:	0e 94 b8 2b 	call	0x5770	; 0x5770 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4baa:	89 81       	ldd	r24, Y+1	; 0x01
    4bac:	9a 81       	ldd	r25, Y+2	; 0x02
    4bae:	2e 81       	ldd	r18, Y+6	; 0x06
    4bb0:	3f 81       	ldd	r19, Y+7	; 0x07
    4bb2:	4c 85       	ldd	r20, Y+12	; 0x0c
    4bb4:	5d 85       	ldd	r21, Y+13	; 0x0d
    4bb6:	b9 01       	movw	r22, r18
    4bb8:	0e 94 8a 1b 	call	0x3714	; 0x3714 <pxPortInitialiseStack>
    4bbc:	eb 81       	ldd	r30, Y+3	; 0x03
    4bbe:	fc 81       	ldd	r31, Y+4	; 0x04
    4bc0:	91 83       	std	Z+1, r25	; 0x01
    4bc2:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    4bc4:	8f 85       	ldd	r24, Y+15	; 0x0f
    4bc6:	98 89       	ldd	r25, Y+16	; 0x10
    4bc8:	00 97       	sbiw	r24, 0x00	; 0
    4bca:	31 f0       	breq	.+12     	; 0x4bd8 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4bcc:	ef 85       	ldd	r30, Y+15	; 0x0f
    4bce:	f8 89       	ldd	r31, Y+16	; 0x10
    4bd0:	8b 81       	ldd	r24, Y+3	; 0x03
    4bd2:	9c 81       	ldd	r25, Y+4	; 0x04
    4bd4:	91 83       	std	Z+1, r25	; 0x01
    4bd6:	80 83       	st	Z, r24
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    4bd8:	0f b6       	in	r0, 0x3f	; 63
    4bda:	f8 94       	cli
    4bdc:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    4bde:	80 91 a0 07 	lds	r24, 0x07A0
    4be2:	8f 5f       	subi	r24, 0xFF	; 255
    4be4:	80 93 a0 07 	sts	0x07A0, r24
			if( pxCurrentTCB == NULL )
    4be8:	80 91 9d 07 	lds	r24, 0x079D
    4bec:	90 91 9e 07 	lds	r25, 0x079E
    4bf0:	00 97       	sbiw	r24, 0x00	; 0
    4bf2:	69 f4       	brne	.+26     	; 0x4c0e <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    4bf4:	8b 81       	ldd	r24, Y+3	; 0x03
    4bf6:	9c 81       	ldd	r25, Y+4	; 0x04
    4bf8:	90 93 9e 07 	sts	0x079E, r25
    4bfc:	80 93 9d 07 	sts	0x079D, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    4c00:	80 91 a0 07 	lds	r24, 0x07A0
    4c04:	81 30       	cpi	r24, 0x01	; 1
    4c06:	a9 f4       	brne	.+42     	; 0x4c32 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    4c08:	0e 94 2b 2c 	call	0x5856	; 0x5856 <prvInitialiseTaskLists>
    4c0c:	12 c0       	rjmp	.+36     	; 0x4c32 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    4c0e:	80 91 a4 07 	lds	r24, 0x07A4
    4c12:	88 23       	and	r24, r24
    4c14:	71 f4       	brne	.+28     	; 0x4c32 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    4c16:	e0 91 9d 07 	lds	r30, 0x079D
    4c1a:	f0 91 9e 07 	lds	r31, 0x079E
    4c1e:	96 89       	ldd	r25, Z+22	; 0x16
    4c20:	8e 85       	ldd	r24, Y+14	; 0x0e
    4c22:	89 17       	cp	r24, r25
    4c24:	30 f0       	brcs	.+12     	; 0x4c32 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    4c26:	8b 81       	ldd	r24, Y+3	; 0x03
    4c28:	9c 81       	ldd	r25, Y+4	; 0x04
    4c2a:	90 93 9e 07 	sts	0x079E, r25
    4c2e:	80 93 9d 07 	sts	0x079D, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    4c32:	80 91 a8 07 	lds	r24, 0x07A8
    4c36:	8f 5f       	subi	r24, 0xFF	; 255
    4c38:	80 93 a8 07 	sts	0x07A8, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    4c3c:	eb 81       	ldd	r30, Y+3	; 0x03
    4c3e:	fc 81       	ldd	r31, Y+4	; 0x04
    4c40:	96 89       	ldd	r25, Z+22	; 0x16
    4c42:	80 91 a3 07 	lds	r24, 0x07A3
    4c46:	89 17       	cp	r24, r25
    4c48:	28 f4       	brcc	.+10     	; 0x4c54 <xTaskGenericCreate+0x13a>
    4c4a:	eb 81       	ldd	r30, Y+3	; 0x03
    4c4c:	fc 81       	ldd	r31, Y+4	; 0x04
    4c4e:	86 89       	ldd	r24, Z+22	; 0x16
    4c50:	80 93 a3 07 	sts	0x07A3, r24
    4c54:	eb 81       	ldd	r30, Y+3	; 0x03
    4c56:	fc 81       	ldd	r31, Y+4	; 0x04
    4c58:	86 89       	ldd	r24, Z+22	; 0x16
    4c5a:	28 2f       	mov	r18, r24
    4c5c:	30 e0       	ldi	r19, 0x00	; 0
    4c5e:	c9 01       	movw	r24, r18
    4c60:	88 0f       	add	r24, r24
    4c62:	99 1f       	adc	r25, r25
    4c64:	88 0f       	add	r24, r24
    4c66:	99 1f       	adc	r25, r25
    4c68:	88 0f       	add	r24, r24
    4c6a:	99 1f       	adc	r25, r25
    4c6c:	82 0f       	add	r24, r18
    4c6e:	93 1f       	adc	r25, r19
    4c70:	ac 01       	movw	r20, r24
    4c72:	46 55       	subi	r20, 0x56	; 86
    4c74:	58 4f       	sbci	r21, 0xF8	; 248
    4c76:	8b 81       	ldd	r24, Y+3	; 0x03
    4c78:	9c 81       	ldd	r25, Y+4	; 0x04
    4c7a:	9c 01       	movw	r18, r24
    4c7c:	2e 5f       	subi	r18, 0xFE	; 254
    4c7e:	3f 4f       	sbci	r19, 0xFF	; 255
    4c80:	ca 01       	movw	r24, r20
    4c82:	b9 01       	movw	r22, r18
    4c84:	0e 94 8e 1a 	call	0x351c	; 0x351c <vListInsertEnd>

			xReturn = pdPASS;
    4c88:	81 e0       	ldi	r24, 0x01	; 1
    4c8a:	8d 83       	std	Y+5, r24	; 0x05
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    4c8c:	0f 90       	pop	r0
    4c8e:	0f be       	out	0x3f, r0	; 63
    4c90:	02 c0       	rjmp	.+4      	; 0x4c96 <xTaskGenericCreate+0x17c>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4c92:	8f ef       	ldi	r24, 0xFF	; 255
    4c94:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    4c96:	8d 81       	ldd	r24, Y+5	; 0x05
    4c98:	81 30       	cpi	r24, 0x01	; 1
    4c9a:	71 f4       	brne	.+28     	; 0x4cb8 <xTaskGenericCreate+0x19e>
	{
		if( xSchedulerRunning != pdFALSE )
    4c9c:	80 91 a4 07 	lds	r24, 0x07A4
    4ca0:	88 23       	and	r24, r24
    4ca2:	51 f0       	breq	.+20     	; 0x4cb8 <xTaskGenericCreate+0x19e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    4ca4:	e0 91 9d 07 	lds	r30, 0x079D
    4ca8:	f0 91 9e 07 	lds	r31, 0x079E
    4cac:	96 89       	ldd	r25, Z+22	; 0x16
    4cae:	8e 85       	ldd	r24, Y+14	; 0x0e
    4cb0:	98 17       	cp	r25, r24
    4cb2:	10 f4       	brcc	.+4      	; 0x4cb8 <xTaskGenericCreate+0x19e>
			{
				taskYIELD_IF_USING_PREEMPTION();
    4cb4:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    4cb8:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4cba:	64 96       	adiw	r28, 0x14	; 20
    4cbc:	0f b6       	in	r0, 0x3f	; 63
    4cbe:	f8 94       	cli
    4cc0:	de bf       	out	0x3e, r29	; 62
    4cc2:	0f be       	out	0x3f, r0	; 63
    4cc4:	cd bf       	out	0x3d, r28	; 61
    4cc6:	cf 91       	pop	r28
    4cc8:	df 91       	pop	r29
    4cca:	1f 91       	pop	r17
    4ccc:	0f 91       	pop	r16
    4cce:	ff 90       	pop	r15
    4cd0:	ef 90       	pop	r14
    4cd2:	df 90       	pop	r13
    4cd4:	cf 90       	pop	r12
    4cd6:	bf 90       	pop	r11
    4cd8:	af 90       	pop	r10
    4cda:	08 95       	ret

00004cdc <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    4cdc:	df 93       	push	r29
    4cde:	cf 93       	push	r28
    4ce0:	00 d0       	rcall	.+0      	; 0x4ce2 <vTaskDelete+0x6>
    4ce2:	00 d0       	rcall	.+0      	; 0x4ce4 <vTaskDelete+0x8>
    4ce4:	00 d0       	rcall	.+0      	; 0x4ce6 <vTaskDelete+0xa>
    4ce6:	cd b7       	in	r28, 0x3d	; 61
    4ce8:	de b7       	in	r29, 0x3e	; 62
    4cea:	9c 83       	std	Y+4, r25	; 0x04
    4cec:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4cee:	0f b6       	in	r0, 0x3f	; 63
    4cf0:	f8 94       	cli
    4cf2:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4cf4:	8b 81       	ldd	r24, Y+3	; 0x03
    4cf6:	9c 81       	ldd	r25, Y+4	; 0x04
    4cf8:	00 97       	sbiw	r24, 0x00	; 0
    4cfa:	39 f4       	brne	.+14     	; 0x4d0a <vTaskDelete+0x2e>
    4cfc:	80 91 9d 07 	lds	r24, 0x079D
    4d00:	90 91 9e 07 	lds	r25, 0x079E
    4d04:	9e 83       	std	Y+6, r25	; 0x06
    4d06:	8d 83       	std	Y+5, r24	; 0x05
    4d08:	04 c0       	rjmp	.+8      	; 0x4d12 <vTaskDelete+0x36>
    4d0a:	8b 81       	ldd	r24, Y+3	; 0x03
    4d0c:	9c 81       	ldd	r25, Y+4	; 0x04
    4d0e:	9e 83       	std	Y+6, r25	; 0x06
    4d10:	8d 83       	std	Y+5, r24	; 0x05
    4d12:	8d 81       	ldd	r24, Y+5	; 0x05
    4d14:	9e 81       	ldd	r25, Y+6	; 0x06
    4d16:	9a 83       	std	Y+2, r25	; 0x02
    4d18:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4d1a:	89 81       	ldd	r24, Y+1	; 0x01
    4d1c:	9a 81       	ldd	r25, Y+2	; 0x02
    4d1e:	02 96       	adiw	r24, 0x02	; 2
    4d20:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4d24:	e9 81       	ldd	r30, Y+1	; 0x01
    4d26:	fa 81       	ldd	r31, Y+2	; 0x02
    4d28:	84 89       	ldd	r24, Z+20	; 0x14
    4d2a:	95 89       	ldd	r25, Z+21	; 0x15
    4d2c:	00 97       	sbiw	r24, 0x00	; 0
    4d2e:	29 f0       	breq	.+10     	; 0x4d3a <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4d30:	89 81       	ldd	r24, Y+1	; 0x01
    4d32:	9a 81       	ldd	r25, Y+2	; 0x02
    4d34:	0c 96       	adiw	r24, 0x0c	; 12
    4d36:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    4d3a:	89 81       	ldd	r24, Y+1	; 0x01
    4d3c:	9a 81       	ldd	r25, Y+2	; 0x02
    4d3e:	9c 01       	movw	r18, r24
    4d40:	2e 5f       	subi	r18, 0xFE	; 254
    4d42:	3f 4f       	sbci	r19, 0xFF	; 255
    4d44:	8d ee       	ldi	r24, 0xED	; 237
    4d46:	97 e0       	ldi	r25, 0x07	; 7
    4d48:	b9 01       	movw	r22, r18
    4d4a:	0e 94 8e 1a 	call	0x351c	; 0x351c <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    4d4e:	80 91 9f 07 	lds	r24, 0x079F
    4d52:	8f 5f       	subi	r24, 0xFF	; 255
    4d54:	80 93 9f 07 	sts	0x079F, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    4d58:	80 91 a8 07 	lds	r24, 0x07A8
    4d5c:	8f 5f       	subi	r24, 0xFF	; 255
    4d5e:	80 93 a8 07 	sts	0x07A8, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4d62:	0f 90       	pop	r0
    4d64:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    4d66:	80 91 a4 07 	lds	r24, 0x07A4
    4d6a:	88 23       	and	r24, r24
    4d6c:	99 f0       	breq	.+38     	; 0x4d94 <vTaskDelete+0xb8>
		{
			if( pxTCB == pxCurrentTCB )
    4d6e:	20 91 9d 07 	lds	r18, 0x079D
    4d72:	30 91 9e 07 	lds	r19, 0x079E
    4d76:	89 81       	ldd	r24, Y+1	; 0x01
    4d78:	9a 81       	ldd	r25, Y+2	; 0x02
    4d7a:	82 17       	cp	r24, r18
    4d7c:	93 07       	cpc	r25, r19
    4d7e:	19 f4       	brne	.+6      	; 0x4d86 <vTaskDelete+0xaa>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    4d80:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <vPortYield>
    4d84:	07 c0       	rjmp	.+14     	; 0x4d94 <vTaskDelete+0xb8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    4d86:	0f b6       	in	r0, 0x3f	; 63
    4d88:	f8 94       	cli
    4d8a:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    4d8c:	0e 94 4a 2d 	call	0x5a94	; 0x5a94 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    4d90:	0f 90       	pop	r0
    4d92:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    4d94:	26 96       	adiw	r28, 0x06	; 6
    4d96:	0f b6       	in	r0, 0x3f	; 63
    4d98:	f8 94       	cli
    4d9a:	de bf       	out	0x3e, r29	; 62
    4d9c:	0f be       	out	0x3f, r0	; 63
    4d9e:	cd bf       	out	0x3d, r28	; 61
    4da0:	cf 91       	pop	r28
    4da2:	df 91       	pop	r29
    4da4:	08 95       	ret

00004da6 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    4da6:	df 93       	push	r29
    4da8:	cf 93       	push	r28
    4daa:	cd b7       	in	r28, 0x3d	; 61
    4dac:	de b7       	in	r29, 0x3e	; 62
    4dae:	2a 97       	sbiw	r28, 0x0a	; 10
    4db0:	0f b6       	in	r0, 0x3f	; 63
    4db2:	f8 94       	cli
    4db4:	de bf       	out	0x3e, r29	; 62
    4db6:	0f be       	out	0x3f, r0	; 63
    4db8:	cd bf       	out	0x3d, r28	; 61
    4dba:	98 87       	std	Y+8, r25	; 0x08
    4dbc:	8f 83       	std	Y+7, r24	; 0x07
    4dbe:	7a 87       	std	Y+10, r23	; 0x0a
    4dc0:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    4dc2:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    4dc4:	0e 94 bf 27 	call	0x4f7e	; 0x4f7e <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    4dc8:	80 91 a1 07 	lds	r24, 0x07A1
    4dcc:	90 91 a2 07 	lds	r25, 0x07A2
    4dd0:	9a 83       	std	Y+2, r25	; 0x02
    4dd2:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    4dd4:	ef 81       	ldd	r30, Y+7	; 0x07
    4dd6:	f8 85       	ldd	r31, Y+8	; 0x08
    4dd8:	20 81       	ld	r18, Z
    4dda:	31 81       	ldd	r19, Z+1	; 0x01
    4ddc:	89 85       	ldd	r24, Y+9	; 0x09
    4dde:	9a 85       	ldd	r25, Y+10	; 0x0a
    4de0:	82 0f       	add	r24, r18
    4de2:	93 1f       	adc	r25, r19
    4de4:	9e 83       	std	Y+6, r25	; 0x06
    4de6:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    4de8:	ef 81       	ldd	r30, Y+7	; 0x07
    4dea:	f8 85       	ldd	r31, Y+8	; 0x08
    4dec:	20 81       	ld	r18, Z
    4dee:	31 81       	ldd	r19, Z+1	; 0x01
    4df0:	89 81       	ldd	r24, Y+1	; 0x01
    4df2:	9a 81       	ldd	r25, Y+2	; 0x02
    4df4:	82 17       	cp	r24, r18
    4df6:	93 07       	cpc	r25, r19
    4df8:	98 f4       	brcc	.+38     	; 0x4e20 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    4dfa:	ef 81       	ldd	r30, Y+7	; 0x07
    4dfc:	f8 85       	ldd	r31, Y+8	; 0x08
    4dfe:	20 81       	ld	r18, Z
    4e00:	31 81       	ldd	r19, Z+1	; 0x01
    4e02:	8d 81       	ldd	r24, Y+5	; 0x05
    4e04:	9e 81       	ldd	r25, Y+6	; 0x06
    4e06:	82 17       	cp	r24, r18
    4e08:	93 07       	cpc	r25, r19
    4e0a:	e0 f4       	brcc	.+56     	; 0x4e44 <vTaskDelayUntil+0x9e>
    4e0c:	2d 81       	ldd	r18, Y+5	; 0x05
    4e0e:	3e 81       	ldd	r19, Y+6	; 0x06
    4e10:	89 81       	ldd	r24, Y+1	; 0x01
    4e12:	9a 81       	ldd	r25, Y+2	; 0x02
    4e14:	82 17       	cp	r24, r18
    4e16:	93 07       	cpc	r25, r19
    4e18:	a8 f4       	brcc	.+42     	; 0x4e44 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4e1a:	81 e0       	ldi	r24, 0x01	; 1
    4e1c:	8b 83       	std	Y+3, r24	; 0x03
    4e1e:	12 c0       	rjmp	.+36     	; 0x4e44 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    4e20:	ef 81       	ldd	r30, Y+7	; 0x07
    4e22:	f8 85       	ldd	r31, Y+8	; 0x08
    4e24:	20 81       	ld	r18, Z
    4e26:	31 81       	ldd	r19, Z+1	; 0x01
    4e28:	8d 81       	ldd	r24, Y+5	; 0x05
    4e2a:	9e 81       	ldd	r25, Y+6	; 0x06
    4e2c:	82 17       	cp	r24, r18
    4e2e:	93 07       	cpc	r25, r19
    4e30:	38 f0       	brcs	.+14     	; 0x4e40 <vTaskDelayUntil+0x9a>
    4e32:	2d 81       	ldd	r18, Y+5	; 0x05
    4e34:	3e 81       	ldd	r19, Y+6	; 0x06
    4e36:	89 81       	ldd	r24, Y+1	; 0x01
    4e38:	9a 81       	ldd	r25, Y+2	; 0x02
    4e3a:	82 17       	cp	r24, r18
    4e3c:	93 07       	cpc	r25, r19
    4e3e:	10 f4       	brcc	.+4      	; 0x4e44 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4e40:	81 e0       	ldi	r24, 0x01	; 1
    4e42:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    4e44:	ef 81       	ldd	r30, Y+7	; 0x07
    4e46:	f8 85       	ldd	r31, Y+8	; 0x08
    4e48:	8d 81       	ldd	r24, Y+5	; 0x05
    4e4a:	9e 81       	ldd	r25, Y+6	; 0x06
    4e4c:	91 83       	std	Z+1, r25	; 0x01
    4e4e:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    4e50:	8b 81       	ldd	r24, Y+3	; 0x03
    4e52:	88 23       	and	r24, r24
    4e54:	59 f0       	breq	.+22     	; 0x4e6c <vTaskDelayUntil+0xc6>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4e56:	80 91 9d 07 	lds	r24, 0x079D
    4e5a:	90 91 9e 07 	lds	r25, 0x079E
    4e5e:	02 96       	adiw	r24, 0x02	; 2
    4e60:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4e64:	8d 81       	ldd	r24, Y+5	; 0x05
    4e66:	9e 81       	ldd	r25, Y+6	; 0x06
    4e68:	0e 94 a7 2c 	call	0x594e	; 0x594e <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    4e6c:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <xTaskResumeAll>
    4e70:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4e72:	8c 81       	ldd	r24, Y+4	; 0x04
    4e74:	88 23       	and	r24, r24
    4e76:	11 f4       	brne	.+4      	; 0x4e7c <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    4e78:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4e7c:	2a 96       	adiw	r28, 0x0a	; 10
    4e7e:	0f b6       	in	r0, 0x3f	; 63
    4e80:	f8 94       	cli
    4e82:	de bf       	out	0x3e, r29	; 62
    4e84:	0f be       	out	0x3f, r0	; 63
    4e86:	cd bf       	out	0x3d, r28	; 61
    4e88:	cf 91       	pop	r28
    4e8a:	df 91       	pop	r29
    4e8c:	08 95       	ret

00004e8e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    4e8e:	df 93       	push	r29
    4e90:	cf 93       	push	r28
    4e92:	00 d0       	rcall	.+0      	; 0x4e94 <vTaskDelay+0x6>
    4e94:	00 d0       	rcall	.+0      	; 0x4e96 <vTaskDelay+0x8>
    4e96:	0f 92       	push	r0
    4e98:	cd b7       	in	r28, 0x3d	; 61
    4e9a:	de b7       	in	r29, 0x3e	; 62
    4e9c:	9d 83       	std	Y+5, r25	; 0x05
    4e9e:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    4ea0:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    4ea2:	8c 81       	ldd	r24, Y+4	; 0x04
    4ea4:	9d 81       	ldd	r25, Y+5	; 0x05
    4ea6:	00 97       	sbiw	r24, 0x00	; 0
    4ea8:	d1 f0       	breq	.+52     	; 0x4ede <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    4eaa:	0e 94 bf 27 	call	0x4f7e	; 0x4f7e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    4eae:	20 91 a1 07 	lds	r18, 0x07A1
    4eb2:	30 91 a2 07 	lds	r19, 0x07A2
    4eb6:	8c 81       	ldd	r24, Y+4	; 0x04
    4eb8:	9d 81       	ldd	r25, Y+5	; 0x05
    4eba:	82 0f       	add	r24, r18
    4ebc:	93 1f       	adc	r25, r19
    4ebe:	9b 83       	std	Y+3, r25	; 0x03
    4ec0:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4ec2:	80 91 9d 07 	lds	r24, 0x079D
    4ec6:	90 91 9e 07 	lds	r25, 0x079E
    4eca:	02 96       	adiw	r24, 0x02	; 2
    4ecc:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4ed0:	8a 81       	ldd	r24, Y+2	; 0x02
    4ed2:	9b 81       	ldd	r25, Y+3	; 0x03
    4ed4:	0e 94 a7 2c 	call	0x594e	; 0x594e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    4ed8:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <xTaskResumeAll>
    4edc:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4ede:	89 81       	ldd	r24, Y+1	; 0x01
    4ee0:	88 23       	and	r24, r24
    4ee2:	11 f4       	brne	.+4      	; 0x4ee8 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    4ee4:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4ee8:	0f 90       	pop	r0
    4eea:	0f 90       	pop	r0
    4eec:	0f 90       	pop	r0
    4eee:	0f 90       	pop	r0
    4ef0:	0f 90       	pop	r0
    4ef2:	cf 91       	pop	r28
    4ef4:	df 91       	pop	r29
    4ef6:	08 95       	ret

00004ef8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4ef8:	af 92       	push	r10
    4efa:	bf 92       	push	r11
    4efc:	cf 92       	push	r12
    4efe:	df 92       	push	r13
    4f00:	ef 92       	push	r14
    4f02:	ff 92       	push	r15
    4f04:	0f 93       	push	r16
    4f06:	df 93       	push	r29
    4f08:	cf 93       	push	r28
    4f0a:	0f 92       	push	r0
    4f0c:	cd b7       	in	r28, 0x3d	; 61
    4f0e:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    4f10:	88 ea       	ldi	r24, 0xA8	; 168
    4f12:	9b e2       	ldi	r25, 0x2B	; 43
    4f14:	24 e4       	ldi	r18, 0x44	; 68
    4f16:	31 e0       	ldi	r19, 0x01	; 1
    4f18:	b9 01       	movw	r22, r18
    4f1a:	45 e5       	ldi	r20, 0x55	; 85
    4f1c:	50 e0       	ldi	r21, 0x00	; 0
    4f1e:	20 e0       	ldi	r18, 0x00	; 0
    4f20:	30 e0       	ldi	r19, 0x00	; 0
    4f22:	00 e0       	ldi	r16, 0x00	; 0
    4f24:	ee 24       	eor	r14, r14
    4f26:	ff 24       	eor	r15, r15
    4f28:	cc 24       	eor	r12, r12
    4f2a:	dd 24       	eor	r13, r13
    4f2c:	aa 24       	eor	r10, r10
    4f2e:	bb 24       	eor	r11, r11
    4f30:	0e 94 8d 25 	call	0x4b1a	; 0x4b1a <xTaskGenericCreate>
    4f34:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    4f36:	89 81       	ldd	r24, Y+1	; 0x01
    4f38:	81 30       	cpi	r24, 0x01	; 1
    4f3a:	51 f4       	brne	.+20     	; 0x4f50 <vTaskStartScheduler+0x58>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    4f3c:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    4f3e:	81 e0       	ldi	r24, 0x01	; 1
    4f40:	80 93 a4 07 	sts	0x07A4, r24
		xTickCount = ( TickType_t ) 0U;
    4f44:	10 92 a2 07 	sts	0x07A2, r1
    4f48:	10 92 a1 07 	sts	0x07A1, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    4f4c:	0e 94 0d 1d 	call	0x3a1a	; 0x3a1a <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    4f50:	0f 90       	pop	r0
    4f52:	cf 91       	pop	r28
    4f54:	df 91       	pop	r29
    4f56:	0f 91       	pop	r16
    4f58:	ff 90       	pop	r15
    4f5a:	ef 90       	pop	r14
    4f5c:	df 90       	pop	r13
    4f5e:	cf 90       	pop	r12
    4f60:	bf 90       	pop	r11
    4f62:	af 90       	pop	r10
    4f64:	08 95       	ret

00004f66 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4f66:	df 93       	push	r29
    4f68:	cf 93       	push	r28
    4f6a:	cd b7       	in	r28, 0x3d	; 61
    4f6c:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4f6e:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4f70:	10 92 a4 07 	sts	0x07A4, r1
	vPortEndScheduler();
    4f74:	0e 94 42 1d 	call	0x3a84	; 0x3a84 <vPortEndScheduler>
}
    4f78:	cf 91       	pop	r28
    4f7a:	df 91       	pop	r29
    4f7c:	08 95       	ret

00004f7e <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4f7e:	df 93       	push	r29
    4f80:	cf 93       	push	r28
    4f82:	cd b7       	in	r28, 0x3d	; 61
    4f84:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    4f86:	80 91 a9 07 	lds	r24, 0x07A9
    4f8a:	8f 5f       	subi	r24, 0xFF	; 255
    4f8c:	80 93 a9 07 	sts	0x07A9, r24
}
    4f90:	cf 91       	pop	r28
    4f92:	df 91       	pop	r29
    4f94:	08 95       	ret

00004f96 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    4f96:	df 93       	push	r29
    4f98:	cf 93       	push	r28
    4f9a:	00 d0       	rcall	.+0      	; 0x4f9c <xTaskResumeAll+0x6>
    4f9c:	0f 92       	push	r0
    4f9e:	cd b7       	in	r28, 0x3d	; 61
    4fa0:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    4fa2:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4fa4:	0f b6       	in	r0, 0x3f	; 63
    4fa6:	f8 94       	cli
    4fa8:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4faa:	80 91 a9 07 	lds	r24, 0x07A9
    4fae:	81 50       	subi	r24, 0x01	; 1
    4fb0:	80 93 a9 07 	sts	0x07A9, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4fb4:	80 91 a9 07 	lds	r24, 0x07A9
    4fb8:	88 23       	and	r24, r24
    4fba:	09 f0       	breq	.+2      	; 0x4fbe <xTaskResumeAll+0x28>
    4fbc:	6d c0       	rjmp	.+218    	; 0x5098 <xTaskResumeAll+0x102>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4fbe:	80 91 a0 07 	lds	r24, 0x07A0
    4fc2:	88 23       	and	r24, r24
    4fc4:	09 f4       	brne	.+2      	; 0x4fc8 <xTaskResumeAll+0x32>
    4fc6:	68 c0       	rjmp	.+208    	; 0x5098 <xTaskResumeAll+0x102>
    4fc8:	45 c0       	rjmp	.+138    	; 0x5054 <xTaskResumeAll+0xbe>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    4fca:	e0 91 e9 07 	lds	r30, 0x07E9
    4fce:	f0 91 ea 07 	lds	r31, 0x07EA
    4fd2:	86 81       	ldd	r24, Z+6	; 0x06
    4fd4:	97 81       	ldd	r25, Z+7	; 0x07
    4fd6:	9b 83       	std	Y+3, r25	; 0x03
    4fd8:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4fda:	8a 81       	ldd	r24, Y+2	; 0x02
    4fdc:	9b 81       	ldd	r25, Y+3	; 0x03
    4fde:	0c 96       	adiw	r24, 0x0c	; 12
    4fe0:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    4fe4:	8a 81       	ldd	r24, Y+2	; 0x02
    4fe6:	9b 81       	ldd	r25, Y+3	; 0x03
    4fe8:	02 96       	adiw	r24, 0x02	; 2
    4fea:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4fee:	ea 81       	ldd	r30, Y+2	; 0x02
    4ff0:	fb 81       	ldd	r31, Y+3	; 0x03
    4ff2:	96 89       	ldd	r25, Z+22	; 0x16
    4ff4:	80 91 a3 07 	lds	r24, 0x07A3
    4ff8:	89 17       	cp	r24, r25
    4ffa:	28 f4       	brcc	.+10     	; 0x5006 <xTaskResumeAll+0x70>
    4ffc:	ea 81       	ldd	r30, Y+2	; 0x02
    4ffe:	fb 81       	ldd	r31, Y+3	; 0x03
    5000:	86 89       	ldd	r24, Z+22	; 0x16
    5002:	80 93 a3 07 	sts	0x07A3, r24
    5006:	ea 81       	ldd	r30, Y+2	; 0x02
    5008:	fb 81       	ldd	r31, Y+3	; 0x03
    500a:	86 89       	ldd	r24, Z+22	; 0x16
    500c:	28 2f       	mov	r18, r24
    500e:	30 e0       	ldi	r19, 0x00	; 0
    5010:	c9 01       	movw	r24, r18
    5012:	88 0f       	add	r24, r24
    5014:	99 1f       	adc	r25, r25
    5016:	88 0f       	add	r24, r24
    5018:	99 1f       	adc	r25, r25
    501a:	88 0f       	add	r24, r24
    501c:	99 1f       	adc	r25, r25
    501e:	82 0f       	add	r24, r18
    5020:	93 1f       	adc	r25, r19
    5022:	ac 01       	movw	r20, r24
    5024:	46 55       	subi	r20, 0x56	; 86
    5026:	58 4f       	sbci	r21, 0xF8	; 248
    5028:	8a 81       	ldd	r24, Y+2	; 0x02
    502a:	9b 81       	ldd	r25, Y+3	; 0x03
    502c:	9c 01       	movw	r18, r24
    502e:	2e 5f       	subi	r18, 0xFE	; 254
    5030:	3f 4f       	sbci	r19, 0xFF	; 255
    5032:	ca 01       	movw	r24, r20
    5034:	b9 01       	movw	r22, r18
    5036:	0e 94 8e 1a 	call	0x351c	; 0x351c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    503a:	ea 81       	ldd	r30, Y+2	; 0x02
    503c:	fb 81       	ldd	r31, Y+3	; 0x03
    503e:	96 89       	ldd	r25, Z+22	; 0x16
    5040:	e0 91 9d 07 	lds	r30, 0x079D
    5044:	f0 91 9e 07 	lds	r31, 0x079E
    5048:	86 89       	ldd	r24, Z+22	; 0x16
    504a:	98 17       	cp	r25, r24
    504c:	18 f0       	brcs	.+6      	; 0x5054 <xTaskResumeAll+0xbe>
					{
						xYieldPending = pdTRUE;
    504e:	81 e0       	ldi	r24, 0x01	; 1
    5050:	80 93 a6 07 	sts	0x07A6, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    5054:	80 91 e4 07 	lds	r24, 0x07E4
    5058:	88 23       	and	r24, r24
    505a:	09 f0       	breq	.+2      	; 0x505e <xTaskResumeAll+0xc8>
    505c:	b6 cf       	rjmp	.-148    	; 0x4fca <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    505e:	80 91 a5 07 	lds	r24, 0x07A5
    5062:	88 23       	and	r24, r24
    5064:	89 f0       	breq	.+34     	; 0x5088 <xTaskResumeAll+0xf2>
    5066:	0c c0       	rjmp	.+24     	; 0x5080 <xTaskResumeAll+0xea>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    5068:	0e 94 8a 28 	call	0x5114	; 0x5114 <xTaskIncrementTick>
    506c:	88 23       	and	r24, r24
    506e:	19 f0       	breq	.+6      	; 0x5076 <xTaskResumeAll+0xe0>
						{
							xYieldPending = pdTRUE;
    5070:	81 e0       	ldi	r24, 0x01	; 1
    5072:	80 93 a6 07 	sts	0x07A6, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    5076:	80 91 a5 07 	lds	r24, 0x07A5
    507a:	81 50       	subi	r24, 0x01	; 1
    507c:	80 93 a5 07 	sts	0x07A5, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    5080:	80 91 a5 07 	lds	r24, 0x07A5
    5084:	88 23       	and	r24, r24
    5086:	81 f7       	brne	.-32     	; 0x5068 <xTaskResumeAll+0xd2>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    5088:	80 91 a6 07 	lds	r24, 0x07A6
    508c:	81 30       	cpi	r24, 0x01	; 1
    508e:	21 f4       	brne	.+8      	; 0x5098 <xTaskResumeAll+0x102>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    5090:	81 e0       	ldi	r24, 0x01	; 1
    5092:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    5094:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    5098:	0f 90       	pop	r0
    509a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    509c:	89 81       	ldd	r24, Y+1	; 0x01
}
    509e:	0f 90       	pop	r0
    50a0:	0f 90       	pop	r0
    50a2:	0f 90       	pop	r0
    50a4:	cf 91       	pop	r28
    50a6:	df 91       	pop	r29
    50a8:	08 95       	ret

000050aa <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    50aa:	df 93       	push	r29
    50ac:	cf 93       	push	r28
    50ae:	00 d0       	rcall	.+0      	; 0x50b0 <xTaskGetTickCount+0x6>
    50b0:	cd b7       	in	r28, 0x3d	; 61
    50b2:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    50b4:	0f b6       	in	r0, 0x3f	; 63
    50b6:	f8 94       	cli
    50b8:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    50ba:	80 91 a1 07 	lds	r24, 0x07A1
    50be:	90 91 a2 07 	lds	r25, 0x07A2
    50c2:	9a 83       	std	Y+2, r25	; 0x02
    50c4:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    50c6:	0f 90       	pop	r0
    50c8:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    50ca:	89 81       	ldd	r24, Y+1	; 0x01
    50cc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    50ce:	0f 90       	pop	r0
    50d0:	0f 90       	pop	r0
    50d2:	cf 91       	pop	r28
    50d4:	df 91       	pop	r29
    50d6:	08 95       	ret

000050d8 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    50d8:	df 93       	push	r29
    50da:	cf 93       	push	r28
    50dc:	00 d0       	rcall	.+0      	; 0x50de <xTaskGetTickCountFromISR+0x6>
    50de:	0f 92       	push	r0
    50e0:	cd b7       	in	r28, 0x3d	; 61
    50e2:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    50e4:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    50e6:	80 91 a1 07 	lds	r24, 0x07A1
    50ea:	90 91 a2 07 	lds	r25, 0x07A2
    50ee:	9b 83       	std	Y+3, r25	; 0x03
    50f0:	8a 83       	std	Y+2, r24	; 0x02
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    50f2:	8a 81       	ldd	r24, Y+2	; 0x02
    50f4:	9b 81       	ldd	r25, Y+3	; 0x03
}
    50f6:	0f 90       	pop	r0
    50f8:	0f 90       	pop	r0
    50fa:	0f 90       	pop	r0
    50fc:	cf 91       	pop	r28
    50fe:	df 91       	pop	r29
    5100:	08 95       	ret

00005102 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    5102:	df 93       	push	r29
    5104:	cf 93       	push	r28
    5106:	cd b7       	in	r28, 0x3d	; 61
    5108:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    510a:	80 91 a0 07 	lds	r24, 0x07A0
}
    510e:	cf 91       	pop	r28
    5110:	df 91       	pop	r29
    5112:	08 95       	ret

00005114 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    5114:	df 93       	push	r29
    5116:	cf 93       	push	r28
    5118:	cd b7       	in	r28, 0x3d	; 61
    511a:	de b7       	in	r29, 0x3e	; 62
    511c:	29 97       	sbiw	r28, 0x09	; 9
    511e:	0f b6       	in	r0, 0x3f	; 63
    5120:	f8 94       	cli
    5122:	de bf       	out	0x3e, r29	; 62
    5124:	0f be       	out	0x3f, r0	; 63
    5126:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    5128:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    512a:	80 91 a9 07 	lds	r24, 0x07A9
    512e:	88 23       	and	r24, r24
    5130:	09 f0       	breq	.+2      	; 0x5134 <xTaskIncrementTick+0x20>
    5132:	c2 c0       	rjmp	.+388    	; 0x52b8 <xTaskIncrementTick+0x1a4>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    5134:	80 91 a1 07 	lds	r24, 0x07A1
    5138:	90 91 a2 07 	lds	r25, 0x07A2
    513c:	01 96       	adiw	r24, 0x01	; 1
    513e:	90 93 a2 07 	sts	0x07A2, r25
    5142:	80 93 a1 07 	sts	0x07A1, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    5146:	80 91 a1 07 	lds	r24, 0x07A1
    514a:	90 91 a2 07 	lds	r25, 0x07A2
    514e:	9c 83       	std	Y+4, r25	; 0x04
    5150:	8b 83       	std	Y+3, r24	; 0x03

			if( xConstTickCount == ( TickType_t ) 0U )
    5152:	8b 81       	ldd	r24, Y+3	; 0x03
    5154:	9c 81       	ldd	r25, Y+4	; 0x04
    5156:	00 97       	sbiw	r24, 0x00	; 0
    5158:	d9 f4       	brne	.+54     	; 0x5190 <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    515a:	80 91 e0 07 	lds	r24, 0x07E0
    515e:	90 91 e1 07 	lds	r25, 0x07E1
    5162:	9a 83       	std	Y+2, r25	; 0x02
    5164:	89 83       	std	Y+1, r24	; 0x01
    5166:	80 91 e2 07 	lds	r24, 0x07E2
    516a:	90 91 e3 07 	lds	r25, 0x07E3
    516e:	90 93 e1 07 	sts	0x07E1, r25
    5172:	80 93 e0 07 	sts	0x07E0, r24
    5176:	89 81       	ldd	r24, Y+1	; 0x01
    5178:	9a 81       	ldd	r25, Y+2	; 0x02
    517a:	90 93 e3 07 	sts	0x07E3, r25
    517e:	80 93 e2 07 	sts	0x07E2, r24
    5182:	80 91 a7 07 	lds	r24, 0x07A7
    5186:	8f 5f       	subi	r24, 0xFF	; 255
    5188:	80 93 a7 07 	sts	0x07A7, r24
    518c:	0e 94 4a 2d 	call	0x5a94	; 0x5a94 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    5190:	20 91 7c 01 	lds	r18, 0x017C
    5194:	30 91 7d 01 	lds	r19, 0x017D
    5198:	8b 81       	ldd	r24, Y+3	; 0x03
    519a:	9c 81       	ldd	r25, Y+4	; 0x04
    519c:	82 17       	cp	r24, r18
    519e:	93 07       	cpc	r25, r19
    51a0:	08 f4       	brcc	.+2      	; 0x51a4 <xTaskIncrementTick+0x90>
    51a2:	71 c0       	rjmp	.+226    	; 0x5286 <xTaskIncrementTick+0x172>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    51a4:	e0 91 e0 07 	lds	r30, 0x07E0
    51a8:	f0 91 e1 07 	lds	r31, 0x07E1
    51ac:	80 81       	ld	r24, Z
    51ae:	88 23       	and	r24, r24
    51b0:	39 f4       	brne	.+14     	; 0x51c0 <xTaskIncrementTick+0xac>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    51b2:	8f ef       	ldi	r24, 0xFF	; 255
    51b4:	9f ef       	ldi	r25, 0xFF	; 255
    51b6:	90 93 7d 01 	sts	0x017D, r25
    51ba:	80 93 7c 01 	sts	0x017C, r24
    51be:	63 c0       	rjmp	.+198    	; 0x5286 <xTaskIncrementTick+0x172>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    51c0:	e0 91 e0 07 	lds	r30, 0x07E0
    51c4:	f0 91 e1 07 	lds	r31, 0x07E1
    51c8:	05 80       	ldd	r0, Z+5	; 0x05
    51ca:	f6 81       	ldd	r31, Z+6	; 0x06
    51cc:	e0 2d       	mov	r30, r0
    51ce:	86 81       	ldd	r24, Z+6	; 0x06
    51d0:	97 81       	ldd	r25, Z+7	; 0x07
    51d2:	99 87       	std	Y+9, r25	; 0x09
    51d4:	88 87       	std	Y+8, r24	; 0x08
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    51d6:	e8 85       	ldd	r30, Y+8	; 0x08
    51d8:	f9 85       	ldd	r31, Y+9	; 0x09
    51da:	82 81       	ldd	r24, Z+2	; 0x02
    51dc:	93 81       	ldd	r25, Z+3	; 0x03
    51de:	9f 83       	std	Y+7, r25	; 0x07
    51e0:	8e 83       	std	Y+6, r24	; 0x06

						if( xConstTickCount < xItemValue )
    51e2:	2b 81       	ldd	r18, Y+3	; 0x03
    51e4:	3c 81       	ldd	r19, Y+4	; 0x04
    51e6:	8e 81       	ldd	r24, Y+6	; 0x06
    51e8:	9f 81       	ldd	r25, Y+7	; 0x07
    51ea:	28 17       	cp	r18, r24
    51ec:	39 07       	cpc	r19, r25
    51ee:	38 f4       	brcc	.+14     	; 0x51fe <xTaskIncrementTick+0xea>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    51f0:	8e 81       	ldd	r24, Y+6	; 0x06
    51f2:	9f 81       	ldd	r25, Y+7	; 0x07
    51f4:	90 93 7d 01 	sts	0x017D, r25
    51f8:	80 93 7c 01 	sts	0x017C, r24
    51fc:	44 c0       	rjmp	.+136    	; 0x5286 <xTaskIncrementTick+0x172>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    51fe:	88 85       	ldd	r24, Y+8	; 0x08
    5200:	99 85       	ldd	r25, Y+9	; 0x09
    5202:	02 96       	adiw	r24, 0x02	; 2
    5204:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5208:	e8 85       	ldd	r30, Y+8	; 0x08
    520a:	f9 85       	ldd	r31, Y+9	; 0x09
    520c:	84 89       	ldd	r24, Z+20	; 0x14
    520e:	95 89       	ldd	r25, Z+21	; 0x15
    5210:	00 97       	sbiw	r24, 0x00	; 0
    5212:	29 f0       	breq	.+10     	; 0x521e <xTaskIncrementTick+0x10a>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5214:	88 85       	ldd	r24, Y+8	; 0x08
    5216:	99 85       	ldd	r25, Y+9	; 0x09
    5218:	0c 96       	adiw	r24, 0x0c	; 12
    521a:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    521e:	e8 85       	ldd	r30, Y+8	; 0x08
    5220:	f9 85       	ldd	r31, Y+9	; 0x09
    5222:	96 89       	ldd	r25, Z+22	; 0x16
    5224:	80 91 a3 07 	lds	r24, 0x07A3
    5228:	89 17       	cp	r24, r25
    522a:	28 f4       	brcc	.+10     	; 0x5236 <xTaskIncrementTick+0x122>
    522c:	e8 85       	ldd	r30, Y+8	; 0x08
    522e:	f9 85       	ldd	r31, Y+9	; 0x09
    5230:	86 89       	ldd	r24, Z+22	; 0x16
    5232:	80 93 a3 07 	sts	0x07A3, r24
    5236:	e8 85       	ldd	r30, Y+8	; 0x08
    5238:	f9 85       	ldd	r31, Y+9	; 0x09
    523a:	86 89       	ldd	r24, Z+22	; 0x16
    523c:	28 2f       	mov	r18, r24
    523e:	30 e0       	ldi	r19, 0x00	; 0
    5240:	c9 01       	movw	r24, r18
    5242:	88 0f       	add	r24, r24
    5244:	99 1f       	adc	r25, r25
    5246:	88 0f       	add	r24, r24
    5248:	99 1f       	adc	r25, r25
    524a:	88 0f       	add	r24, r24
    524c:	99 1f       	adc	r25, r25
    524e:	82 0f       	add	r24, r18
    5250:	93 1f       	adc	r25, r19
    5252:	ac 01       	movw	r20, r24
    5254:	46 55       	subi	r20, 0x56	; 86
    5256:	58 4f       	sbci	r21, 0xF8	; 248
    5258:	88 85       	ldd	r24, Y+8	; 0x08
    525a:	99 85       	ldd	r25, Y+9	; 0x09
    525c:	9c 01       	movw	r18, r24
    525e:	2e 5f       	subi	r18, 0xFE	; 254
    5260:	3f 4f       	sbci	r19, 0xFF	; 255
    5262:	ca 01       	movw	r24, r20
    5264:	b9 01       	movw	r22, r18
    5266:	0e 94 8e 1a 	call	0x351c	; 0x351c <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    526a:	e8 85       	ldd	r30, Y+8	; 0x08
    526c:	f9 85       	ldd	r31, Y+9	; 0x09
    526e:	96 89       	ldd	r25, Z+22	; 0x16
    5270:	e0 91 9d 07 	lds	r30, 0x079D
    5274:	f0 91 9e 07 	lds	r31, 0x079E
    5278:	86 89       	ldd	r24, Z+22	; 0x16
    527a:	98 17       	cp	r25, r24
    527c:	08 f4       	brcc	.+2      	; 0x5280 <xTaskIncrementTick+0x16c>
    527e:	92 cf       	rjmp	.-220    	; 0x51a4 <xTaskIncrementTick+0x90>
							{
								xSwitchRequired = pdTRUE;
    5280:	81 e0       	ldi	r24, 0x01	; 1
    5282:	8d 83       	std	Y+5, r24	; 0x05
    5284:	8f cf       	rjmp	.-226    	; 0x51a4 <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    5286:	e0 91 9d 07 	lds	r30, 0x079D
    528a:	f0 91 9e 07 	lds	r31, 0x079E
    528e:	86 89       	ldd	r24, Z+22	; 0x16
    5290:	28 2f       	mov	r18, r24
    5292:	30 e0       	ldi	r19, 0x00	; 0
    5294:	c9 01       	movw	r24, r18
    5296:	88 0f       	add	r24, r24
    5298:	99 1f       	adc	r25, r25
    529a:	88 0f       	add	r24, r24
    529c:	99 1f       	adc	r25, r25
    529e:	88 0f       	add	r24, r24
    52a0:	99 1f       	adc	r25, r25
    52a2:	82 0f       	add	r24, r18
    52a4:	93 1f       	adc	r25, r19
    52a6:	fc 01       	movw	r30, r24
    52a8:	e6 55       	subi	r30, 0x56	; 86
    52aa:	f8 4f       	sbci	r31, 0xF8	; 248
    52ac:	80 81       	ld	r24, Z
    52ae:	82 30       	cpi	r24, 0x02	; 2
    52b0:	40 f0       	brcs	.+16     	; 0x52c2 <xTaskIncrementTick+0x1ae>
			{
				xSwitchRequired = pdTRUE;
    52b2:	81 e0       	ldi	r24, 0x01	; 1
    52b4:	8d 83       	std	Y+5, r24	; 0x05
    52b6:	05 c0       	rjmp	.+10     	; 0x52c2 <xTaskIncrementTick+0x1ae>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    52b8:	80 91 a5 07 	lds	r24, 0x07A5
    52bc:	8f 5f       	subi	r24, 0xFF	; 255
    52be:	80 93 a5 07 	sts	0x07A5, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    52c2:	80 91 a6 07 	lds	r24, 0x07A6
    52c6:	88 23       	and	r24, r24
    52c8:	11 f0       	breq	.+4      	; 0x52ce <xTaskIncrementTick+0x1ba>
		{
			xSwitchRequired = pdTRUE;
    52ca:	81 e0       	ldi	r24, 0x01	; 1
    52cc:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    52ce:	8d 81       	ldd	r24, Y+5	; 0x05
}
    52d0:	29 96       	adiw	r28, 0x09	; 9
    52d2:	0f b6       	in	r0, 0x3f	; 63
    52d4:	f8 94       	cli
    52d6:	de bf       	out	0x3e, r29	; 62
    52d8:	0f be       	out	0x3f, r0	; 63
    52da:	cd bf       	out	0x3d, r28	; 61
    52dc:	cf 91       	pop	r28
    52de:	df 91       	pop	r29
    52e0:	08 95       	ret

000052e2 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    52e2:	df 93       	push	r29
    52e4:	cf 93       	push	r28
    52e6:	00 d0       	rcall	.+0      	; 0x52e8 <vTaskSwitchContext+0x6>
    52e8:	cd b7       	in	r28, 0x3d	; 61
    52ea:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    52ec:	80 91 a9 07 	lds	r24, 0x07A9
    52f0:	88 23       	and	r24, r24
    52f2:	21 f0       	breq	.+8      	; 0x52fc <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    52f4:	81 e0       	ldi	r24, 0x01	; 1
    52f6:	80 93 a6 07 	sts	0x07A6, r24
    52fa:	57 c0       	rjmp	.+174    	; 0x53aa <vTaskSwitchContext+0xc8>
	}
	else
	{
		xYieldPending = pdFALSE;
    52fc:	10 92 a6 07 	sts	0x07A6, r1
    5300:	05 c0       	rjmp	.+10     	; 0x530c <vTaskSwitchContext+0x2a>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    5302:	80 91 a3 07 	lds	r24, 0x07A3
    5306:	81 50       	subi	r24, 0x01	; 1
    5308:	80 93 a3 07 	sts	0x07A3, r24
    530c:	80 91 a3 07 	lds	r24, 0x07A3
    5310:	28 2f       	mov	r18, r24
    5312:	30 e0       	ldi	r19, 0x00	; 0
    5314:	c9 01       	movw	r24, r18
    5316:	88 0f       	add	r24, r24
    5318:	99 1f       	adc	r25, r25
    531a:	88 0f       	add	r24, r24
    531c:	99 1f       	adc	r25, r25
    531e:	88 0f       	add	r24, r24
    5320:	99 1f       	adc	r25, r25
    5322:	82 0f       	add	r24, r18
    5324:	93 1f       	adc	r25, r19
    5326:	fc 01       	movw	r30, r24
    5328:	e6 55       	subi	r30, 0x56	; 86
    532a:	f8 4f       	sbci	r31, 0xF8	; 248
    532c:	80 81       	ld	r24, Z
    532e:	88 23       	and	r24, r24
    5330:	41 f3       	breq	.-48     	; 0x5302 <vTaskSwitchContext+0x20>
    5332:	80 91 a3 07 	lds	r24, 0x07A3
    5336:	28 2f       	mov	r18, r24
    5338:	30 e0       	ldi	r19, 0x00	; 0
    533a:	c9 01       	movw	r24, r18
    533c:	88 0f       	add	r24, r24
    533e:	99 1f       	adc	r25, r25
    5340:	88 0f       	add	r24, r24
    5342:	99 1f       	adc	r25, r25
    5344:	88 0f       	add	r24, r24
    5346:	99 1f       	adc	r25, r25
    5348:	82 0f       	add	r24, r18
    534a:	93 1f       	adc	r25, r19
    534c:	86 55       	subi	r24, 0x56	; 86
    534e:	98 4f       	sbci	r25, 0xF8	; 248
    5350:	9a 83       	std	Y+2, r25	; 0x02
    5352:	89 83       	std	Y+1, r24	; 0x01
    5354:	e9 81       	ldd	r30, Y+1	; 0x01
    5356:	fa 81       	ldd	r31, Y+2	; 0x02
    5358:	01 80       	ldd	r0, Z+1	; 0x01
    535a:	f2 81       	ldd	r31, Z+2	; 0x02
    535c:	e0 2d       	mov	r30, r0
    535e:	82 81       	ldd	r24, Z+2	; 0x02
    5360:	93 81       	ldd	r25, Z+3	; 0x03
    5362:	e9 81       	ldd	r30, Y+1	; 0x01
    5364:	fa 81       	ldd	r31, Y+2	; 0x02
    5366:	92 83       	std	Z+2, r25	; 0x02
    5368:	81 83       	std	Z+1, r24	; 0x01
    536a:	e9 81       	ldd	r30, Y+1	; 0x01
    536c:	fa 81       	ldd	r31, Y+2	; 0x02
    536e:	21 81       	ldd	r18, Z+1	; 0x01
    5370:	32 81       	ldd	r19, Z+2	; 0x02
    5372:	89 81       	ldd	r24, Y+1	; 0x01
    5374:	9a 81       	ldd	r25, Y+2	; 0x02
    5376:	03 96       	adiw	r24, 0x03	; 3
    5378:	28 17       	cp	r18, r24
    537a:	39 07       	cpc	r19, r25
    537c:	59 f4       	brne	.+22     	; 0x5394 <vTaskSwitchContext+0xb2>
    537e:	e9 81       	ldd	r30, Y+1	; 0x01
    5380:	fa 81       	ldd	r31, Y+2	; 0x02
    5382:	01 80       	ldd	r0, Z+1	; 0x01
    5384:	f2 81       	ldd	r31, Z+2	; 0x02
    5386:	e0 2d       	mov	r30, r0
    5388:	82 81       	ldd	r24, Z+2	; 0x02
    538a:	93 81       	ldd	r25, Z+3	; 0x03
    538c:	e9 81       	ldd	r30, Y+1	; 0x01
    538e:	fa 81       	ldd	r31, Y+2	; 0x02
    5390:	92 83       	std	Z+2, r25	; 0x02
    5392:	81 83       	std	Z+1, r24	; 0x01
    5394:	e9 81       	ldd	r30, Y+1	; 0x01
    5396:	fa 81       	ldd	r31, Y+2	; 0x02
    5398:	01 80       	ldd	r0, Z+1	; 0x01
    539a:	f2 81       	ldd	r31, Z+2	; 0x02
    539c:	e0 2d       	mov	r30, r0
    539e:	86 81       	ldd	r24, Z+6	; 0x06
    53a0:	97 81       	ldd	r25, Z+7	; 0x07
    53a2:	90 93 9e 07 	sts	0x079E, r25
    53a6:	80 93 9d 07 	sts	0x079D, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    53aa:	0f 90       	pop	r0
    53ac:	0f 90       	pop	r0
    53ae:	cf 91       	pop	r28
    53b0:	df 91       	pop	r29
    53b2:	08 95       	ret

000053b4 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    53b4:	df 93       	push	r29
    53b6:	cf 93       	push	r28
    53b8:	00 d0       	rcall	.+0      	; 0x53ba <vTaskPlaceOnEventList+0x6>
    53ba:	00 d0       	rcall	.+0      	; 0x53bc <vTaskPlaceOnEventList+0x8>
    53bc:	00 d0       	rcall	.+0      	; 0x53be <vTaskPlaceOnEventList+0xa>
    53be:	cd b7       	in	r28, 0x3d	; 61
    53c0:	de b7       	in	r29, 0x3e	; 62
    53c2:	9c 83       	std	Y+4, r25	; 0x04
    53c4:	8b 83       	std	Y+3, r24	; 0x03
    53c6:	7e 83       	std	Y+6, r23	; 0x06
    53c8:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    53ca:	80 91 9d 07 	lds	r24, 0x079D
    53ce:	90 91 9e 07 	lds	r25, 0x079E
    53d2:	9c 01       	movw	r18, r24
    53d4:	24 5f       	subi	r18, 0xF4	; 244
    53d6:	3f 4f       	sbci	r19, 0xFF	; 255
    53d8:	8b 81       	ldd	r24, Y+3	; 0x03
    53da:	9c 81       	ldd	r25, Y+4	; 0x04
    53dc:	b9 01       	movw	r22, r18
    53de:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    53e2:	80 91 9d 07 	lds	r24, 0x079D
    53e6:	90 91 9e 07 	lds	r25, 0x079E
    53ea:	02 96       	adiw	r24, 0x02	; 2
    53ec:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    53f0:	20 91 a1 07 	lds	r18, 0x07A1
    53f4:	30 91 a2 07 	lds	r19, 0x07A2
    53f8:	8d 81       	ldd	r24, Y+5	; 0x05
    53fa:	9e 81       	ldd	r25, Y+6	; 0x06
    53fc:	82 0f       	add	r24, r18
    53fe:	93 1f       	adc	r25, r19
    5400:	9a 83       	std	Y+2, r25	; 0x02
    5402:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    5404:	89 81       	ldd	r24, Y+1	; 0x01
    5406:	9a 81       	ldd	r25, Y+2	; 0x02
    5408:	0e 94 a7 2c 	call	0x594e	; 0x594e <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    540c:	26 96       	adiw	r28, 0x06	; 6
    540e:	0f b6       	in	r0, 0x3f	; 63
    5410:	f8 94       	cli
    5412:	de bf       	out	0x3e, r29	; 62
    5414:	0f be       	out	0x3f, r0	; 63
    5416:	cd bf       	out	0x3d, r28	; 61
    5418:	cf 91       	pop	r28
    541a:	df 91       	pop	r29
    541c:	08 95       	ret

0000541e <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    541e:	df 93       	push	r29
    5420:	cf 93       	push	r28
    5422:	cd b7       	in	r28, 0x3d	; 61
    5424:	de b7       	in	r29, 0x3e	; 62
    5426:	28 97       	sbiw	r28, 0x08	; 8
    5428:	0f b6       	in	r0, 0x3f	; 63
    542a:	f8 94       	cli
    542c:	de bf       	out	0x3e, r29	; 62
    542e:	0f be       	out	0x3f, r0	; 63
    5430:	cd bf       	out	0x3d, r28	; 61
    5432:	9c 83       	std	Y+4, r25	; 0x04
    5434:	8b 83       	std	Y+3, r24	; 0x03
    5436:	7e 83       	std	Y+6, r23	; 0x06
    5438:	6d 83       	std	Y+5, r22	; 0x05
    543a:	58 87       	std	Y+8, r21	; 0x08
    543c:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    543e:	e0 91 9d 07 	lds	r30, 0x079D
    5442:	f0 91 9e 07 	lds	r31, 0x079E
    5446:	8d 81       	ldd	r24, Y+5	; 0x05
    5448:	9e 81       	ldd	r25, Y+6	; 0x06
    544a:	90 68       	ori	r25, 0x80	; 128
    544c:	95 87       	std	Z+13, r25	; 0x0d
    544e:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5450:	80 91 9d 07 	lds	r24, 0x079D
    5454:	90 91 9e 07 	lds	r25, 0x079E
    5458:	9c 01       	movw	r18, r24
    545a:	24 5f       	subi	r18, 0xF4	; 244
    545c:	3f 4f       	sbci	r19, 0xFF	; 255
    545e:	8b 81       	ldd	r24, Y+3	; 0x03
    5460:	9c 81       	ldd	r25, Y+4	; 0x04
    5462:	b9 01       	movw	r22, r18
    5464:	0e 94 8e 1a 	call	0x351c	; 0x351c <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    5468:	80 91 9d 07 	lds	r24, 0x079D
    546c:	90 91 9e 07 	lds	r25, 0x079E
    5470:	02 96       	adiw	r24, 0x02	; 2
    5472:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    5476:	20 91 a1 07 	lds	r18, 0x07A1
    547a:	30 91 a2 07 	lds	r19, 0x07A2
    547e:	8f 81       	ldd	r24, Y+7	; 0x07
    5480:	98 85       	ldd	r25, Y+8	; 0x08
    5482:	82 0f       	add	r24, r18
    5484:	93 1f       	adc	r25, r19
    5486:	9a 83       	std	Y+2, r25	; 0x02
    5488:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    548a:	89 81       	ldd	r24, Y+1	; 0x01
    548c:	9a 81       	ldd	r25, Y+2	; 0x02
    548e:	0e 94 a7 2c 	call	0x594e	; 0x594e <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5492:	28 96       	adiw	r28, 0x08	; 8
    5494:	0f b6       	in	r0, 0x3f	; 63
    5496:	f8 94       	cli
    5498:	de bf       	out	0x3e, r29	; 62
    549a:	0f be       	out	0x3f, r0	; 63
    549c:	cd bf       	out	0x3d, r28	; 61
    549e:	cf 91       	pop	r28
    54a0:	df 91       	pop	r29
    54a2:	08 95       	ret

000054a4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    54a4:	df 93       	push	r29
    54a6:	cf 93       	push	r28
    54a8:	00 d0       	rcall	.+0      	; 0x54aa <xTaskRemoveFromEventList+0x6>
    54aa:	00 d0       	rcall	.+0      	; 0x54ac <xTaskRemoveFromEventList+0x8>
    54ac:	0f 92       	push	r0
    54ae:	cd b7       	in	r28, 0x3d	; 61
    54b0:	de b7       	in	r29, 0x3e	; 62
    54b2:	9d 83       	std	Y+5, r25	; 0x05
    54b4:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    54b6:	ec 81       	ldd	r30, Y+4	; 0x04
    54b8:	fd 81       	ldd	r31, Y+5	; 0x05
    54ba:	05 80       	ldd	r0, Z+5	; 0x05
    54bc:	f6 81       	ldd	r31, Z+6	; 0x06
    54be:	e0 2d       	mov	r30, r0
    54c0:	86 81       	ldd	r24, Z+6	; 0x06
    54c2:	97 81       	ldd	r25, Z+7	; 0x07
    54c4:	9b 83       	std	Y+3, r25	; 0x03
    54c6:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    54c8:	8a 81       	ldd	r24, Y+2	; 0x02
    54ca:	9b 81       	ldd	r25, Y+3	; 0x03
    54cc:	0c 96       	adiw	r24, 0x0c	; 12
    54ce:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    54d2:	80 91 a9 07 	lds	r24, 0x07A9
    54d6:	88 23       	and	r24, r24
    54d8:	61 f5       	brne	.+88     	; 0x5532 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    54da:	8a 81       	ldd	r24, Y+2	; 0x02
    54dc:	9b 81       	ldd	r25, Y+3	; 0x03
    54de:	02 96       	adiw	r24, 0x02	; 2
    54e0:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    54e4:	ea 81       	ldd	r30, Y+2	; 0x02
    54e6:	fb 81       	ldd	r31, Y+3	; 0x03
    54e8:	96 89       	ldd	r25, Z+22	; 0x16
    54ea:	80 91 a3 07 	lds	r24, 0x07A3
    54ee:	89 17       	cp	r24, r25
    54f0:	28 f4       	brcc	.+10     	; 0x54fc <xTaskRemoveFromEventList+0x58>
    54f2:	ea 81       	ldd	r30, Y+2	; 0x02
    54f4:	fb 81       	ldd	r31, Y+3	; 0x03
    54f6:	86 89       	ldd	r24, Z+22	; 0x16
    54f8:	80 93 a3 07 	sts	0x07A3, r24
    54fc:	ea 81       	ldd	r30, Y+2	; 0x02
    54fe:	fb 81       	ldd	r31, Y+3	; 0x03
    5500:	86 89       	ldd	r24, Z+22	; 0x16
    5502:	28 2f       	mov	r18, r24
    5504:	30 e0       	ldi	r19, 0x00	; 0
    5506:	c9 01       	movw	r24, r18
    5508:	88 0f       	add	r24, r24
    550a:	99 1f       	adc	r25, r25
    550c:	88 0f       	add	r24, r24
    550e:	99 1f       	adc	r25, r25
    5510:	88 0f       	add	r24, r24
    5512:	99 1f       	adc	r25, r25
    5514:	82 0f       	add	r24, r18
    5516:	93 1f       	adc	r25, r19
    5518:	ac 01       	movw	r20, r24
    551a:	46 55       	subi	r20, 0x56	; 86
    551c:	58 4f       	sbci	r21, 0xF8	; 248
    551e:	8a 81       	ldd	r24, Y+2	; 0x02
    5520:	9b 81       	ldd	r25, Y+3	; 0x03
    5522:	9c 01       	movw	r18, r24
    5524:	2e 5f       	subi	r18, 0xFE	; 254
    5526:	3f 4f       	sbci	r19, 0xFF	; 255
    5528:	ca 01       	movw	r24, r20
    552a:	b9 01       	movw	r22, r18
    552c:	0e 94 8e 1a 	call	0x351c	; 0x351c <vListInsertEnd>
    5530:	0a c0       	rjmp	.+20     	; 0x5546 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    5532:	8a 81       	ldd	r24, Y+2	; 0x02
    5534:	9b 81       	ldd	r25, Y+3	; 0x03
    5536:	9c 01       	movw	r18, r24
    5538:	24 5f       	subi	r18, 0xF4	; 244
    553a:	3f 4f       	sbci	r19, 0xFF	; 255
    553c:	84 ee       	ldi	r24, 0xE4	; 228
    553e:	97 e0       	ldi	r25, 0x07	; 7
    5540:	b9 01       	movw	r22, r18
    5542:	0e 94 8e 1a 	call	0x351c	; 0x351c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5546:	ea 81       	ldd	r30, Y+2	; 0x02
    5548:	fb 81       	ldd	r31, Y+3	; 0x03
    554a:	96 89       	ldd	r25, Z+22	; 0x16
    554c:	e0 91 9d 07 	lds	r30, 0x079D
    5550:	f0 91 9e 07 	lds	r31, 0x079E
    5554:	86 89       	ldd	r24, Z+22	; 0x16
    5556:	89 17       	cp	r24, r25
    5558:	30 f4       	brcc	.+12     	; 0x5566 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    555a:	81 e0       	ldi	r24, 0x01	; 1
    555c:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    555e:	81 e0       	ldi	r24, 0x01	; 1
    5560:	80 93 a6 07 	sts	0x07A6, r24
    5564:	01 c0       	rjmp	.+2      	; 0x5568 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    5566:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5568:	89 81       	ldd	r24, Y+1	; 0x01
}
    556a:	0f 90       	pop	r0
    556c:	0f 90       	pop	r0
    556e:	0f 90       	pop	r0
    5570:	0f 90       	pop	r0
    5572:	0f 90       	pop	r0
    5574:	cf 91       	pop	r28
    5576:	df 91       	pop	r29
    5578:	08 95       	ret

0000557a <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    557a:	df 93       	push	r29
    557c:	cf 93       	push	r28
    557e:	cd b7       	in	r28, 0x3d	; 61
    5580:	de b7       	in	r29, 0x3e	; 62
    5582:	27 97       	sbiw	r28, 0x07	; 7
    5584:	0f b6       	in	r0, 0x3f	; 63
    5586:	f8 94       	cli
    5588:	de bf       	out	0x3e, r29	; 62
    558a:	0f be       	out	0x3f, r0	; 63
    558c:	cd bf       	out	0x3d, r28	; 61
    558e:	9d 83       	std	Y+5, r25	; 0x05
    5590:	8c 83       	std	Y+4, r24	; 0x04
    5592:	7f 83       	std	Y+7, r23	; 0x07
    5594:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5596:	8e 81       	ldd	r24, Y+6	; 0x06
    5598:	9f 81       	ldd	r25, Y+7	; 0x07
    559a:	90 68       	ori	r25, 0x80	; 128
    559c:	ec 81       	ldd	r30, Y+4	; 0x04
    559e:	fd 81       	ldd	r31, Y+5	; 0x05
    55a0:	91 83       	std	Z+1, r25	; 0x01
    55a2:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    55a4:	ec 81       	ldd	r30, Y+4	; 0x04
    55a6:	fd 81       	ldd	r31, Y+5	; 0x05
    55a8:	86 81       	ldd	r24, Z+6	; 0x06
    55aa:	97 81       	ldd	r25, Z+7	; 0x07
    55ac:	9b 83       	std	Y+3, r25	; 0x03
    55ae:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    55b0:	8c 81       	ldd	r24, Y+4	; 0x04
    55b2:	9d 81       	ldd	r25, Y+5	; 0x05
    55b4:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    55b8:	8a 81       	ldd	r24, Y+2	; 0x02
    55ba:	9b 81       	ldd	r25, Y+3	; 0x03
    55bc:	02 96       	adiw	r24, 0x02	; 2
    55be:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    55c2:	ea 81       	ldd	r30, Y+2	; 0x02
    55c4:	fb 81       	ldd	r31, Y+3	; 0x03
    55c6:	96 89       	ldd	r25, Z+22	; 0x16
    55c8:	80 91 a3 07 	lds	r24, 0x07A3
    55cc:	89 17       	cp	r24, r25
    55ce:	28 f4       	brcc	.+10     	; 0x55da <xTaskRemoveFromUnorderedEventList+0x60>
    55d0:	ea 81       	ldd	r30, Y+2	; 0x02
    55d2:	fb 81       	ldd	r31, Y+3	; 0x03
    55d4:	86 89       	ldd	r24, Z+22	; 0x16
    55d6:	80 93 a3 07 	sts	0x07A3, r24
    55da:	ea 81       	ldd	r30, Y+2	; 0x02
    55dc:	fb 81       	ldd	r31, Y+3	; 0x03
    55de:	86 89       	ldd	r24, Z+22	; 0x16
    55e0:	28 2f       	mov	r18, r24
    55e2:	30 e0       	ldi	r19, 0x00	; 0
    55e4:	c9 01       	movw	r24, r18
    55e6:	88 0f       	add	r24, r24
    55e8:	99 1f       	adc	r25, r25
    55ea:	88 0f       	add	r24, r24
    55ec:	99 1f       	adc	r25, r25
    55ee:	88 0f       	add	r24, r24
    55f0:	99 1f       	adc	r25, r25
    55f2:	82 0f       	add	r24, r18
    55f4:	93 1f       	adc	r25, r19
    55f6:	ac 01       	movw	r20, r24
    55f8:	46 55       	subi	r20, 0x56	; 86
    55fa:	58 4f       	sbci	r21, 0xF8	; 248
    55fc:	8a 81       	ldd	r24, Y+2	; 0x02
    55fe:	9b 81       	ldd	r25, Y+3	; 0x03
    5600:	9c 01       	movw	r18, r24
    5602:	2e 5f       	subi	r18, 0xFE	; 254
    5604:	3f 4f       	sbci	r19, 0xFF	; 255
    5606:	ca 01       	movw	r24, r20
    5608:	b9 01       	movw	r22, r18
    560a:	0e 94 8e 1a 	call	0x351c	; 0x351c <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    560e:	ea 81       	ldd	r30, Y+2	; 0x02
    5610:	fb 81       	ldd	r31, Y+3	; 0x03
    5612:	96 89       	ldd	r25, Z+22	; 0x16
    5614:	e0 91 9d 07 	lds	r30, 0x079D
    5618:	f0 91 9e 07 	lds	r31, 0x079E
    561c:	86 89       	ldd	r24, Z+22	; 0x16
    561e:	89 17       	cp	r24, r25
    5620:	30 f4       	brcc	.+12     	; 0x562e <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    5622:	81 e0       	ldi	r24, 0x01	; 1
    5624:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    5626:	81 e0       	ldi	r24, 0x01	; 1
    5628:	80 93 a6 07 	sts	0x07A6, r24
    562c:	01 c0       	rjmp	.+2      	; 0x5630 <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    562e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5630:	89 81       	ldd	r24, Y+1	; 0x01
}
    5632:	27 96       	adiw	r28, 0x07	; 7
    5634:	0f b6       	in	r0, 0x3f	; 63
    5636:	f8 94       	cli
    5638:	de bf       	out	0x3e, r29	; 62
    563a:	0f be       	out	0x3f, r0	; 63
    563c:	cd bf       	out	0x3d, r28	; 61
    563e:	cf 91       	pop	r28
    5640:	df 91       	pop	r29
    5642:	08 95       	ret

00005644 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5644:	df 93       	push	r29
    5646:	cf 93       	push	r28
    5648:	00 d0       	rcall	.+0      	; 0x564a <vTaskSetTimeOutState+0x6>
    564a:	cd b7       	in	r28, 0x3d	; 61
    564c:	de b7       	in	r29, 0x3e	; 62
    564e:	9a 83       	std	Y+2, r25	; 0x02
    5650:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5652:	80 91 a7 07 	lds	r24, 0x07A7
    5656:	e9 81       	ldd	r30, Y+1	; 0x01
    5658:	fa 81       	ldd	r31, Y+2	; 0x02
    565a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    565c:	80 91 a1 07 	lds	r24, 0x07A1
    5660:	90 91 a2 07 	lds	r25, 0x07A2
    5664:	e9 81       	ldd	r30, Y+1	; 0x01
    5666:	fa 81       	ldd	r31, Y+2	; 0x02
    5668:	92 83       	std	Z+2, r25	; 0x02
    566a:	81 83       	std	Z+1, r24	; 0x01
}
    566c:	0f 90       	pop	r0
    566e:	0f 90       	pop	r0
    5670:	cf 91       	pop	r28
    5672:	df 91       	pop	r29
    5674:	08 95       	ret

00005676 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    5676:	df 93       	push	r29
    5678:	cf 93       	push	r28
    567a:	cd b7       	in	r28, 0x3d	; 61
    567c:	de b7       	in	r29, 0x3e	; 62
    567e:	27 97       	sbiw	r28, 0x07	; 7
    5680:	0f b6       	in	r0, 0x3f	; 63
    5682:	f8 94       	cli
    5684:	de bf       	out	0x3e, r29	; 62
    5686:	0f be       	out	0x3f, r0	; 63
    5688:	cd bf       	out	0x3d, r28	; 61
    568a:	9d 83       	std	Y+5, r25	; 0x05
    568c:	8c 83       	std	Y+4, r24	; 0x04
    568e:	7f 83       	std	Y+7, r23	; 0x07
    5690:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5692:	0f b6       	in	r0, 0x3f	; 63
    5694:	f8 94       	cli
    5696:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    5698:	80 91 a1 07 	lds	r24, 0x07A1
    569c:	90 91 a2 07 	lds	r25, 0x07A2
    56a0:	9a 83       	std	Y+2, r25	; 0x02
    56a2:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    56a4:	ec 81       	ldd	r30, Y+4	; 0x04
    56a6:	fd 81       	ldd	r31, Y+5	; 0x05
    56a8:	90 81       	ld	r25, Z
    56aa:	80 91 a7 07 	lds	r24, 0x07A7
    56ae:	98 17       	cp	r25, r24
    56b0:	61 f0       	breq	.+24     	; 0x56ca <xTaskCheckForTimeOut+0x54>
    56b2:	ec 81       	ldd	r30, Y+4	; 0x04
    56b4:	fd 81       	ldd	r31, Y+5	; 0x05
    56b6:	21 81       	ldd	r18, Z+1	; 0x01
    56b8:	32 81       	ldd	r19, Z+2	; 0x02
    56ba:	89 81       	ldd	r24, Y+1	; 0x01
    56bc:	9a 81       	ldd	r25, Y+2	; 0x02
    56be:	82 17       	cp	r24, r18
    56c0:	93 07       	cpc	r25, r19
    56c2:	18 f0       	brcs	.+6      	; 0x56ca <xTaskCheckForTimeOut+0x54>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    56c4:	81 e0       	ldi	r24, 0x01	; 1
    56c6:	8b 83       	std	Y+3, r24	; 0x03
    56c8:	2d c0       	rjmp	.+90     	; 0x5724 <xTaskCheckForTimeOut+0xae>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    56ca:	ec 81       	ldd	r30, Y+4	; 0x04
    56cc:	fd 81       	ldd	r31, Y+5	; 0x05
    56ce:	21 81       	ldd	r18, Z+1	; 0x01
    56d0:	32 81       	ldd	r19, Z+2	; 0x02
    56d2:	89 81       	ldd	r24, Y+1	; 0x01
    56d4:	9a 81       	ldd	r25, Y+2	; 0x02
    56d6:	ac 01       	movw	r20, r24
    56d8:	42 1b       	sub	r20, r18
    56da:	53 0b       	sbc	r21, r19
    56dc:	9a 01       	movw	r18, r20
    56de:	ee 81       	ldd	r30, Y+6	; 0x06
    56e0:	ff 81       	ldd	r31, Y+7	; 0x07
    56e2:	80 81       	ld	r24, Z
    56e4:	91 81       	ldd	r25, Z+1	; 0x01
    56e6:	28 17       	cp	r18, r24
    56e8:	39 07       	cpc	r19, r25
    56ea:	d0 f4       	brcc	.+52     	; 0x5720 <xTaskCheckForTimeOut+0xaa>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    56ec:	ee 81       	ldd	r30, Y+6	; 0x06
    56ee:	ff 81       	ldd	r31, Y+7	; 0x07
    56f0:	40 81       	ld	r20, Z
    56f2:	51 81       	ldd	r21, Z+1	; 0x01
    56f4:	ec 81       	ldd	r30, Y+4	; 0x04
    56f6:	fd 81       	ldd	r31, Y+5	; 0x05
    56f8:	21 81       	ldd	r18, Z+1	; 0x01
    56fa:	32 81       	ldd	r19, Z+2	; 0x02
    56fc:	89 81       	ldd	r24, Y+1	; 0x01
    56fe:	9a 81       	ldd	r25, Y+2	; 0x02
    5700:	b9 01       	movw	r22, r18
    5702:	68 1b       	sub	r22, r24
    5704:	79 0b       	sbc	r23, r25
    5706:	cb 01       	movw	r24, r22
    5708:	84 0f       	add	r24, r20
    570a:	95 1f       	adc	r25, r21
    570c:	ee 81       	ldd	r30, Y+6	; 0x06
    570e:	ff 81       	ldd	r31, Y+7	; 0x07
    5710:	91 83       	std	Z+1, r25	; 0x01
    5712:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    5714:	8c 81       	ldd	r24, Y+4	; 0x04
    5716:	9d 81       	ldd	r25, Y+5	; 0x05
    5718:	0e 94 22 2b 	call	0x5644	; 0x5644 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    571c:	1b 82       	std	Y+3, r1	; 0x03
    571e:	02 c0       	rjmp	.+4      	; 0x5724 <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			xReturn = pdTRUE;
    5720:	81 e0       	ldi	r24, 0x01	; 1
    5722:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    5724:	0f 90       	pop	r0
    5726:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5728:	8b 81       	ldd	r24, Y+3	; 0x03
}
    572a:	27 96       	adiw	r28, 0x07	; 7
    572c:	0f b6       	in	r0, 0x3f	; 63
    572e:	f8 94       	cli
    5730:	de bf       	out	0x3e, r29	; 62
    5732:	0f be       	out	0x3f, r0	; 63
    5734:	cd bf       	out	0x3d, r28	; 61
    5736:	cf 91       	pop	r28
    5738:	df 91       	pop	r29
    573a:	08 95       	ret

0000573c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    573c:	df 93       	push	r29
    573e:	cf 93       	push	r28
    5740:	cd b7       	in	r28, 0x3d	; 61
    5742:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    5744:	81 e0       	ldi	r24, 0x01	; 1
    5746:	80 93 a6 07 	sts	0x07A6, r24
}
    574a:	cf 91       	pop	r28
    574c:	df 91       	pop	r29
    574e:	08 95       	ret

00005750 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5750:	df 93       	push	r29
    5752:	cf 93       	push	r28
    5754:	00 d0       	rcall	.+0      	; 0x5756 <prvIdleTask+0x6>
    5756:	cd b7       	in	r28, 0x3d	; 61
    5758:	de b7       	in	r29, 0x3e	; 62
    575a:	9a 83       	std	Y+2, r25	; 0x02
    575c:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    575e:	0e 94 68 2c 	call	0x58d0	; 0x58d0 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    5762:	80 91 aa 07 	lds	r24, 0x07AA
    5766:	82 30       	cpi	r24, 0x02	; 2
    5768:	d0 f3       	brcs	.-12     	; 0x575e <prvIdleTask+0xe>
			{
				taskYIELD();
    576a:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <vPortYield>
    576e:	f7 cf       	rjmp	.-18     	; 0x575e <prvIdleTask+0xe>

00005770 <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    5770:	0f 93       	push	r16
    5772:	1f 93       	push	r17
    5774:	df 93       	push	r29
    5776:	cf 93       	push	r28
    5778:	cd b7       	in	r28, 0x3d	; 61
    577a:	de b7       	in	r29, 0x3e	; 62
    577c:	2a 97       	sbiw	r28, 0x0a	; 10
    577e:	0f b6       	in	r0, 0x3f	; 63
    5780:	f8 94       	cli
    5782:	de bf       	out	0x3e, r29	; 62
    5784:	0f be       	out	0x3f, r0	; 63
    5786:	cd bf       	out	0x3d, r28	; 61
    5788:	9b 83       	std	Y+3, r25	; 0x03
    578a:	8a 83       	std	Y+2, r24	; 0x02
    578c:	7d 83       	std	Y+5, r23	; 0x05
    578e:	6c 83       	std	Y+4, r22	; 0x04
    5790:	4e 83       	std	Y+6, r20	; 0x06
    5792:	38 87       	std	Y+8, r19	; 0x08
    5794:	2f 83       	std	Y+7, r18	; 0x07
    5796:	1a 87       	std	Y+10, r17	; 0x0a
    5798:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    579a:	19 82       	std	Y+1, r1	; 0x01
    579c:	21 c0       	rjmp	.+66     	; 0x57e0 <prvInitialiseTCBVariables+0x70>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    579e:	89 81       	ldd	r24, Y+1	; 0x01
    57a0:	48 2f       	mov	r20, r24
    57a2:	50 e0       	ldi	r21, 0x00	; 0
    57a4:	89 81       	ldd	r24, Y+1	; 0x01
    57a6:	28 2f       	mov	r18, r24
    57a8:	30 e0       	ldi	r19, 0x00	; 0
    57aa:	8c 81       	ldd	r24, Y+4	; 0x04
    57ac:	9d 81       	ldd	r25, Y+5	; 0x05
    57ae:	fc 01       	movw	r30, r24
    57b0:	e2 0f       	add	r30, r18
    57b2:	f3 1f       	adc	r31, r19
    57b4:	20 81       	ld	r18, Z
    57b6:	8a 81       	ldd	r24, Y+2	; 0x02
    57b8:	9b 81       	ldd	r25, Y+3	; 0x03
    57ba:	84 0f       	add	r24, r20
    57bc:	95 1f       	adc	r25, r21
    57be:	fc 01       	movw	r30, r24
    57c0:	79 96       	adiw	r30, 0x19	; 25
    57c2:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    57c4:	89 81       	ldd	r24, Y+1	; 0x01
    57c6:	28 2f       	mov	r18, r24
    57c8:	30 e0       	ldi	r19, 0x00	; 0
    57ca:	8c 81       	ldd	r24, Y+4	; 0x04
    57cc:	9d 81       	ldd	r25, Y+5	; 0x05
    57ce:	fc 01       	movw	r30, r24
    57d0:	e2 0f       	add	r30, r18
    57d2:	f3 1f       	adc	r31, r19
    57d4:	80 81       	ld	r24, Z
    57d6:	88 23       	and	r24, r24
    57d8:	31 f0       	breq	.+12     	; 0x57e6 <prvInitialiseTCBVariables+0x76>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    57da:	89 81       	ldd	r24, Y+1	; 0x01
    57dc:	8f 5f       	subi	r24, 0xFF	; 255
    57de:	89 83       	std	Y+1, r24	; 0x01
    57e0:	89 81       	ldd	r24, Y+1	; 0x01
    57e2:	84 31       	cpi	r24, 0x14	; 20
    57e4:	e0 f2       	brcs	.-72     	; 0x579e <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    57e6:	ea 81       	ldd	r30, Y+2	; 0x02
    57e8:	fb 81       	ldd	r31, Y+3	; 0x03
    57ea:	14 a6       	std	Z+44, r1	; 0x2c

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    57ec:	8e 81       	ldd	r24, Y+6	; 0x06
    57ee:	84 30       	cpi	r24, 0x04	; 4
    57f0:	10 f0       	brcs	.+4      	; 0x57f6 <prvInitialiseTCBVariables+0x86>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    57f2:	83 e0       	ldi	r24, 0x03	; 3
    57f4:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    57f6:	ea 81       	ldd	r30, Y+2	; 0x02
    57f8:	fb 81       	ldd	r31, Y+3	; 0x03
    57fa:	8e 81       	ldd	r24, Y+6	; 0x06
    57fc:	86 8b       	std	Z+22, r24	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    57fe:	8a 81       	ldd	r24, Y+2	; 0x02
    5800:	9b 81       	ldd	r25, Y+3	; 0x03
    5802:	02 96       	adiw	r24, 0x02	; 2
    5804:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    5808:	8a 81       	ldd	r24, Y+2	; 0x02
    580a:	9b 81       	ldd	r25, Y+3	; 0x03
    580c:	0c 96       	adiw	r24, 0x0c	; 12
    580e:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    5812:	ea 81       	ldd	r30, Y+2	; 0x02
    5814:	fb 81       	ldd	r31, Y+3	; 0x03
    5816:	8a 81       	ldd	r24, Y+2	; 0x02
    5818:	9b 81       	ldd	r25, Y+3	; 0x03
    581a:	91 87       	std	Z+9, r25	; 0x09
    581c:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    581e:	8e 81       	ldd	r24, Y+6	; 0x06
    5820:	28 2f       	mov	r18, r24
    5822:	30 e0       	ldi	r19, 0x00	; 0
    5824:	84 e0       	ldi	r24, 0x04	; 4
    5826:	90 e0       	ldi	r25, 0x00	; 0
    5828:	82 1b       	sub	r24, r18
    582a:	93 0b       	sbc	r25, r19
    582c:	ea 81       	ldd	r30, Y+2	; 0x02
    582e:	fb 81       	ldd	r31, Y+3	; 0x03
    5830:	95 87       	std	Z+13, r25	; 0x0d
    5832:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    5834:	ea 81       	ldd	r30, Y+2	; 0x02
    5836:	fb 81       	ldd	r31, Y+3	; 0x03
    5838:	8a 81       	ldd	r24, Y+2	; 0x02
    583a:	9b 81       	ldd	r25, Y+3	; 0x03
    583c:	93 8b       	std	Z+19, r25	; 0x13
    583e:	82 8b       	std	Z+18, r24	; 0x12
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    5840:	2a 96       	adiw	r28, 0x0a	; 10
    5842:	0f b6       	in	r0, 0x3f	; 63
    5844:	f8 94       	cli
    5846:	de bf       	out	0x3e, r29	; 62
    5848:	0f be       	out	0x3f, r0	; 63
    584a:	cd bf       	out	0x3d, r28	; 61
    584c:	cf 91       	pop	r28
    584e:	df 91       	pop	r29
    5850:	1f 91       	pop	r17
    5852:	0f 91       	pop	r16
    5854:	08 95       	ret

00005856 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    5856:	df 93       	push	r29
    5858:	cf 93       	push	r28
    585a:	0f 92       	push	r0
    585c:	cd b7       	in	r28, 0x3d	; 61
    585e:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5860:	19 82       	std	Y+1, r1	; 0x01
    5862:	13 c0       	rjmp	.+38     	; 0x588a <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    5864:	89 81       	ldd	r24, Y+1	; 0x01
    5866:	28 2f       	mov	r18, r24
    5868:	30 e0       	ldi	r19, 0x00	; 0
    586a:	c9 01       	movw	r24, r18
    586c:	88 0f       	add	r24, r24
    586e:	99 1f       	adc	r25, r25
    5870:	88 0f       	add	r24, r24
    5872:	99 1f       	adc	r25, r25
    5874:	88 0f       	add	r24, r24
    5876:	99 1f       	adc	r25, r25
    5878:	82 0f       	add	r24, r18
    587a:	93 1f       	adc	r25, r19
    587c:	86 55       	subi	r24, 0x56	; 86
    587e:	98 4f       	sbci	r25, 0xF8	; 248
    5880:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5884:	89 81       	ldd	r24, Y+1	; 0x01
    5886:	8f 5f       	subi	r24, 0xFF	; 255
    5888:	89 83       	std	Y+1, r24	; 0x01
    588a:	89 81       	ldd	r24, Y+1	; 0x01
    588c:	84 30       	cpi	r24, 0x04	; 4
    588e:	50 f3       	brcs	.-44     	; 0x5864 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    5890:	8e ec       	ldi	r24, 0xCE	; 206
    5892:	97 e0       	ldi	r25, 0x07	; 7
    5894:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    5898:	87 ed       	ldi	r24, 0xD7	; 215
    589a:	97 e0       	ldi	r25, 0x07	; 7
    589c:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    58a0:	84 ee       	ldi	r24, 0xE4	; 228
    58a2:	97 e0       	ldi	r25, 0x07	; 7
    58a4:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    58a8:	8d ee       	ldi	r24, 0xED	; 237
    58aa:	97 e0       	ldi	r25, 0x07	; 7
    58ac:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    58b0:	8e ec       	ldi	r24, 0xCE	; 206
    58b2:	97 e0       	ldi	r25, 0x07	; 7
    58b4:	90 93 e1 07 	sts	0x07E1, r25
    58b8:	80 93 e0 07 	sts	0x07E0, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    58bc:	87 ed       	ldi	r24, 0xD7	; 215
    58be:	97 e0       	ldi	r25, 0x07	; 7
    58c0:	90 93 e3 07 	sts	0x07E3, r25
    58c4:	80 93 e2 07 	sts	0x07E2, r24
}
    58c8:	0f 90       	pop	r0
    58ca:	cf 91       	pop	r28
    58cc:	df 91       	pop	r29
    58ce:	08 95       	ret

000058d0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    58d0:	df 93       	push	r29
    58d2:	cf 93       	push	r28
    58d4:	00 d0       	rcall	.+0      	; 0x58d6 <prvCheckTasksWaitingTermination+0x6>
    58d6:	0f 92       	push	r0
    58d8:	cd b7       	in	r28, 0x3d	; 61
    58da:	de b7       	in	r29, 0x3e	; 62
    58dc:	2e c0       	rjmp	.+92     	; 0x593a <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    58de:	0e 94 bf 27 	call	0x4f7e	; 0x4f7e <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    58e2:	80 91 ed 07 	lds	r24, 0x07ED
    58e6:	1b 82       	std	Y+3, r1	; 0x03
    58e8:	88 23       	and	r24, r24
    58ea:	11 f4       	brne	.+4      	; 0x58f0 <prvCheckTasksWaitingTermination+0x20>
    58ec:	81 e0       	ldi	r24, 0x01	; 1
    58ee:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    58f0:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    58f4:	8b 81       	ldd	r24, Y+3	; 0x03
    58f6:	88 23       	and	r24, r24
    58f8:	01 f5       	brne	.+64     	; 0x593a <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    58fa:	0f b6       	in	r0, 0x3f	; 63
    58fc:	f8 94       	cli
    58fe:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    5900:	e0 91 f2 07 	lds	r30, 0x07F2
    5904:	f0 91 f3 07 	lds	r31, 0x07F3
    5908:	86 81       	ldd	r24, Z+6	; 0x06
    590a:	97 81       	ldd	r25, Z+7	; 0x07
    590c:	9a 83       	std	Y+2, r25	; 0x02
    590e:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    5910:	89 81       	ldd	r24, Y+1	; 0x01
    5912:	9a 81       	ldd	r25, Y+2	; 0x02
    5914:	02 96       	adiw	r24, 0x02	; 2
    5916:	0e 94 3e 1b 	call	0x367c	; 0x367c <uxListRemove>
					--uxCurrentNumberOfTasks;
    591a:	80 91 a0 07 	lds	r24, 0x07A0
    591e:	81 50       	subi	r24, 0x01	; 1
    5920:	80 93 a0 07 	sts	0x07A0, r24
					--uxTasksDeleted;
    5924:	80 91 9f 07 	lds	r24, 0x079F
    5928:	81 50       	subi	r24, 0x01	; 1
    592a:	80 93 9f 07 	sts	0x079F, r24
				}
				taskEXIT_CRITICAL();
    592e:	0f 90       	pop	r0
    5930:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    5932:	89 81       	ldd	r24, Y+1	; 0x01
    5934:	9a 81       	ldd	r25, Y+2	; 0x02
    5936:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    593a:	80 91 9f 07 	lds	r24, 0x079F
    593e:	88 23       	and	r24, r24
    5940:	71 f6       	brne	.-100    	; 0x58de <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    5942:	0f 90       	pop	r0
    5944:	0f 90       	pop	r0
    5946:	0f 90       	pop	r0
    5948:	cf 91       	pop	r28
    594a:	df 91       	pop	r29
    594c:	08 95       	ret

0000594e <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    594e:	df 93       	push	r29
    5950:	cf 93       	push	r28
    5952:	00 d0       	rcall	.+0      	; 0x5954 <prvAddCurrentTaskToDelayedList+0x6>
    5954:	cd b7       	in	r28, 0x3d	; 61
    5956:	de b7       	in	r29, 0x3e	; 62
    5958:	9a 83       	std	Y+2, r25	; 0x02
    595a:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    595c:	e0 91 9d 07 	lds	r30, 0x079D
    5960:	f0 91 9e 07 	lds	r31, 0x079E
    5964:	89 81       	ldd	r24, Y+1	; 0x01
    5966:	9a 81       	ldd	r25, Y+2	; 0x02
    5968:	93 83       	std	Z+3, r25	; 0x03
    596a:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    596c:	20 91 a1 07 	lds	r18, 0x07A1
    5970:	30 91 a2 07 	lds	r19, 0x07A2
    5974:	89 81       	ldd	r24, Y+1	; 0x01
    5976:	9a 81       	ldd	r25, Y+2	; 0x02
    5978:	82 17       	cp	r24, r18
    597a:	93 07       	cpc	r25, r19
    597c:	70 f4       	brcc	.+28     	; 0x599a <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    597e:	80 91 e2 07 	lds	r24, 0x07E2
    5982:	90 91 e3 07 	lds	r25, 0x07E3
    5986:	20 91 9d 07 	lds	r18, 0x079D
    598a:	30 91 9e 07 	lds	r19, 0x079E
    598e:	2e 5f       	subi	r18, 0xFE	; 254
    5990:	3f 4f       	sbci	r19, 0xFF	; 255
    5992:	b9 01       	movw	r22, r18
    5994:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <vListInsert>
    5998:	1e c0       	rjmp	.+60     	; 0x59d6 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    599a:	40 91 e0 07 	lds	r20, 0x07E0
    599e:	50 91 e1 07 	lds	r21, 0x07E1
    59a2:	80 91 9d 07 	lds	r24, 0x079D
    59a6:	90 91 9e 07 	lds	r25, 0x079E
    59aa:	9c 01       	movw	r18, r24
    59ac:	2e 5f       	subi	r18, 0xFE	; 254
    59ae:	3f 4f       	sbci	r19, 0xFF	; 255
    59b0:	ca 01       	movw	r24, r20
    59b2:	b9 01       	movw	r22, r18
    59b4:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    59b8:	20 91 7c 01 	lds	r18, 0x017C
    59bc:	30 91 7d 01 	lds	r19, 0x017D
    59c0:	89 81       	ldd	r24, Y+1	; 0x01
    59c2:	9a 81       	ldd	r25, Y+2	; 0x02
    59c4:	82 17       	cp	r24, r18
    59c6:	93 07       	cpc	r25, r19
    59c8:	30 f4       	brcc	.+12     	; 0x59d6 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    59ca:	89 81       	ldd	r24, Y+1	; 0x01
    59cc:	9a 81       	ldd	r25, Y+2	; 0x02
    59ce:	90 93 7d 01 	sts	0x017D, r25
    59d2:	80 93 7c 01 	sts	0x017C, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    59d6:	0f 90       	pop	r0
    59d8:	0f 90       	pop	r0
    59da:	cf 91       	pop	r28
    59dc:	df 91       	pop	r29
    59de:	08 95       	ret

000059e0 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    59e0:	df 93       	push	r29
    59e2:	cf 93       	push	r28
    59e4:	cd b7       	in	r28, 0x3d	; 61
    59e6:	de b7       	in	r29, 0x3e	; 62
    59e8:	28 97       	sbiw	r28, 0x08	; 8
    59ea:	0f b6       	in	r0, 0x3f	; 63
    59ec:	f8 94       	cli
    59ee:	de bf       	out	0x3e, r29	; 62
    59f0:	0f be       	out	0x3f, r0	; 63
    59f2:	cd bf       	out	0x3d, r28	; 61
    59f4:	9c 83       	std	Y+4, r25	; 0x04
    59f6:	8b 83       	std	Y+3, r24	; 0x03
    59f8:	7e 83       	std	Y+6, r23	; 0x06
    59fa:	6d 83       	std	Y+5, r22	; 0x05
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    59fc:	8d e2       	ldi	r24, 0x2D	; 45
    59fe:	90 e0       	ldi	r25, 0x00	; 0
    5a00:	0e 94 06 19 	call	0x320c	; 0x320c <pvPortMalloc>
    5a04:	9a 83       	std	Y+2, r25	; 0x02
    5a06:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    5a08:	89 81       	ldd	r24, Y+1	; 0x01
    5a0a:	9a 81       	ldd	r25, Y+2	; 0x02
    5a0c:	00 97       	sbiw	r24, 0x00	; 0
    5a0e:	09 f1       	breq	.+66     	; 0x5a52 <prvAllocateTCBAndStack+0x72>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5a10:	8d 81       	ldd	r24, Y+5	; 0x05
    5a12:	9e 81       	ldd	r25, Y+6	; 0x06
    5a14:	00 97       	sbiw	r24, 0x00	; 0
    5a16:	39 f4       	brne	.+14     	; 0x5a26 <prvAllocateTCBAndStack+0x46>
    5a18:	8b 81       	ldd	r24, Y+3	; 0x03
    5a1a:	9c 81       	ldd	r25, Y+4	; 0x04
    5a1c:	0e 94 06 19 	call	0x320c	; 0x320c <pvPortMalloc>
    5a20:	98 87       	std	Y+8, r25	; 0x08
    5a22:	8f 83       	std	Y+7, r24	; 0x07
    5a24:	04 c0       	rjmp	.+8      	; 0x5a2e <prvAllocateTCBAndStack+0x4e>
    5a26:	8d 81       	ldd	r24, Y+5	; 0x05
    5a28:	9e 81       	ldd	r25, Y+6	; 0x06
    5a2a:	98 87       	std	Y+8, r25	; 0x08
    5a2c:	8f 83       	std	Y+7, r24	; 0x07
    5a2e:	e9 81       	ldd	r30, Y+1	; 0x01
    5a30:	fa 81       	ldd	r31, Y+2	; 0x02
    5a32:	8f 81       	ldd	r24, Y+7	; 0x07
    5a34:	98 85       	ldd	r25, Y+8	; 0x08
    5a36:	90 8f       	std	Z+24, r25	; 0x18
    5a38:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    5a3a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a3c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a3e:	87 89       	ldd	r24, Z+23	; 0x17
    5a40:	90 8d       	ldd	r25, Z+24	; 0x18
    5a42:	00 97       	sbiw	r24, 0x00	; 0
    5a44:	31 f4       	brne	.+12     	; 0x5a52 <prvAllocateTCBAndStack+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    5a46:	89 81       	ldd	r24, Y+1	; 0x01
    5a48:	9a 81       	ldd	r25, Y+2	; 0x02
    5a4a:	0e 94 5c 19 	call	0x32b8	; 0x32b8 <vPortFree>
			pxNewTCB = NULL;
    5a4e:	1a 82       	std	Y+2, r1	; 0x02
    5a50:	19 82       	std	Y+1, r1	; 0x01
			}
			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
		}
	}

	return pxNewTCB;
    5a52:	89 81       	ldd	r24, Y+1	; 0x01
    5a54:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5a56:	28 96       	adiw	r28, 0x08	; 8
    5a58:	0f b6       	in	r0, 0x3f	; 63
    5a5a:	f8 94       	cli
    5a5c:	de bf       	out	0x3e, r29	; 62
    5a5e:	0f be       	out	0x3f, r0	; 63
    5a60:	cd bf       	out	0x3d, r28	; 61
    5a62:	cf 91       	pop	r28
    5a64:	df 91       	pop	r29
    5a66:	08 95       	ret

00005a68 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    5a68:	df 93       	push	r29
    5a6a:	cf 93       	push	r28
    5a6c:	00 d0       	rcall	.+0      	; 0x5a6e <prvDeleteTCB+0x6>
    5a6e:	cd b7       	in	r28, 0x3d	; 61
    5a70:	de b7       	in	r29, 0x3e	; 62
    5a72:	9a 83       	std	Y+2, r25	; 0x02
    5a74:	89 83       	std	Y+1, r24	; 0x01
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    5a76:	e9 81       	ldd	r30, Y+1	; 0x01
    5a78:	fa 81       	ldd	r31, Y+2	; 0x02
    5a7a:	87 89       	ldd	r24, Z+23	; 0x17
    5a7c:	90 8d       	ldd	r25, Z+24	; 0x18
    5a7e:	0e 94 5c 19 	call	0x32b8	; 0x32b8 <vPortFree>
		vPortFree( pxTCB );
    5a82:	89 81       	ldd	r24, Y+1	; 0x01
    5a84:	9a 81       	ldd	r25, Y+2	; 0x02
    5a86:	0e 94 5c 19 	call	0x32b8	; 0x32b8 <vPortFree>
	}
    5a8a:	0f 90       	pop	r0
    5a8c:	0f 90       	pop	r0
    5a8e:	cf 91       	pop	r28
    5a90:	df 91       	pop	r29
    5a92:	08 95       	ret

00005a94 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    5a94:	df 93       	push	r29
    5a96:	cf 93       	push	r28
    5a98:	00 d0       	rcall	.+0      	; 0x5a9a <prvResetNextTaskUnblockTime+0x6>
    5a9a:	cd b7       	in	r28, 0x3d	; 61
    5a9c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5a9e:	e0 91 e0 07 	lds	r30, 0x07E0
    5aa2:	f0 91 e1 07 	lds	r31, 0x07E1
    5aa6:	80 81       	ld	r24, Z
    5aa8:	88 23       	and	r24, r24
    5aaa:	39 f4       	brne	.+14     	; 0x5aba <prvResetNextTaskUnblockTime+0x26>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    5aac:	8f ef       	ldi	r24, 0xFF	; 255
    5aae:	9f ef       	ldi	r25, 0xFF	; 255
    5ab0:	90 93 7d 01 	sts	0x017D, r25
    5ab4:	80 93 7c 01 	sts	0x017C, r24
    5ab8:	13 c0       	rjmp	.+38     	; 0x5ae0 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    5aba:	e0 91 e0 07 	lds	r30, 0x07E0
    5abe:	f0 91 e1 07 	lds	r31, 0x07E1
    5ac2:	05 80       	ldd	r0, Z+5	; 0x05
    5ac4:	f6 81       	ldd	r31, Z+6	; 0x06
    5ac6:	e0 2d       	mov	r30, r0
    5ac8:	86 81       	ldd	r24, Z+6	; 0x06
    5aca:	97 81       	ldd	r25, Z+7	; 0x07
    5acc:	9a 83       	std	Y+2, r25	; 0x02
    5ace:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    5ad0:	e9 81       	ldd	r30, Y+1	; 0x01
    5ad2:	fa 81       	ldd	r31, Y+2	; 0x02
    5ad4:	82 81       	ldd	r24, Z+2	; 0x02
    5ad6:	93 81       	ldd	r25, Z+3	; 0x03
    5ad8:	90 93 7d 01 	sts	0x017D, r25
    5adc:	80 93 7c 01 	sts	0x017C, r24
	}
}
    5ae0:	0f 90       	pop	r0
    5ae2:	0f 90       	pop	r0
    5ae4:	cf 91       	pop	r28
    5ae6:	df 91       	pop	r29
    5ae8:	08 95       	ret

00005aea <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    5aea:	df 93       	push	r29
    5aec:	cf 93       	push	r28
    5aee:	00 d0       	rcall	.+0      	; 0x5af0 <uxTaskResetEventItemValue+0x6>
    5af0:	cd b7       	in	r28, 0x3d	; 61
    5af2:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5af4:	e0 91 9d 07 	lds	r30, 0x079D
    5af8:	f0 91 9e 07 	lds	r31, 0x079E
    5afc:	84 85       	ldd	r24, Z+12	; 0x0c
    5afe:	95 85       	ldd	r25, Z+13	; 0x0d
    5b00:	9a 83       	std	Y+2, r25	; 0x02
    5b02:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5b04:	a0 91 9d 07 	lds	r26, 0x079D
    5b08:	b0 91 9e 07 	lds	r27, 0x079E
    5b0c:	e0 91 9d 07 	lds	r30, 0x079D
    5b10:	f0 91 9e 07 	lds	r31, 0x079E
    5b14:	86 89       	ldd	r24, Z+22	; 0x16
    5b16:	28 2f       	mov	r18, r24
    5b18:	30 e0       	ldi	r19, 0x00	; 0
    5b1a:	84 e0       	ldi	r24, 0x04	; 4
    5b1c:	90 e0       	ldi	r25, 0x00	; 0
    5b1e:	82 1b       	sub	r24, r18
    5b20:	93 0b       	sbc	r25, r19
    5b22:	1d 96       	adiw	r26, 0x0d	; 13
    5b24:	9c 93       	st	X, r25
    5b26:	8e 93       	st	-X, r24
    5b28:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    5b2a:	89 81       	ldd	r24, Y+1	; 0x01
    5b2c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5b2e:	0f 90       	pop	r0
    5b30:	0f 90       	pop	r0
    5b32:	cf 91       	pop	r28
    5b34:	df 91       	pop	r29
    5b36:	08 95       	ret

00005b38 <main>:
void T2_SmartLock( void *pvParameters);

xSemaphoreHandle		bsRes ;
char STATUS=0;

int main(void) {
    5b38:	af 92       	push	r10
    5b3a:	bf 92       	push	r11
    5b3c:	cf 92       	push	r12
    5b3e:	df 92       	push	r13
    5b40:	ef 92       	push	r14
    5b42:	ff 92       	push	r15
    5b44:	0f 93       	push	r16
    5b46:	df 93       	push	r29
    5b48:	cf 93       	push	r28
    5b4a:	cd b7       	in	r28, 0x3d	; 61
    5b4c:	de b7       	in	r29, 0x3e	; 62
	while(!(PINC&(1<<HC_ConnectionStatePin)));
    5b4e:	e3 e3       	ldi	r30, 0x33	; 51
    5b50:	f0 e0       	ldi	r31, 0x00	; 0
    5b52:	80 81       	ld	r24, Z
    5b54:	88 2f       	mov	r24, r24
    5b56:	90 e0       	ldi	r25, 0x00	; 0
    5b58:	81 70       	andi	r24, 0x01	; 1
    5b5a:	90 70       	andi	r25, 0x00	; 0
    5b5c:	00 97       	sbiw	r24, 0x00	; 0
    5b5e:	b9 f3       	breq	.-18     	; 0x5b4e <main+0x16>
	    SmartLock_Init();
    5b60:	0e 94 8f 07 	call	0xf1e	; 0xf1e <SmartLock_Init>
        bsRes= xSemaphoreCreateBinary();
    5b64:	81 e0       	ldi	r24, 0x01	; 1
    5b66:	60 e0       	ldi	r22, 0x00	; 0
    5b68:	43 e0       	ldi	r20, 0x03	; 3
    5b6a:	0e 94 e4 1e 	call	0x3dc8	; 0x3dc8 <xQueueGenericCreate>
    5b6e:	90 93 f8 07 	sts	0x07F8, r25
    5b72:	80 93 f7 07 	sts	0x07F7, r24
        xTaskCreate(T2_SmartLock,NULL,100,NULL,2,NULL);
    5b76:	88 e1       	ldi	r24, 0x18	; 24
    5b78:	9e e2       	ldi	r25, 0x2E	; 46
    5b7a:	60 e0       	ldi	r22, 0x00	; 0
    5b7c:	70 e0       	ldi	r23, 0x00	; 0
    5b7e:	44 e6       	ldi	r20, 0x64	; 100
    5b80:	50 e0       	ldi	r21, 0x00	; 0
    5b82:	20 e0       	ldi	r18, 0x00	; 0
    5b84:	30 e0       	ldi	r19, 0x00	; 0
    5b86:	02 e0       	ldi	r16, 0x02	; 2
    5b88:	ee 24       	eor	r14, r14
    5b8a:	ff 24       	eor	r15, r15
    5b8c:	cc 24       	eor	r12, r12
    5b8e:	dd 24       	eor	r13, r13
    5b90:	aa 24       	eor	r10, r10
    5b92:	bb 24       	eor	r11, r11
    5b94:	0e 94 8d 25 	call	0x4b1a	; 0x4b1a <xTaskGenericCreate>
		xTaskCreate(T1_Authentication,NULL,1000,NULL,1,NULL);
    5b98:	80 ee       	ldi	r24, 0xE0	; 224
    5b9a:	9d e2       	ldi	r25, 0x2D	; 45
    5b9c:	60 e0       	ldi	r22, 0x00	; 0
    5b9e:	70 e0       	ldi	r23, 0x00	; 0
    5ba0:	48 ee       	ldi	r20, 0xE8	; 232
    5ba2:	53 e0       	ldi	r21, 0x03	; 3
    5ba4:	20 e0       	ldi	r18, 0x00	; 0
    5ba6:	30 e0       	ldi	r19, 0x00	; 0
    5ba8:	01 e0       	ldi	r16, 0x01	; 1
    5baa:	ee 24       	eor	r14, r14
    5bac:	ff 24       	eor	r15, r15
    5bae:	cc 24       	eor	r12, r12
    5bb0:	dd 24       	eor	r13, r13
    5bb2:	aa 24       	eor	r10, r10
    5bb4:	bb 24       	eor	r11, r11
    5bb6:	0e 94 8d 25 	call	0x4b1a	; 0x4b1a <xTaskGenericCreate>
		/* Start OS or Sched */
		vTaskStartScheduler();
    5bba:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <vTaskStartScheduler>
    5bbe:	ff cf       	rjmp	.-2      	; 0x5bbe <main+0x86>

00005bc0 <T1_Authentication>:
		while(1);
}

void T1_Authentication( void *pvParameters)
{ char trails=0;
    5bc0:	df 93       	push	r29
    5bc2:	cf 93       	push	r28
    5bc4:	00 d0       	rcall	.+0      	; 0x5bc6 <T1_Authentication+0x6>
    5bc6:	0f 92       	push	r0
    5bc8:	cd b7       	in	r28, 0x3d	; 61
    5bca:	de b7       	in	r29, 0x3e	; 62
    5bcc:	9b 83       	std	Y+3, r25	; 0x03
    5bce:	8a 83       	std	Y+2, r24	; 0x02
    5bd0:	19 82       	std	Y+1, r1	; 0x01
	while(1){
		while(!(PINC&(1<<HC_ConnectionStatePin)));
    5bd2:	e3 e3       	ldi	r30, 0x33	; 51
    5bd4:	f0 e0       	ldi	r31, 0x00	; 0
    5bd6:	80 81       	ld	r24, Z
    5bd8:	88 2f       	mov	r24, r24
    5bda:	90 e0       	ldi	r25, 0x00	; 0
    5bdc:	81 70       	andi	r24, 0x01	; 1
    5bde:	90 70       	andi	r25, 0x00	; 0
    5be0:	00 97       	sbiw	r24, 0x00	; 0
    5be2:	b9 f3       	breq	.-18     	; 0x5bd2 <T1_Authentication+0x12>
		STATUS=CheckLogin();
    5be4:	0e 94 9e 08 	call	0x113c	; 0x113c <CheckLogin>
    5be8:	80 93 f6 07 	sts	0x07F6, r24
		if (STATUS==TRUE)
    5bec:	80 91 f6 07 	lds	r24, 0x07F6
    5bf0:	81 30       	cpi	r24, 0x01	; 1
    5bf2:	61 f4       	brne	.+24     	; 0x5c0c <T1_Authentication+0x4c>
		{
          xSemaphoreGive(bsRes);
    5bf4:	80 91 f7 07 	lds	r24, 0x07F7
    5bf8:	90 91 f8 07 	lds	r25, 0x07F8
    5bfc:	60 e0       	ldi	r22, 0x00	; 0
    5bfe:	70 e0       	ldi	r23, 0x00	; 0
    5c00:	40 e0       	ldi	r20, 0x00	; 0
    5c02:	50 e0       	ldi	r21, 0x00	; 0
    5c04:	20 e0       	ldi	r18, 0x00	; 0
    5c06:	0e 94 61 1f 	call	0x3ec2	; 0x3ec2 <xQueueGenericSend>
    5c0a:	0a c0       	rjmp	.+20     	; 0x5c20 <T1_Authentication+0x60>
		}
		else
		{   trails++;
    5c0c:	89 81       	ldd	r24, Y+1	; 0x01
    5c0e:	8f 5f       	subi	r24, 0xFF	; 255
    5c10:	89 83       	std	Y+1, r24	; 0x01
		    USART_SendString("Please enter correct username or password\r");
    5c12:	89 e4       	ldi	r24, 0x49	; 73
    5c14:	91 e0       	ldi	r25, 0x01	; 1
    5c16:	0e 94 4f 06 	call	0xc9e	; 0xc9e <USART_SendString>
    5c1a:	02 c0       	rjmp	.+4      	; 0x5c20 <T1_Authentication+0x60>
		}
		while(trails>=3)
		{
			Alarm();
    5c1c:	0e 94 44 10 	call	0x2088	; 0x2088 <Alarm>
		}
		else
		{   trails++;
		    USART_SendString("Please enter correct username or password\r");
		}
		while(trails>=3)
    5c20:	89 81       	ldd	r24, Y+1	; 0x01
    5c22:	83 30       	cpi	r24, 0x03	; 3
    5c24:	d8 f7       	brcc	.-10     	; 0x5c1c <T1_Authentication+0x5c>
		{
			Alarm();
		}
 		vTaskDelay(1000);
    5c26:	88 ee       	ldi	r24, 0xE8	; 232
    5c28:	93 e0       	ldi	r25, 0x03	; 3
    5c2a:	0e 94 47 27 	call	0x4e8e	; 0x4e8e <vTaskDelay>
    5c2e:	d1 cf       	rjmp	.-94     	; 0x5bd2 <T1_Authentication+0x12>

00005c30 <T2_SmartLock>:

	}}


//--------------------------------------------------
void T2_SmartLock(void* pvData){
    5c30:	df 93       	push	r29
    5c32:	cf 93       	push	r28
    5c34:	00 d0       	rcall	.+0      	; 0x5c36 <T2_SmartLock+0x6>
    5c36:	0f 92       	push	r0
    5c38:	cd b7       	in	r28, 0x3d	; 61
    5c3a:	de b7       	in	r29, 0x3e	; 62
    5c3c:	9b 83       	std	Y+3, r25	; 0x03
    5c3e:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t result = pdFALSE;
    5c40:	19 82       	std	Y+1, r1	; 0x01
	while(1){
		result = xSemaphoreTake(bsRes,1000);
    5c42:	80 91 f7 07 	lds	r24, 0x07F7
    5c46:	90 91 f8 07 	lds	r25, 0x07F8
    5c4a:	60 e0       	ldi	r22, 0x00	; 0
    5c4c:	70 e0       	ldi	r23, 0x00	; 0
    5c4e:	48 ee       	ldi	r20, 0xE8	; 232
    5c50:	53 e0       	ldi	r21, 0x03	; 3
    5c52:	20 e0       	ldi	r18, 0x00	; 0
    5c54:	0e 94 6f 20 	call	0x40de	; 0x40de <xQueueGenericReceive>
    5c58:	89 83       	std	Y+1, r24	; 0x01
				if(result == pdTRUE){
    5c5a:	89 81       	ldd	r24, Y+1	; 0x01
    5c5c:	81 30       	cpi	r24, 0x01	; 1
    5c5e:	11 f4       	brne	.+4      	; 0x5c64 <T2_SmartLock+0x34>
					SmartLock_Feature();
    5c60:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <SmartLock_Feature>
				}
     		vTaskDelay(1000);
    5c64:	88 ee       	ldi	r24, 0xE8	; 232
    5c66:	93 e0       	ldi	r25, 0x03	; 3
    5c68:	0e 94 47 27 	call	0x4e8e	; 0x4e8e <vTaskDelay>
    5c6c:	ea cf       	rjmp	.-44     	; 0x5c42 <T2_SmartLock+0x12>

00005c6e <__mulsi3>:
    5c6e:	62 9f       	mul	r22, r18
    5c70:	d0 01       	movw	r26, r0
    5c72:	73 9f       	mul	r23, r19
    5c74:	f0 01       	movw	r30, r0
    5c76:	82 9f       	mul	r24, r18
    5c78:	e0 0d       	add	r30, r0
    5c7a:	f1 1d       	adc	r31, r1
    5c7c:	64 9f       	mul	r22, r20
    5c7e:	e0 0d       	add	r30, r0
    5c80:	f1 1d       	adc	r31, r1
    5c82:	92 9f       	mul	r25, r18
    5c84:	f0 0d       	add	r31, r0
    5c86:	83 9f       	mul	r24, r19
    5c88:	f0 0d       	add	r31, r0
    5c8a:	74 9f       	mul	r23, r20
    5c8c:	f0 0d       	add	r31, r0
    5c8e:	65 9f       	mul	r22, r21
    5c90:	f0 0d       	add	r31, r0
    5c92:	99 27       	eor	r25, r25
    5c94:	72 9f       	mul	r23, r18
    5c96:	b0 0d       	add	r27, r0
    5c98:	e1 1d       	adc	r30, r1
    5c9a:	f9 1f       	adc	r31, r25
    5c9c:	63 9f       	mul	r22, r19
    5c9e:	b0 0d       	add	r27, r0
    5ca0:	e1 1d       	adc	r30, r1
    5ca2:	f9 1f       	adc	r31, r25
    5ca4:	bd 01       	movw	r22, r26
    5ca6:	cf 01       	movw	r24, r30
    5ca8:	11 24       	eor	r1, r1
    5caa:	08 95       	ret

00005cac <__udivmodsi4>:
    5cac:	a1 e2       	ldi	r26, 0x21	; 33
    5cae:	1a 2e       	mov	r1, r26
    5cb0:	aa 1b       	sub	r26, r26
    5cb2:	bb 1b       	sub	r27, r27
    5cb4:	fd 01       	movw	r30, r26
    5cb6:	0d c0       	rjmp	.+26     	; 0x5cd2 <__udivmodsi4_ep>

00005cb8 <__udivmodsi4_loop>:
    5cb8:	aa 1f       	adc	r26, r26
    5cba:	bb 1f       	adc	r27, r27
    5cbc:	ee 1f       	adc	r30, r30
    5cbe:	ff 1f       	adc	r31, r31
    5cc0:	a2 17       	cp	r26, r18
    5cc2:	b3 07       	cpc	r27, r19
    5cc4:	e4 07       	cpc	r30, r20
    5cc6:	f5 07       	cpc	r31, r21
    5cc8:	20 f0       	brcs	.+8      	; 0x5cd2 <__udivmodsi4_ep>
    5cca:	a2 1b       	sub	r26, r18
    5ccc:	b3 0b       	sbc	r27, r19
    5cce:	e4 0b       	sbc	r30, r20
    5cd0:	f5 0b       	sbc	r31, r21

00005cd2 <__udivmodsi4_ep>:
    5cd2:	66 1f       	adc	r22, r22
    5cd4:	77 1f       	adc	r23, r23
    5cd6:	88 1f       	adc	r24, r24
    5cd8:	99 1f       	adc	r25, r25
    5cda:	1a 94       	dec	r1
    5cdc:	69 f7       	brne	.-38     	; 0x5cb8 <__udivmodsi4_loop>
    5cde:	60 95       	com	r22
    5ce0:	70 95       	com	r23
    5ce2:	80 95       	com	r24
    5ce4:	90 95       	com	r25
    5ce6:	9b 01       	movw	r18, r22
    5ce8:	ac 01       	movw	r20, r24
    5cea:	bd 01       	movw	r22, r26
    5cec:	cf 01       	movw	r24, r30
    5cee:	08 95       	ret

00005cf0 <__divmodsi4>:
    5cf0:	97 fb       	bst	r25, 7
    5cf2:	09 2e       	mov	r0, r25
    5cf4:	05 26       	eor	r0, r21
    5cf6:	0e d0       	rcall	.+28     	; 0x5d14 <__divmodsi4_neg1>
    5cf8:	57 fd       	sbrc	r21, 7
    5cfa:	04 d0       	rcall	.+8      	; 0x5d04 <__divmodsi4_neg2>
    5cfc:	d7 df       	rcall	.-82     	; 0x5cac <__udivmodsi4>
    5cfe:	0a d0       	rcall	.+20     	; 0x5d14 <__divmodsi4_neg1>
    5d00:	00 1c       	adc	r0, r0
    5d02:	38 f4       	brcc	.+14     	; 0x5d12 <__divmodsi4_exit>

00005d04 <__divmodsi4_neg2>:
    5d04:	50 95       	com	r21
    5d06:	40 95       	com	r20
    5d08:	30 95       	com	r19
    5d0a:	21 95       	neg	r18
    5d0c:	3f 4f       	sbci	r19, 0xFF	; 255
    5d0e:	4f 4f       	sbci	r20, 0xFF	; 255
    5d10:	5f 4f       	sbci	r21, 0xFF	; 255

00005d12 <__divmodsi4_exit>:
    5d12:	08 95       	ret

00005d14 <__divmodsi4_neg1>:
    5d14:	f6 f7       	brtc	.-4      	; 0x5d12 <__divmodsi4_exit>
    5d16:	90 95       	com	r25
    5d18:	80 95       	com	r24
    5d1a:	70 95       	com	r23
    5d1c:	61 95       	neg	r22
    5d1e:	7f 4f       	sbci	r23, 0xFF	; 255
    5d20:	8f 4f       	sbci	r24, 0xFF	; 255
    5d22:	9f 4f       	sbci	r25, 0xFF	; 255
    5d24:	08 95       	ret

00005d26 <__prologue_saves__>:
    5d26:	2f 92       	push	r2
    5d28:	3f 92       	push	r3
    5d2a:	4f 92       	push	r4
    5d2c:	5f 92       	push	r5
    5d2e:	6f 92       	push	r6
    5d30:	7f 92       	push	r7
    5d32:	8f 92       	push	r8
    5d34:	9f 92       	push	r9
    5d36:	af 92       	push	r10
    5d38:	bf 92       	push	r11
    5d3a:	cf 92       	push	r12
    5d3c:	df 92       	push	r13
    5d3e:	ef 92       	push	r14
    5d40:	ff 92       	push	r15
    5d42:	0f 93       	push	r16
    5d44:	1f 93       	push	r17
    5d46:	cf 93       	push	r28
    5d48:	df 93       	push	r29
    5d4a:	cd b7       	in	r28, 0x3d	; 61
    5d4c:	de b7       	in	r29, 0x3e	; 62
    5d4e:	ca 1b       	sub	r28, r26
    5d50:	db 0b       	sbc	r29, r27
    5d52:	0f b6       	in	r0, 0x3f	; 63
    5d54:	f8 94       	cli
    5d56:	de bf       	out	0x3e, r29	; 62
    5d58:	0f be       	out	0x3f, r0	; 63
    5d5a:	cd bf       	out	0x3d, r28	; 61
    5d5c:	09 94       	ijmp

00005d5e <__epilogue_restores__>:
    5d5e:	2a 88       	ldd	r2, Y+18	; 0x12
    5d60:	39 88       	ldd	r3, Y+17	; 0x11
    5d62:	48 88       	ldd	r4, Y+16	; 0x10
    5d64:	5f 84       	ldd	r5, Y+15	; 0x0f
    5d66:	6e 84       	ldd	r6, Y+14	; 0x0e
    5d68:	7d 84       	ldd	r7, Y+13	; 0x0d
    5d6a:	8c 84       	ldd	r8, Y+12	; 0x0c
    5d6c:	9b 84       	ldd	r9, Y+11	; 0x0b
    5d6e:	aa 84       	ldd	r10, Y+10	; 0x0a
    5d70:	b9 84       	ldd	r11, Y+9	; 0x09
    5d72:	c8 84       	ldd	r12, Y+8	; 0x08
    5d74:	df 80       	ldd	r13, Y+7	; 0x07
    5d76:	ee 80       	ldd	r14, Y+6	; 0x06
    5d78:	fd 80       	ldd	r15, Y+5	; 0x05
    5d7a:	0c 81       	ldd	r16, Y+4	; 0x04
    5d7c:	1b 81       	ldd	r17, Y+3	; 0x03
    5d7e:	aa 81       	ldd	r26, Y+2	; 0x02
    5d80:	b9 81       	ldd	r27, Y+1	; 0x01
    5d82:	ce 0f       	add	r28, r30
    5d84:	d1 1d       	adc	r29, r1
    5d86:	0f b6       	in	r0, 0x3f	; 63
    5d88:	f8 94       	cli
    5d8a:	de bf       	out	0x3e, r29	; 62
    5d8c:	0f be       	out	0x3f, r0	; 63
    5d8e:	cd bf       	out	0x3d, r28	; 61
    5d90:	ed 01       	movw	r28, r26
    5d92:	08 95       	ret

00005d94 <memcpy>:
    5d94:	fb 01       	movw	r30, r22
    5d96:	dc 01       	movw	r26, r24
    5d98:	02 c0       	rjmp	.+4      	; 0x5d9e <memcpy+0xa>
    5d9a:	01 90       	ld	r0, Z+
    5d9c:	0d 92       	st	X+, r0
    5d9e:	41 50       	subi	r20, 0x01	; 1
    5da0:	50 40       	sbci	r21, 0x00	; 0
    5da2:	d8 f7       	brcc	.-10     	; 0x5d9a <memcpy+0x6>
    5da4:	08 95       	ret

00005da6 <strcmp>:
    5da6:	fb 01       	movw	r30, r22
    5da8:	dc 01       	movw	r26, r24
    5daa:	8d 91       	ld	r24, X+
    5dac:	01 90       	ld	r0, Z+
    5dae:	80 19       	sub	r24, r0
    5db0:	01 10       	cpse	r0, r1
    5db2:	d9 f3       	breq	.-10     	; 0x5daa <strcmp+0x4>
    5db4:	99 0b       	sbc	r25, r25
    5db6:	08 95       	ret

00005db8 <_exit>:
    5db8:	f8 94       	cli

00005dba <__stop_program>:
    5dba:	ff cf       	rjmp	.-2      	; 0x5dba <__stop_program>
